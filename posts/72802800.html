<!DOCTYPE html><html lang="default" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Linux系统编程 | SunDocker's Personal Blog</title><meta name="keywords" content="Computer,Linux"><meta name="author" content="SunDocker"><meta name="copyright" content="SunDocker"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="1 常用工具 1.1 gcc 工作流程概述：   预处理：头文件展开、宏替换、去除注释 gcc -E xxx.c -o xxx.i  xxx.i仍然是一个c文件 预处理工作本质是由cpp工具完成的，gcc命令会调用这个工具    编译：将c文件编译成汇编文件 gcc -S xxx.i -o xxx.s  这一步时间往往是最长的 编译工作由gcc工具完成    汇编：将汇编文件转换成二进制文件 gc">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux系统编程">
<meta property="og:url" content="https://sundocker.online/posts/72802800.html">
<meta property="og:site_name" content="SunDocker&#39;s Personal Blog">
<meta property="og:description" content="1 常用工具 1.1 gcc 工作流程概述：   预处理：头文件展开、宏替换、去除注释 gcc -E xxx.c -o xxx.i  xxx.i仍然是一个c文件 预处理工作本质是由cpp工具完成的，gcc命令会调用这个工具    编译：将c文件编译成汇编文件 gcc -S xxx.i -o xxx.s  这一步时间往往是最长的 编译工作由gcc工具完成    汇编：将汇编文件转换成二进制文件 gc">
<meta property="og:locale">
<meta property="og:image" content="https://sundocker.online/bgs/bg2.jpg">
<meta property="article:published_time" content="2022-10-10T03:40:02.000Z">
<meta property="article:modified_time" content="2023-01-04T04:29:25.452Z">
<meta property="article:author" content="SunDocker">
<meta property="article:tag" content="Computer">
<meta property="article:tag" content="Linux">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://sundocker.online/bgs/bg2.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://sundocker.online/posts/72802800"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="IzmEN2qRcorqxCIoxoXqi3hYOR3lP0li6nPF0PZq21g"/><meta name="baidu-site-verification" content="code-AGXLAKjYup"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"We didn't find any results for the search: ${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":300},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"Traditional Chinese Activated Manually","cht_to_chs":"Simplified Chinese Activated Manually","day_to_night":"Dark Mode Activated Manually","night_to_day":"Light Mode Activated Manually","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: true,
  isAnchor: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Linux系统编程',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-01-04 12:29:25'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 6 || hour >= 18
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-double-row-display@1.00/cardlistpost.min.css"/>
                        <style>
                        #recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags:before {
                            content:"\A";
                            white-space: pre;
                        }
                        #recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags > .article-meta__separator {
                            display:none
                        }
                        </style>
<link rel="stylesheet" href="/css/categorybar.css"><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.css" /><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiperstyle.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://unpkg.zhimg.com/hexo-butterfly-footer-beautify@1.0.0/lib/runtime.min.css" media="print" onload="this.media='all'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="SunDocker's Personal Blog" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">Loading...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">55</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">45</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">14</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home Page</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa-solid fa-warehouse"></i><span> Knowledge Repository</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/Computer-Theory"><i class="fa-fw fa-solid fa-book"></i><span> Computer Theory</span></a></li><li><a class="site-page child" href="/categories/Java-Kotlin"><i class="fa-fw fa-brands fa-java"></i><span> Java &amp; Kotlin</span></a></li><li><a class="site-page child" href="/categories/Data-Persistence"><i class="fa-fw fa-solid fa-database"></i><span> Data Persistence</span></a></li><li><a class="site-page child" href="/categories/Frontend"><i class="fa-fw fa-solid fa-code"></i><span> Frontend</span></a></li><li><a class="site-page child" href="/categories/Golang"><i class="fa-fw fas fa-brands fa-golang"></i><span> Golang</span></a></li><li><a class="site-page child" href="/categories/Operations"><i class="fa-fw fa-brands fa-docker"></i><span> Operations</span></a></li><li><a class="site-page child" href="/categories/Project-Management"><i class="fa-fw fa-brands fa-git-alt"></i><span> Project Management</span></a></li><li><a class="site-page child" href="/categories/C-C"><i class="fa-fw fa-solid fa-c"></i><span> C &amp; C++</span></a></li><li><a class="site-page child" href="/categories/Big-Data"><i class="fa-fw fa-solid fa-mountain-sun"></i><span> Big Data</span></a></li><li><a class="site-page child" href="/categories/AI"><i class="fa-fw fa-solid fa-robot"></i><span> AI</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa-solid fa-sun"></i><span> Life Sharing</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/Life-Sharing"><i class="fa-fw fa-solid fa-book-open"></i><span> Paper Reading</span></a></li><li><a class="site-page child" href="/categories/Life-Sharing"><i class="fa-fw fa-solid fa-music"></i><span> Pop Music Keyboard</span></a></li><li><a class="site-page child" href="/categories/Life-Sharing"><i class="fa-fw fa-solid fa-film"></i><span> Movie Review</span></a></li><li><a class="site-page child" href="/categories/Life-Sharing"><i class="fa-fw fa-solid fa-comment"></i><span> Life By-talk</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> Links</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/posts/6c24763b.html"><i class="fa-fw fa-solid fa-folder-tree"></i><span> Knowledge Tree</span></a></li><li><a class="site-page child" href="/posts/ed318fdc.html"><i class="fa-fw fa-solid fa-blog"></i><span> About This Blog</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About Me</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></li><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> Blogroll</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/bgs/bg2.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">SunDocker's Personal Blog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> Search</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home Page</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa-solid fa-warehouse"></i><span> Knowledge Repository</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/Computer-Theory"><i class="fa-fw fa-solid fa-book"></i><span> Computer Theory</span></a></li><li><a class="site-page child" href="/categories/Java-Kotlin"><i class="fa-fw fa-brands fa-java"></i><span> Java &amp; Kotlin</span></a></li><li><a class="site-page child" href="/categories/Data-Persistence"><i class="fa-fw fa-solid fa-database"></i><span> Data Persistence</span></a></li><li><a class="site-page child" href="/categories/Frontend"><i class="fa-fw fa-solid fa-code"></i><span> Frontend</span></a></li><li><a class="site-page child" href="/categories/Golang"><i class="fa-fw fas fa-brands fa-golang"></i><span> Golang</span></a></li><li><a class="site-page child" href="/categories/Operations"><i class="fa-fw fa-brands fa-docker"></i><span> Operations</span></a></li><li><a class="site-page child" href="/categories/Project-Management"><i class="fa-fw fa-brands fa-git-alt"></i><span> Project Management</span></a></li><li><a class="site-page child" href="/categories/C-C"><i class="fa-fw fa-solid fa-c"></i><span> C &amp; C++</span></a></li><li><a class="site-page child" href="/categories/Big-Data"><i class="fa-fw fa-solid fa-mountain-sun"></i><span> Big Data</span></a></li><li><a class="site-page child" href="/categories/AI"><i class="fa-fw fa-solid fa-robot"></i><span> AI</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa-solid fa-sun"></i><span> Life Sharing</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/Life-Sharing"><i class="fa-fw fa-solid fa-book-open"></i><span> Paper Reading</span></a></li><li><a class="site-page child" href="/categories/Life-Sharing"><i class="fa-fw fa-solid fa-music"></i><span> Pop Music Keyboard</span></a></li><li><a class="site-page child" href="/categories/Life-Sharing"><i class="fa-fw fa-solid fa-film"></i><span> Movie Review</span></a></li><li><a class="site-page child" href="/categories/Life-Sharing"><i class="fa-fw fa-solid fa-comment"></i><span> Life By-talk</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> Links</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/posts/6c24763b.html"><i class="fa-fw fa-solid fa-folder-tree"></i><span> Knowledge Tree</span></a></li><li><a class="site-page child" href="/posts/ed318fdc.html"><i class="fa-fw fa-solid fa-blog"></i><span> About This Blog</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About Me</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></li><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> Blogroll</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Linux系统编程</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2022-10-10T03:40:02.000Z" title="Created 2022-10-10 11:40:02">2022-10-10</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2023-01-04T04:29:25.452Z" title="Updated 2023-01-04 12:29:25">2023-01-04</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/C-C/">C &amp; C++</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word count:</span><span class="word-count">11.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading time:</span><span>38min</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Linux系统编程"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="1-常用工具">1 常用工具</h2>
<h3 id="1-1-gcc">1.1 gcc</h3>
<p><em>工作流程概述：</em></p>
<ol>
<li>
<p>预处理：<strong>头文件</strong>展开、<strong>宏</strong>替换、去除<strong>注释</strong></p>
<p><code>gcc -E xxx.c -o xxx.i</code></p>
<blockquote>
<p><code>xxx.i</code>仍然是一个<strong>c文件</strong></p>
<p>预处理工作本质是由<strong>cpp工具</strong>完成的，gcc命令会调用这个工具</p>
</blockquote>
</li>
<li>
<p>编译：将c文件编译成<strong>汇编文件</strong></p>
<p><code>gcc -S xxx.i -o xxx.s</code></p>
<blockquote>
<p>这一步时间往往是<strong>最长</strong>的</p>
<p>编译工作由<strong>gcc工具</strong>完成</p>
</blockquote>
</li>
<li>
<p>汇编：将汇编文件转换成<strong>二进制文件</strong></p>
<p><code>gcc -c xxx.s -o xxx.o</code></p>
<blockquote>
<p>汇编工作本质是由<strong>as工具</strong>完成的，gcc命令会调用这个工具</p>
</blockquote>
</li>
<li>
<p>链接：将<strong>函数库</strong>中相应的代码组合到目标文件中</p>
<p><code>gcc xxx.o -o xxx</code></p>
<blockquote>
<p>将所有相关的<code>.o</code>文件打包成一个<strong>可执行文件</strong>，并将<code>main</code>函数作为<strong>启动函数</strong></p>
<p>链接工作本质是由<strong>ld工具</strong>完成的，gcc命令会调用这个工具</p>
</blockquote>
<blockquote>
<p>可以直接调用链接的命令，这样会自动调用之前的三步：<code>gcc xxx.c -o xxx</code></p>
</blockquote>
</li>
</ol>
<hr>
<p><em>常用参数：</em></p>
<ul>
<li>
<p><code>-I 目录</code>：指定<strong>头文件</strong>所在目录</p>
<blockquote>
<p>头文件一般放在<code>include</code>目录下；如果是在<strong>同级目录</strong>就不用参数指定了</p>
</blockquote>
</li>
<li>
<p><code>-L 目录</code>：指定<strong>库文件</strong>所在目录</p>
<blockquote>
<p>库文件一般放在<code>lib</code>目录下</p>
</blockquote>
</li>
<li>
<p><code>-l 库名</code>：指定<strong>库文件</strong>的名字</p>
</li>
<li>
<p><code>-D 宏名</code>：指定一个宏</p>
<blockquote>
<p>经典使用场景是控制log的输出</p>
</blockquote>
</li>
<li>
<p><code>-O1</code>、<code>-O2</code>、<code>-O3</code>：生成汇编之前<strong>优化</strong>代码，<code>-O</code>后面数字越大，优化等级越大</p>
</li>
<li>
<p><code>-Wall</code>：输出<strong>警告</strong>信息</p>
</li>
<li>
<p><code>-g</code>：添加调试信息，之后可以用gdb工具调试</p>
</li>
</ul>
<hr>
<p><em>静态库：</em></p>
<ul>
<li>
<p>命名规则：<code>lib + 库的名字 + .a</code></p>
<blockquote>
<p><code>.a</code>文件一般放在<code>lib</code>目录下</p>
</blockquote>
</li>
<li>
<p>制作步骤</p>
<ol>
<li>
<p>生成<code>.o</code>文件：<code>gcc 所有需要的.c文件 -c -I 头文件所在目录</code></p>
</li>
<li>
<p>将生成的<code>.o</code>文件打包：<code>ar rcs lib库的名字.a 所有需要的.o文件</code></p>
<blockquote>
<p>使用<code>ar</code>打包工具</p>
</blockquote>
</li>
</ol>
</li>
<li>
<p>发布和使用静态库</p>
<ul>
<li>发布静态库</li>
<li>提供头文件，在源程序中引入</li>
<li>在编译时指定静态库，生成可执行程序：
<ul>
<li><code>gcc 源程序.c lib库的名字.a -I 头文件所在目录 -o xxx</code></li>
<li><code>gcc 源程序.c -I 头文件所在目录 -L 静态库所在目录 -l 库的名字 -o xxx</code></li>
</ul>
</li>
<li>运行可执行程序</li>
</ul>
</li>
<li>
<p>查看组成静态库的<code>.o</code>文件：<code>nm lib库名.a</code></p>
<ul>
<li>打包的最小单元是<code>.o</code>文件，并不会直接把整个库打包</li>
</ul>
</li>
<li>
<p>静态库的优点和缺点</p>
<ul>
<li>优点
<ul>
<li>发布程序时，不需要再<strong>提供对应库</strong></li>
<li>加载静态库的<strong>速度</strong>快</li>
</ul>
</li>
<li>缺点
<ul>
<li>增加了应用程序的<strong>大小</strong></li>
<li>库发生<strong>更新</strong>后必须<strong>重新编译</strong>程序</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<p><em>共享库/动态库：</em></p>
<ul>
<li>
<p>命名规则：<code>lib + 库名 + .so</code></p>
</li>
<li>
<p>制作步骤</p>
<ol>
<li>
<p>生成与位置无关的<code>.o</code>文件：<code>gcc -fPIC -c 所有需要的.c文件</code></p>
<blockquote>
<p>生成静态库的时候，是与位置有关的<code>.o</code></p>
<ul>
<li>与位置有关的<code>.o</code>，直接“静态地”存放在**<code>.text</code>代码段**</li>
<li>与位置无关的<code>.o</code>，在程序运行时才会动态加载到<strong>虚拟地址空间的共享库</strong>中</li>
</ul>
</blockquote>
</li>
<li>
<p>将<code>.o</code>文件打包成共享库：<code>gcc -shared lib库名.so -o 所有需要的.o文件</code></p>
</li>
</ol>
</li>
<li>
<p>发布和使用共享库</p>
<ul>
<li>
<p>发布静态库</p>
</li>
<li>
<p>提供头文件，在源程序中引入</p>
</li>
<li>
<p>在编译时指定动态库，生成可执行程序：</p>
<ul>
<li><code>gcc 源程序.c lib库名.so -I 头文件所在目录 -o xxx</code></li>
<li><code>gcc 源程序.c -I 头文件所在目录 -L 共享库所在目录 -l 库的名字 -o xxx</code></li>
</ul>
</li>
<li>
<p>运行可执行程序</p>
<blockquote>
<p>解决自定义动态库无法加载的问题：</p>
<hr>
<p><code>ldd 可执行程序</code>可以查看程序<strong>依赖的所有共享库</strong></p>
<p>一般来说，程序都会依赖一个库，叫做动态链接器：<code>/lib64/ld-linux-x86-64.so.2</code></p>
<ul>
<li>
<p>动态链接器可以<strong>加载程序依赖的其他动态库</strong></p>
</li>
<li>
<p>动态链接器的查找规则：根据某些<strong>环境变量</strong>查找</p>
<blockquote>
<p>系统提供的动态库一般都放在<code>/lib</code>下（但不要把自己制作的库放进去</p>
<p>**环境变量<code>LD_LIBRARY_PATH</code>**也在动态链接器的查找范围内，且是优先被查找的</p>
</blockquote>
</li>
</ul>
<p>所以如果要使用自定义动态库，可以执行<code>export LD_LIBRARY_PATH = xxx</code>，让动态链接器能找到自定义动态库，这样可以临时生效，用于<strong>测试</strong></p>
<blockquote>
<p>如果不只要临时生效，可以把<code>export</code>语句写入<code>~/.bachrc</code>文件中再重启终端，但这种做法比较少见</p>
</blockquote>
<p>还可以使用<strong>配置文件</strong>的方式：</p>
<ol>
<li>
<p>以管理员权限修改<code>/etc/ld.so.conf</code>，将自定义动态库路径写入新行</p>
</li>
<li>
<p>使配置文件生效：<code>ldconfig -v</code></p>
<blockquote>
<p><code>-v</code>代表打印提示信息，也可以不加</p>
</blockquote>
</li>
</ol>
</blockquote>
</li>
</ul>
</li>
<li>
<p>动态库的优点和缺点</p>
<ul>
<li>
<p>优点</p>
<ul>
<li>
<p>不会把动态库打包到应用程序中，<strong>体积小</strong></p>
</li>
<li>
<p>库发生<strong>更新</strong>后可以不需要<strong>重新编译</strong>程序</p>
<blockquote>
<p>前提是<strong>接口</strong>没有发生太大变化</p>
</blockquote>
</li>
</ul>
</li>
<li>
<p>缺点</p>
<ul>
<li>发布程序时，还需要再<strong>提供对应库</strong></li>
<li>加载动态库的<strong>速度</strong>相对较慢</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="1-2-gdb">1.2 gdb</h3>
<p><em>概述：</em></p>
<ul>
<li>GDB（GNU Debugger）是GCC的调试工具</li>
</ul>
<hr>
<p><em>常用指令：</em></p>
<blockquote>
<p>编译时需要加<code>-g</code>选项，通过<code>gdb 可执行程序</code>可以开启gdb调试</p>
</blockquote>
<ul>
<li>
<p>工作目录</p>
<ul>
<li><code>pwd</code>：查看当前工作目录</li>
<li><code>cd</code>：切换工作目录</li>
</ul>
</li>
<li>
<p>运行时参数</p>
<ul>
<li><code>set args 参数1 参数2 ...</code>：指定运行时参数</li>
<li><code>show args</code>：查看设置好的运行时参数</li>
</ul>
</li>
<li>
<p>查看源代码</p>
<blockquote>
<p>l：list，列出10行</p>
</blockquote>
<ul>
<li><code>l 要查看的文件名:行号</code>：显示指定文件某行前后的代码</li>
<li><code>l 要查看的文件名:函数名</code>：显示指定文件某函数定义前后的代码</li>
<li><code>l</code>：从上一次列出的代码后继续列出代码，或是从程序入口开始列出代码</li>
<li><code>set listsize count</code>：设置一次显示的代码行数</li>
<li><code>show listsize</code>：查看一次显示的代码行数</li>
</ul>
</li>
<li>
<p>设置断点</p>
<blockquote>
<p>b：break</p>
</blockquote>
<ul>
<li>
<p><code>b 行号</code>：（在当前所在文件中）设置一个断点</p>
</li>
<li>
<p><code>b 行号 if 逻辑表达式</code>：当逻辑表达式成立时断点才有效</p>
<blockquote>
<p>注意，如果是设置循环的条件停止，要把断点设置在<code>&#123;&#125;</code>代码块里</p>
</blockquote>
</li>
<li>
<p><code>d 断点编号范围</code>：删除断点。如果不加断点编号范围，则删除所有断点</p>
<blockquote>
<p>d：delete</p>
<p><code>范围</code>可以直接写一个数字，也可以写类似<code>3-7</code>这种</p>
</blockquote>
</li>
<li>
<p><code>disable 断点编号范围</code>：让指定断点暂时失效</p>
</li>
<li>
<p><code>enable 断点编号范围</code>：让指定断点重新生效</p>
</li>
</ul>
</li>
<li>
<p>运行程序</p>
<ul>
<li>
<p><code>start</code>：开始运行程序，等待调试（只执行一步）</p>
</li>
<li>
<p><code>r</code>：运行程序，直到断点或运行结束</p>
<blockquote>
<p>r：run</p>
</blockquote>
</li>
<li>
<p><code>n</code>：单步执行</p>
<blockquote>
<p>n：next</p>
</blockquote>
</li>
<li>
<p><code>c</code>：继续运行程序，直到断点或运行结束</p>
<blockquote>
<p>c：continue</p>
</blockquote>
</li>
<li>
<p><code>s</code>：进入当前行中的函数内部</p>
<blockquote>
<p>s：step</p>
</blockquote>
</li>
<li>
<p><code>u</code>：跳出循环</p>
<blockquote>
<p>u：until</p>
<p>相当于程序中的<code>break</code>关键字</p>
</blockquote>
</li>
<li>
<p><code>finish</code>：跳出之前进入的函数</p>
<blockquote>
<p>要求之后不能有断点出现，否则无法跳出</p>
</blockquote>
</li>
</ul>
</li>
<li>
<p>打印信息</p>
<ul>
<li><code>p 表达式</code>：打印表达式的值</li>
<li><code>ptype 表达式</code>：打印表达式的类型</li>
<li><code>display 表达式</code>：追踪打印表达式的值，每运行一次都会打印</li>
<li><code>undisplay 被追踪的表达式编号范围</code>：取消追踪的表达式</li>
</ul>
</li>
<li>
<p>设置值</p>
<ul>
<li><code>set var 变量名=变量值 </code>：设置变量的值</li>
</ul>
</li>
<li>
<p>查看信息</p>
<blockquote>
<p>i：info</p>
</blockquote>
<ul>
<li><code>i b</code>：查看断点信息</li>
<li><code>i display</code>：查看被追踪的表达式信息</li>
</ul>
</li>
</ul>
<h3 id="1-3-makefile">1.3 makefile</h3>
<p><em>一个规则：</em></p>
<ul>
<li>
<p>makefile文件命名规则：</p>
<ul>
<li><code>makefile</code></li>
<li><code>Makefile</code></li>
</ul>
</li>
<li>
<p>运行makefile：</p>
<ul>
<li><code>make</code>：生成终极目标</li>
<li><code>make xxx</code>：生成<code>xxx</code>目标，运行对应规则的命令</li>
</ul>
</li>
<li>
<p>规则三要素：目标、依赖、命令</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如下方式定义一条“规则”</span></span><br><span class="line"><span class="section">目标: 依赖的所有文件</span></span><br><span class="line">	gcc命令</span><br></pre></td></tr></table></figure>
<ul>
<li>注意命令前必须有一个<code>tab</code>缩进</li>
<li>默认从当前目录中寻找依赖文件，否则就要指定路径</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">app: main.o add.o sub.o mul.o</span></span><br><span class="line">    gcc main.o add.o sub.o mul.o -o app</span><br><span class="line"></span><br><span class="line"><span class="section">main.o: main.c</span></span><br><span class="line">    gcc -c main.c</span><br><span class="line"></span><br><span class="line"><span class="section">add.o: add.c</span></span><br><span class="line">    gcc -c add.c</span><br><span class="line"></span><br><span class="line"><span class="section">mul.o: mul.c</span></span><br><span class="line">    gcc -c mul.c</span><br><span class="line"></span><br><span class="line"><span class="section">sub.o: sub.c</span></span><br><span class="line">    gcc -c sub.c</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>如果有多条规则，默认<strong>第1条规则</strong>的目标为<strong>终极目标</strong>，后面的规则都是为此服务的</p>
<blockquote>
<p>终极目标可以向下查找依赖项的生成，然后从下向上执行</p>
</blockquote>
</li>
<li>
<p>如上所示分开生成<code>.o</code>文件，则执行<code>make</code>时<strong>只会编译修改过的文件</strong></p>
<blockquote>
<p>终极目标是<code>app</code>，其他的可以不变；</p>
<p>当<strong>依赖的更新时间</strong>晚于<strong>目标的更新时间</strong>时，会再次执行<strong>命令</strong></p>
</blockquote>
</li>
</ul>
</li>
<li>
<p><code>clean</code>规则与伪目标</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    rm <span class="variable">$(obj)</span> <span class="variable">$(target)</span> -f</span><br></pre></td></tr></table></figure>
<ul>
<li><code>make clean</code>即可运行命令</li>
<li>解决目录下有名为<code>clean</code>的文件的问题：声明伪目标<code>.PHONY</code></li>
</ul>
</li>
</ul>
<hr>
<p><em>三个变量：</em></p>
<ul>
<li>
<p><code>变量名=变量值</code></p>
<p><code>$(变量名)</code></p>
<ul>
<li>可以在makefile中以<code>变量名=变量值</code>和格式定义变量</li>
<li>然后用<code>$(变量名)</code>引用</li>
</ul>
<p><code>%</code></p>
<ul>
<li>
<p>向下寻找依赖时，会自动匹配下方规则中的<code>%</code>，替换成要寻找的依赖，生成一条规则</p>
<blockquote>
<p>替换时会自动将<code>.后缀</code>去掉</p>
</blockquote>
</li>
</ul>
</li>
<li>
<p><code>$&lt;</code>：规则中的<strong>第一个依赖</strong></p>
<p><code>$^</code>：规则中的<strong>所有依赖</strong></p>
</li>
<li>
<p><code>$@</code>：规则中的<strong>目标</strong></p>
</li>
</ul>
<blockquote>
<p><code>$&lt; $^ $@</code>是makefile中的自动变量，只能在规则的<strong>命令</strong>中使用</p>
</blockquote>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">obj = main.o add.o sub.o mul.o</span><br><span class="line">target = app </span><br><span class="line"></span><br><span class="line"><span class="section">$&#123;target&#125;: $&#123;obj&#125; </span></span><br><span class="line">    gcc $&#123;obj&#125; -o $&#123;target&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">%.o: %.c </span></span><br><span class="line">    gcc -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>makefile维护的变量</p>
<blockquote>
<p>通常为<strong>大写</strong>。用户自定义变量通常为小写</p>
</blockquote>
<ul>
<li><code>CC</code>：默认值<code>cc</code>，也就是<code>gcc</code></li>
<li><code>CPPFLAGS</code>：预处理时需要的选项，如<code>-I</code></li>
<li><code>CFLAGS</code>：编译的时候使用的参数，如<code>-Wall -D -g -c</code></li>
<li><code>LDFLAGS</code>：链接时使用的选项，如<code>-L -l</code></li>
</ul>
</li>
</ul>
<hr>
<p><em>两个函数：</em></p>
<ul>
<li>
<p><code>wildcard</code>：</p>
<p><code>src = $(wildcard 某目录下用*匹配的文件)</code></p>
</li>
<li>
<p><code>patsubst</code>：</p>
<p><code>obj = $(patsubst 某目录下用%匹配的文件, 保留%后要替换成的样子, $(src))</code></p>
</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">target = app </span><br><span class="line">src = <span class="variable">$(<span class="built_in">wildcard</span> ./*.c)</span></span><br><span class="line">obj = <span class="variable">$(<span class="built_in">patsubst</span> ./%.c, ./%.o, <span class="variable">$(src)</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="section">$&#123;target&#125;: $&#123;obj&#125; </span></span><br><span class="line">    gcc $&#123;obj&#125; -o $&#123;target&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">%.o: %.c </span></span><br><span class="line">    gcc -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    rm <span class="variable">$(obj)</span> <span class="variable">$(target)</span> -f</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="2-内存与文件系统">2 内存与文件系统</h2>
<h3 id="2-1-内存管理">2.1 内存管理</h3>
<p><em>虚拟地址空间：</em></p>
<ul>
<li>
<p><u>大小</u>：对于32bit操作系统，有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>32</mn></msup><mo>=</mo><mn>4</mn><mi>G</mi></mrow><annotation encoding="application/x-tex">2^{32}=4G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">32</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">4</span><span class="mord mathnormal">G</span></span></span></span>的可用虚拟地址空间，从0开始</p>
<blockquote>
<p>为进程按需分配物理内存，不会直接分配4G</p>
</blockquote>
</li>
<li>
<p><u>内核区</u>：3G~4G</p>
<blockquote>
<p>不允许用户直接操作</p>
</blockquote>
<ul>
<li>
<p>PCB：</p>
<ul>
<li>
<p>文件描述符表：一个大小为1024的数组，数组<strong>索引</strong>就是<strong>文件描述符</strong>，数组元素代表文件</p>
<p>0：<code>STDIN_FILENO</code></p>
<p>1：<code>STDOUT_FILENO</code></p>
<p>2：<code>STDERR_FILENO</code></p>
<blockquote>
<p>标准输入、标准输出、标准错误默认是打开状态</p>
</blockquote>
<p>3~1023：每打开一个新文件，会占用<strong>空闲文件描述符</strong>中最小的那个</p>
</li>
<li>
<p>…（PCB中的其他内容）</p>
</li>
</ul>
</li>
<li>
<p>…（内核区的其他内容）</p>
</li>
</ul>
</li>
<li>
<p><u>用户区</u>：0~3G</p>
<blockquote>
<p>允许用户访问并操作；</p>
<p>接下来的<strong>从低地址向高地址</strong>介绍</p>
</blockquote>
<ul>
<li>
<p>受保护的地址（header）：0~4K</p>
<blockquote>
<p><code>#define NULL (void*)0</code>指向的就是这里</p>
</blockquote>
</li>
<li>
<p>ELF段：ELF是Linux下<strong>可执行文件格式</strong></p>
<blockquote>
<p><code>file a.out</code>命令可以查看<code>a.out</code>的文件格式</p>
</blockquote>
<ul>
<li>
<p>.text段：只读的<strong>代码段</strong>，二进制机器指令</p>
<blockquote>
<p>代码段也可以包括一些<strong>静态库</strong></p>
</blockquote>
</li>
<li>
<p>.rodata段：只读的数据段、符号段等</p>
</li>
<li>
<p>.data段：已初始化的<strong>全局变量</strong>，可读写</p>
</li>
<li>
<p>.bss段：未初始化的<strong>全局变量</strong>，可读写</p>
</li>
</ul>
</li>
<li>
<p>堆空间：从低地址向高地址增长，<code>malloc</code>相关函数分配的地址空间</p>
</li>
<li>
<p>共享库：加载程序执行时引用的<strong>动态链接库</strong>（C标准库等）</p>
<blockquote>
<p>由于加载到共享库的位置不定，所以动态库中应当时位置无关代码（相对地址）</p>
</blockquote>
</li>
<li>
<p>栈空间：从高地址向低地址增长，主要存放<strong>函数栈帧</strong>，包括调用信息、局部变量等</p>
</li>
<li>
<p>命令行参数：<code>argv[]</code></p>
</li>
<li>
<p>环境变量（env）</p>
</li>
</ul>
</li>
<li>
<p><u>虚拟地址空间的优点</u></p>
<ul>
<li>有利于编译器和操作系统利用<strong>离散的物理地址空间</strong>，为进程提供虚拟的<strong>连续地址空间</strong></li>
<li>有利于进程之间<strong>地址空间的隔离</strong></li>
<li>有利于在逻辑上<strong>扩展物理内存</strong></li>
</ul>
</li>
</ul>
<hr>
<p><em>MMU的基本工作原理</em>：</p>
<ul>
<li>
<p>Memory Management Unit，内存管理单元，位于CPU内部</p>
</li>
<li>
<p>主要功能</p>
<ul>
<li>
<p>虚拟内存和物理内存的映射，按**页（4k大小）**分配物理地址空间</p>
<ul>
<li>
<p>不同进程的<strong>内核区</strong>映射到<strong>相同的内核物理内存</strong></p>
<blockquote>
<p>当然，不同进程的PCB不同，只是位于同一块内核物理内存中</p>
</blockquote>
</li>
<li>
<p>不同进程的用户区映射到不同的物理内存</p>
</li>
</ul>
</li>
<li>
<p>管理<strong>内存访问权限</strong>（用户级、内核级）</p>
</li>
</ul>
</li>
</ul>
<h3 id="2-3-IO">2.3 IO</h3>
<h2 id="3-进程与线程">3 进程与线程</h2>
<h3 id="3-1-进程相关数据结构">3.1 进程相关数据结构</h3>
<p><em>进程控制块PCB：</em></p>
<ul>
<li>
<p>Linux内核的进程控制块是<code>task_struct</code>结构体</p>
<blockquote>
<p><code>/usr/src/linux-headers-3.16.0-30/include/linux/sched.h</code>文件中可以查看<code>struct task_struct</code>结构体定义</p>
</blockquote>
</li>
<li>
<p><code>task_struct</code>结构体重要成员</p>
<ul>
<li>
<p>进程<strong>描述</strong>信息：</p>
<ul>
<li>
<p>进程标识符（<strong>PID</strong>）：系统中每个进程都有<strong>唯一</strong>的id，用<code>pid_t</code>表示其<strong>类型</strong>，本质是非负整数</p>
<blockquote>
<p>Unix系统的第一个进程<strong>init进程的pid为1</strong></p>
</blockquote>
</li>
<li>
<p>用户id和组id</p>
</li>
</ul>
</li>
<li>
<p>进程<strong>控制和管理</strong>信息：</p>
<ul>
<li>进程当前<strong>状态</strong></li>
<li><strong>信号</strong>相关的信息</li>
<li><strong>会话</strong>（Session）和<strong>进程组</strong></li>
</ul>
</li>
<li>
<p><strong>资源分配</strong>清单：</p>
<ul>
<li>
<p>描述<strong>虚拟地址空间</strong>的信息</p>
</li>
<li>
<p>进程可以使用的<strong>资源上限</strong>（Resource Limit）</p>
<blockquote>
<p><code>ulimit -a</code>命令可以查看一些资源上限</p>
</blockquote>
</li>
</ul>
</li>
<li>
<p><strong>处理机</strong>相关信息：</p>
<ul>
<li>进程<strong>切换</strong>时需要保存和恢复的<strong>寄存器</strong></li>
<li>描述<strong>控制终端</strong>的信息</li>
<li>当前<strong>工作目录</strong>位置</li>
<li><code>umask</code>掩码</li>
<li><strong>文件描述符</strong>表</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<p><em>环境变量：</em></p>
<ul>
<li>
<p>操作系统中用来<strong>指定运行环境</strong>的一些参数</p>
</li>
<li>
<p>特征：</p>
<ul>
<li>本质是<strong>字符串</strong></li>
<li>统一的格式：<code>名=值1:值2:值3</code></li>
<li>描述<strong>进程环境信息</strong></li>
</ul>
</li>
<li>
<p><strong>shell进程</strong>的常见环境变量</p>
<ul>
<li>
<p>PATH：记录<strong>可执行</strong>程序的<strong>搜索路径</strong></p>
</li>
<li>
<p>SHELL：记录当前所使用的<strong>命令解析器</strong></p>
</li>
<li>
<p>HOME：当前用户家目录</p>
</li>
<li>
<p>LANG：当前使用的语言和本地信息</p>
<blockquote>
<p>决定了字符编码、时间、货币等信息的显示格式</p>
</blockquote>
</li>
<li>
<p>TERM：当前终端类型</p>
</li>
</ul>
</li>
<li>
<p>在c程序中使用环境变量：</p>
<ul>
<li>
<p>存储形式：<code>char *[]</code>数组，数组名为<code>environ</code>，内部存储字符串，<code>NULL</code>作为哨兵结尾</p>
</li>
<li>
<p>加载位置：位于用户区，高于stack的起始位置</p>
</li>
<li>
<p>引入环境变量表：<code>extern char **environ</code></p>
</li>
<li>
<p>相关函数</p>
<ul>
<li><code>char *getenv(const char *name);</code></li>
<li><code>int setenv(const char *name, const char *value, int overwrite)</code></li>
<li><code>int unsetenv(const char *name);</code></li>
</ul>
<blockquote>
<p><code>man getenv</code>、<code>man setenv</code>、<code>man unsetenv</code></p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h3 id="3-2-进程控制">3.2 进程控制</h3>
<p><em>创建进程：</em></p>
<ul>
<li>
<p>方式一：<strong>运行可执行程序</strong>时，就会创建进程</p>
<blockquote>
<p>一般可执行程序对应进程的<u>父进程是<code>bash</code>/shell进程</u>，<br>
shell进程会将前台交给该进程，自己到后台去，直到该进程结束，再回到前台</p>
</blockquote>
</li>
<li>
<p>方式二：<code>pid_t fork(void);</code></p>
<blockquote>
<p><code>#include &lt;unistd.h&gt;</code>：Unix系统标准头文件</p>
</blockquote>
<ul>
<li>
<p>创建n个进程：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (i &lt; n) &#123;</span><br><span class="line">    <span class="comment">// child process</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// parent process</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>刚fork之后：</p>
<ul>
<li>父子相同处：全局变量、.data、.text、栈、堆、环境变量、用户ID、宿主目录、进程工作目录、信号处理方式…</li>
<li>父子不同处：进程ID、fork返回值、父进程ID、进程运行时间、闹钟(定时器)、未决信号集</li>
</ul>
</li>
<li>
<p><strong>读时共享写时复制</strong></p>
<ul>
<li>共享的是<strong>物理地址空间</strong>，虚拟的地址空间当然可以直接复制多个</li>
</ul>
</li>
<li>
<p>父子进程的共享资源</p>
<ul>
<li>
<p>文件描述符</p>
<blockquote>
<p>打开文件的结构体</p>
</blockquote>
</li>
<li>
<p>mmap建立的映射区</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<p><em>进程描述信息：</em></p>
<ul>
<li>进程id相关
<ul>
<li>获得进程id：<code>pid_t getpid(void);</code></li>
<li>获得父进程id：<code>pid_t getppid(void);</code></li>
</ul>
</li>
<li>用户id相关
<ul>
<li>获取当前进程实际用户ID：<code>uid_t getuid(void);</code></li>
<li>获取当前进程有效用户ID：<code>uid_t geteuid(void);</code></li>
<li>获取当前进程实际用户组ID：<code>gid_t getgid(void);</code></li>
<li>获取当前进程有效用户组ID：<code>gid_t getegid(void);</code></li>
</ul>
</li>
</ul>
<hr>
<p><em><code>exec</code>函数族：</em></p>
<ul>
<li>
<p>fork创建的子进程往往要调用一种exec函数以执行另一个程序。当进程调用一种exec函数时，该进程的用户空间<strong>代码和数据</strong>完全被新程序<strong>替换</strong>，从新程序的<strong>启动例程</strong>开始执行</p>
<blockquote>
<p>启动例程：调用<code>main</code>函数的函数</p>
<p>调用exec并<strong>不创建新进程</strong>，所以调用exec前后该<strong>进程的id并未改变</strong></p>
<p>一个程序调用了<code>exec</code>之后，在不出错的情况下，不再有返回值，原程序后续代码不会执行，若出错了才有返回值，并执行原程序后续代码</p>
</blockquote>
</li>
<li>
<p>:star:<code>int execlp(const char *file, const char *arg, ...);</code></p>
<blockquote>
<p>l：list，p：path</p>
</blockquote>
<ul>
<li>加载一个进程，要依赖系统当前的PATH环境变量</li>
<li><code>file</code>：可执行程序名</li>
<li><code>arg, ...</code>：命令行参数，从<code>argv[0]</code>开始，可变参要以<code>NULL</code>结尾</li>
</ul>
<blockquote>
<p>举例：<code>execlp(&quot;ls&quot;, &quot;ls&quot;, &quot;-l&quot;, &quot;-F&quot;, NULL);</code></p>
</blockquote>
</li>
<li>
<p>:star:<code>int execl(const char *path, const char *arg, ...);</code></p>
<ul>
<li>加载一个进程， 通过<code>路径+程序名</code>来加载，不需要依赖系统当前的PATH环境变量</li>
</ul>
<blockquote>
<p>举例：<code>execl(&quot;/bin/ls&quot;, &quot;ls&quot;, &quot;-l&quot;, &quot;-F&quot;, NULL);</code></p>
</blockquote>
</li>
<li>
<p><code>int execle(const char *path, const char *arg, ..., char *const envp[]);</code></p>
<ul>
<li>需要引入新的环境变量表</li>
</ul>
</li>
<li>
<p><code>int execv(const char *path, char *const argv[]);</code></p>
<blockquote>
<p>v：vector</p>
</blockquote>
</li>
<li>
<p><code>int execvp(const char *file, char *const argv[]);</code></p>
</li>
<li>
<p><code>int execve(const char *path, char *const argv[], char *const envp[]);</code></p>
<ul>
<li>只有<code>execve</code>是真正的系统调用</li>
</ul>
</li>
</ul>
<hr>
<p><em>回收子进程：</em></p>
<ul>
<li>
<p>孤儿进程：父进程先于子进程结束，则子进程成为孤儿进程，子进程的父进程成为init进程</p>
<blockquote>
<p>“init进程”可能是整个系统的init进程，也可能是用户的init进程</p>
</blockquote>
</li>
<li>
<p>僵尸进程：进程终止，父进程尚未回收，子进程**残留资源（PCB）**存放于内核中，变成僵尸（Zombie）进程。</p>
<blockquote>
<p>所谓回收就是在<strong>回收PCB</strong></p>
</blockquote>
</li>
<li>
<p><code>pid_t wait(int *status)</code></p>
<ul>
<li>
<p>三个功能</p>
<ul>
<li><strong>阻塞</strong>并等待一个子进程退出</li>
<li><strong>回收</strong>子进程残留资源</li>
<li>获取子进程结束<strong>状态</strong>(退出原因)</li>
</ul>
</li>
<li>
<p>返回-1代表出错（无子进程）</p>
</li>
<li>
<p>用<code>status</code>结合<strong>宏函数</strong>判断子进程终止原因</p>
<ul>
<li>
<p>:star:<code>WIFEXITED(status)</code>：返回值非0代表子进程<strong>正常结束</strong></p>
<p>如上宏为真可以使用此宏<code>WEXITSTATUS(status)</code>：获取进程<strong>退出状态</strong>(<code>exit</code>的参数)</p>
</li>
<li>
<p>:star:<code>WIFSIGNALED(status)</code>：返回值非0代表<strong>异常结束</strong></p>
<blockquote>
<p>Linux中所有异常结束都是因为收到了<strong>信号</strong></p>
</blockquote>
<p>如上宏为真可以使用此宏<code>WTERMSIG(status)</code>：取得使子进程终止的那个<strong>信号的编号</strong></p>
</li>
<li>
<p><code>WIFSTOPPED(status)</code>：返回值非0代表子进程处于<strong>暂停状态</strong></p>
<p>如上宏为真可以使用此宏<code>WSTOPSIG(status)</code>：获取使子进程暂停的那个<strong>信号的编号</strong></p>
<blockquote>
<p><code>WIFCONTINUED(status)</code>为真 → 子进程暂停后已经继续运行</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p><code>pid_t waitpid(pid_t pid, int *status, int options);</code></p>
<ul>
<li><code>pid</code>：要回收的子进程id
<ul>
<li>:star:大于0则回收指定id子进程</li>
<li>:star:为-1则回收任意子进程（相当于<code>wait</code>）</li>
<li>为0则回收和当前调用waitpid的进程同一个<strong>进程组</strong>的所有子进程</li>
<li>小于-1则回收指定<strong>进程组</strong>内的任意子进程</li>
</ul>
</li>
<li><code>options</code>：若指定为0则<strong>阻塞</strong>；若指定为<code>WNOHANG</code>则<strong>不阻塞</strong>，只是检查子进程是否结束，结束则回收，否则<strong>返回0</strong>并继续运行</li>
</ul>
</li>
</ul>
<h3 id="3-3-进程间通信">3.3 进程间通信</h3>
<p><em>管道：</em></p>
<hr>
<p><em><code>mmap</code></em>：</p>
<h3 id="3-4-进程信号">3.4 进程信号</h3>
<p><em>信号的基本概念：</em></p>
<ul>
<li>
<p>信号是信息的载体，有如下<strong>特征</strong>：</p>
<ul>
<li>
<p>简单</p>
<blockquote>
<p>信号的<strong>开销很小</strong>，就算不使用信号也会有这样的开销</p>
</blockquote>
</li>
<li>
<p>不能携带大量信息</p>
<blockquote>
<p>一般来说只能带一个<strong>标志</strong>过去</p>
</blockquote>
</li>
<li>
<p>满足某个<strong>特设条件</strong>才发送</p>
</li>
</ul>
</li>
<li>
<p>信号<strong>机制</strong>：</p>
<ul>
<li>
<p>进程收到信号后，不管执行到程序的什么位置，都要<strong>中断</strong>运行去处理信号，处理完毕再继续执行</p>
<blockquote>
<p>采用与<strong>硬件中断</strong>类似的异步模式。但信号是<strong>软件层面</strong>上实现的<strong>中断</strong>，早期常被称为“软中断”，有一定<strong>延时性</strong>（相对于硬件来说）</p>
</blockquote>
</li>
<li>
<p>:star:<strong>每个进程收到的所有信号，都是由<u>内核负责产生并发送</u>的，<u>内核处理</u></strong>:star:</p>
</li>
</ul>
</li>
<li>
<p>信号<strong>产生</strong>的五种方式：</p>
<ul>
<li>终端按键产生</li>
<li>硬件异常产生</li>
<li>命令产生</li>
<li>系统调用产生</li>
<li>软件条件产生</li>
</ul>
</li>
<li>
<p>信号<strong>状态</strong>：</p>
<ul>
<li>
<p><strong>递达</strong>：递送并且到达进程</p>
<blockquote>
<p>内核产生信号后会<strong>立刻发送</strong>给相应进程</p>
</blockquote>
</li>
<li>
<p><strong>阻塞</strong>（屏蔽、未决）：信号产生后受到阻塞，未能递达进程</p>
</li>
</ul>
</li>
<li>
<p>信号的<strong>编号</strong>与<strong>信号集</strong></p>
<ul>
<li>
<p>信号<strong>编号</strong></p>
<ul>
<li>
<p>可以使用<code>kill –l</code>命令查看当前系统可使用的信号有哪些</p>
</li>
<li>
<p>1-31号信号称之为<strong>常规信号</strong>（也叫普通信号或标准信号）</p>
</li>
<li>
<p>34-64称之为实时信号</p>
<blockquote>
<p>与嵌入式开发和驱动编程有关</p>
</blockquote>
</li>
</ul>
<blockquote>
<p><code>man 7 signal</code>可以查看相关文档</p>
</blockquote>
</li>
<li>
<p><strong>阻塞信号集(信号屏蔽字)</strong></p>
<ul>
<li>
<p>将某些信号加入集合，对他们设置屏蔽，收到这些信号时，对其的处理将推迟到解除屏蔽后</p>
<blockquote>
<p>常规信号会阻塞但<strong>不支持排队</strong>，产生多次<strong>只记录一次</strong></p>
</blockquote>
</li>
</ul>
</li>
<li>
<p><strong>未决信号集</strong></p>
<ul>
<li>
<p>信号产生后未决信号集中<strong>描述该信号的位</strong>立刻翻转为1，表信号处于未决状态，信号被处理后对应位再翻转为0</p>
</li>
<li>
<p>信号产生后由于某些原因(主要是阻塞)不能抵达，这类信号的集合称之为未决信号集。</p>
<blockquote>
<p>在屏蔽解除前，信号一直处于未决状态</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>信号的<strong>三种处理方式</strong></p>
<ul>
<li>执行默认动作
<ul>
<li>Term：终止进程</li>
<li>Ign：忽略信号（默认即时对该种信号忽略操作）</li>
<li>Core：终止进程并生成<strong>Core文件</strong>（记录进程死亡原因， 可用于gdb调试）</li>
<li>Stop：暂停进程</li>
<li>Cont：继续运行进程</li>
</ul>
</li>
<li>忽略：丢弃</li>
<li>捕捉：调用用户处理函数</li>
</ul>
<blockquote>
<p>值得注意的是 <em><strong>9) SIGKILL</strong></em> 和 <em><strong>19) SIGSTOP</strong></em> 信号，不允许忽略和捕捉，只能执行默认动作。甚至不能将其设置为阻塞。</p>
</blockquote>
</li>
<li>
<p>:star:信号<strong>四要素</strong></p>
<ul>
<li>编号</li>
<li>名称</li>
<li>默认处理动作</li>
<li>事件：使得该信号<strong>产生</strong>的事件</li>
</ul>
</li>
</ul>
<hr>
<p><em>信号的产生：</em></p>
<ul>
<li>
<p><strong>终端按键</strong>产生信号</p>
<ul>
<li>
<p>Ctrl + c → <em><strong>2) SIGINT</strong></em>：终止/中断</p>
<blockquote>
<p>“INT” ----Interrupt</p>
</blockquote>
</li>
<li>
<p>Ctrl + z → <em><strong>20) SIGTSTP</strong></em>：暂停/停止</p>
<blockquote>
<p>“T” ----Terminal 终端，只能停止与终端交互的进程</p>
</blockquote>
</li>
<li>
<p>Ctrl + \ → <em><strong>3) SIGQUIT</strong></em>：退出进程（核心已转储，也是终止进程）</p>
</li>
</ul>
</li>
<li>
<p><strong>硬件异常</strong>产生</p>
<ul>
<li>
<p>浮点数例外：<em><strong>8) SIGFPE</strong></em></p>
<blockquote>
<p>例如：除0</p>
<p>“F” -----float 浮点数</p>
</blockquote>
</li>
<li>
<p>段错误：<em><strong>11) SIGSEGV</strong></em></p>
<blockquote>
<p>例如：非法访问内存</p>
</blockquote>
</li>
<li>
<p>总线错误：<em><strong>7) SIGBUS</strong></em></p>
<blockquote>
<p>例如：内存对齐出错</p>
</blockquote>
</li>
</ul>
</li>
<li>
<p><strong>命令</strong>产生</p>
<ul>
<li>
<p>:star:<code>kill -信号编号 进程ID</code>：给对应ID的进程发送信号</p>
<blockquote>
<p>默认发送的是 <em><strong>15) SIGTERM</strong></em></p>
</blockquote>
</li>
</ul>
</li>
<li>
<p><strong>系统调用</strong>产生</p>
<ul>
<li>
<p>:star:<code>int kill(pid_t pid, int sig);</code>：给对应ID的进程发送信号</p>
<blockquote>
<p><code>man 2 kill</code>查看相关文档</p>
</blockquote>
<ul>
<li>成功返回0，失败返回-1并设置<code>errno</code></li>
</ul>
</li>
<li>
<p><code>int raise(int sig);</code>：给当前进程自己发送信号</p>
<p><code>raise(signo) == kill(getpid(), signo);</code></p>
</li>
<li>
<p><code>void abort(void);</code>：给当前进程自己发送异常终止信号</p>
<p><em><strong>6) SIGABRT</strong></em> 信号，终止并产生core文件</p>
</li>
</ul>
</li>
<li>
<p>软件条件产生</p>
<ul>
<li>
<p>:star:<code>unsigned int alarm(unsigned int seconds);</code>：设置定时器(闹钟)。在指定seconds后，内核会给当前进程发送 <em><strong>14) SIGALRM</strong></em> 信号</p>
<blockquote>
<p>进程收到该信号，默认动作<strong>终止</strong></p>
</blockquote>
<ul>
<li>
<p><strong>每个进程都有且只有<u>唯一</u>个定时器</strong></p>
</li>
<li>
<p>调用<code>alarm</code>后会取消旧闹钟，并<strong>返回旧闹钟余下秒数</strong></p>
<blockquote>
<p><code>alarm(0)</code>取消闹钟</p>
</blockquote>
</li>
<li>
<p>定时<strong>与进程状态无关</strong>(自然定时法)</p>
</li>
</ul>
<blockquote>
<p>使用time命令查看<strong>程序执行的时间</strong>：</p>
<p>实际执行时间 = 系统时间 + 用户时间 + <strong>等待</strong>时间</p>
<blockquote>
<p>IO往往会造成较长的等待时间，程序运行的瓶颈在于IO，优化程序，首选优化IO</p>
</blockquote>
</blockquote>
</li>
<li>
<p><code>int setitimer(int which, const struct itimerval *new_value, struct itimerval *old_value);</code></p>
<ul>
<li>
<p><code>which</code>：指定定时方式</p>
<blockquote>
<p>自然定时：ITIMER_REAL → <em><strong>14）SIGLARM</strong></em></p>
<p>虚拟空间计时(用户空间)：ITIMER_VIRTUAL → <em><strong>26）SIGVTALRM</strong></em></p>
<blockquote>
<p>只计算进程占用cpu的时间</p>
</blockquote>
<p>运行时计时(用户+内核)：ITIMER_PROF → <em><strong>27）SIGPROF</strong></em></p>
<blockquote>
<p>计算占用cpu及执行系统调用的时间</p>
</blockquote>
</blockquote>
</li>
<li>
<p><code>man setitimer</code>学习其他参数</p>
<blockquote>
<p>可以设置周期定时</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<p><em>信号集操作：</em></p>
<ul>
<li>
<p><code>sigset_t set;      // typedef unsigned long sigset_t;</code></p>
</li>
<li>
<p>设置<strong>自定义信号集</strong></p>
<ul>
<li>
<p><code>int sigemptyset(sigset_t *set);</code>：将某个信号集清0</p>
<blockquote>
<p>返回值：成功0、失败-1，下面3个函数返回值也一样</p>
</blockquote>
</li>
<li>
<p><code>int sigfillset(sigset_t *set);</code>：将某个信号集全部置1</p>
</li>
<li>
<p><code>int sigaddset(sigset_t *set, int signum);</code>：将某个信号加入信号集</p>
</li>
<li>
<p><code>int sigdelset(sigset_t *set, int signum);</code>：将某个信号清出信号集</p>
</li>
<li>
<p><code>int sigismember(const sigset_t *set, int signum);</code>：判断某个信号是否在信号集中</p>
<blockquote>
<p>返回值：在集合1、不在：0、出错：-1</p>
</blockquote>
</li>
</ul>
</li>
<li>
<p><strong>信号屏蔽字与未决信号集</strong>的操作</p>
<ul>
<li>
<p>:star:<code>int sigprocmask(int how, const sigset_t *set, sigset_t *oldset);</code>：屏蔽信号或解除屏蔽</p>
<ul>
<li>
<p><code>how</code></p>
<p><code>SIG_BLOCK</code>：<code>set</code>表示需要屏蔽的信号</p>
<p><code>SIG_UNBLOCK</code>：<code>set</code>表示需要解除屏蔽的信号(set位为1代表解除屏蔽)</p>
<p><code>SIG_SETMASK</code>：<code>set</code>表示用于替代原始屏蔽及的新屏蔽集</p>
</li>
<li>
<p>成功返回0，失败返回-1</p>
</li>
</ul>
</li>
<li>
<p><code>int sigpending(sigset_t *set);</code>：读取当前进程的<strong>未决</strong>信号集</p>
<ul>
<li>成功返回0，失败返回-1</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<p><em>信号捕捉：</em></p>
<ul>
<li>
<p><code>sighandler_t signal(int signum, sighandler_t handler);</code>：注册一个信号捕捉函数</p>
<blockquote>
<p><code>typedef void (*sighandler_t)(int);</code>，参数是<strong>信号编号</strong></p>
</blockquote>
<ul>
<li>返回值为<code>sighandler_t </code>，若是<code>SIG_ERR</code>则代表出错，若不是则代表该信号之前的捕捉函数</li>
<li><code>handler</code>是要注册的处理函数，也可赋值为<code>SIG_IGN</code>表<strong>忽略</strong>或<code>SIG_DFL</code>表执行<strong>默认动作</strong></li>
</ul>
</li>
<li>
<p>:star:<code>int sigaction(int signum, const struct sigaction *act, struct sigaction *oldact);</code></p>
<ul>
<li>
<p>成功：0；失败：-1</p>
</li>
<li>
<p><code>struct sigaction</code>结构体重要成员</p>
<ul>
<li>
<p><code>sa_handler</code>成员：要注册的处理函数</p>
</li>
<li>
<p><code>sigset_t sa_mask</code>：信号处理函数执行期间进程的<strong>信号屏蔽字</strong></p>
<blockquote>
<p>仅在处理函数被调用期间屏蔽生效，是临时性设置；当然，如果处理函数执行期间未被屏蔽的信号到来，则依然按照正常的机制去处理</p>
</blockquote>
</li>
<li>
<p><code>int sa_flags</code>：通常设置为0，代表使用默认属性，即处理函数执行期间<strong>自动屏蔽</strong>被捕捉信号</p>
<blockquote>
<p>如果不希望自动阻塞被捕捉信号，则可以设置为<code>SA_NODEFER</code>，当然这种情况要求处理函数是可重入的（后面会讲”重入“）</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>内核实现信号捕捉的过程</p>
<ol>
<li>进程收到成功<strong>递达</strong>的信号，陷入内核</li>
<li><strong>内核</strong>处理信号，如果有注册处理函数，则回到用户态<strong>执行回调</strong></li>
<li>处理函数执行完后，执行特殊的<strong>系统调用</strong>函数<code>sigreturn</code>，再次回到内核</li>
<li>最后回到用户态继续向后执行</li>
</ol>
</li>
<li>
<p>通过 <em><strong>17) SIGCHILD</strong></em> 信号回收子进程</p>
<ol>
<li>屏蔽SIGCHILD信号</li>
<li>注册 SIGCHILD 信号处理函数
<ul>
<li>在函数中通过<code>while ((pid = waitpid(0, &amp;status, WNOHANG)) &gt; 0)</code> 的方式回收子进程</li>
</ul>
</li>
<li>解除对SIGCHILD信号的屏蔽</li>
</ol>
</li>
</ul>
<hr>
<p><em><code>pause</code>函数与<code>sigsuspend</code>函数</em>：</p>
<ul>
<li>
<p><code>int pause(void);</code>：让进程主动阻塞，等待信号唤醒</p>
<ul>
<li>
<p>不能返回的情况</p>
<ul>
<li>
<p>信号的<strong>默认处理动作</strong>是终止进程，进程<strong>终止</strong></p>
<blockquote>
<p>一般来说，<strong>执行默认动作</strong>就不能返回了</p>
</blockquote>
</li>
<li>
<p>信号被<strong>忽略</strong></p>
</li>
<li>
<p>信号被<strong>屏蔽</strong></p>
</li>
</ul>
</li>
<li>
<p>可以返回的情况：<strong>捕捉</strong>且<strong>处理函数</strong>执行后</p>
<ul>
<li>返回 -1 并设置errno为EINTR</li>
</ul>
</li>
</ul>
</li>
<li>
<p><code>int sigsuspend(const sigset_t *mask);</code>：让进程主动阻塞，等待信号唤醒，阻塞期间的信号屏蔽字由参数决定</p>
</li>
</ul>
<hr>
<p><em>信号传参：</em></p>
<ul>
<li>
<p>发送信号时传参：<code>int sigqueue(pid_t pid, int sig, const union sigval value);</code></p>
<ul>
<li>
<p><code>union sigval &#123;int  sival_int; void *sival_ptr;&#125;;</code></p>
<blockquote>
<p>注意，不同进程<strong>虚拟地址空间</strong>不同，所以<strong>不同进程之间</strong>用信号传地址是没有太大意义的，但<strong>同一个进程</strong>可以</p>
</blockquote>
</li>
<li>
<p>成功返回0，失败返回-1并设置error</p>
</li>
</ul>
</li>
<li>
<p>捕捉信号时接收到的参数：<code>int sigaction(int signum, const struct sigaction *act, struct sigaction *oldact);</code></p>
<ul>
<li>
<p><code>sigaction</code>结构体的<code>sa_sigaction</code>成员：<code>void (*sa_sigaction)(int, siginfo_t *, void *);</code></p>
<blockquote>
<p><code>siginfo_t</code>是较为复杂的结构体，详见<code>man sigaction</code></p>
</blockquote>
</li>
<li>
<p>用<code>sa_sigaction</code>成员代替<code>sa_handler</code>，并且<code>sa_flags</code>要置为<code>SA_SIGINFO</code></p>
</li>
</ul>
</li>
</ul>
<hr>
<p><em>中断系统调用：</em></p>
<ul>
<li>
<p>系统调用的一种分类</p>
<ul>
<li>
<p>慢速系统调用：可能会使进程永远阻塞的一类系统调用</p>
<blockquote>
<p>如，read、write、pause、wait…</p>
</blockquote>
</li>
<li>
<p>其他系统调用</p>
</li>
</ul>
</li>
<li>
<p>慢速系统调用执行期间捕捉到信号，则系统调用会被中断，处理函数执行后，慢速系统调用通常会返回-1，并设置<code>errno</code>为<code>EINTR</code></p>
<blockquote>
<p>想中断慢速系统调用，不能屏蔽、忽略、执行默认动作；</p>
<p>EINTR代表“被信号中断“</p>
</blockquote>
</li>
<li>
<p>中断慢速系统调用后，如果想重启，可以自行在程序中书写重启的逻辑，也可以设置<code>sa_flags</code>参数为<code>SA_RESTART</code></p>
<blockquote>
<p><code>SA_INTERRUPT</code>为不重启</p>
</blockquote>
</li>
</ul>
<h3 id="3-5-竞态条件">3.5 竞态条件</h3>
<p><em>时序竞态问题：</em></p>
<ul>
<li>竞态条件，跟系统负载有很紧密的关系，体现出信号的不可靠性。系统负载越严重，信号不可靠性越强。</li>
<li>竞态问题就是指由于进程抢占CPU时间片执行的<strong>异步性和不确定性</strong>导致的<strong>数据不一致问题</strong>。这种意外情况只能在编写程序过程中，提早预见，主动规避，而无法通过gdb程序调试等其他手段弥补。</li>
<li>条件：<strong>共享</strong>数据<strong>并发</strong>访问，且有<strong>写</strong>动作</li>
</ul>
<hr>
<p><em>全局变量的异步读写</em>：</p>
<ul>
<li>进程本身的函数和内核调用的<strong>回调函数</strong>可能会对全局变量有异步读写操作</li>
<li>解决方案
<ul>
<li>不使用全局变量</li>
<li>锁机制</li>
</ul>
</li>
</ul>
<hr>
<p><em>可重入与不可重入函数：</em></p>
<ul>
<li>一个函数在被调用执行期间，由于某种时序又被重复调用，称之为“重入”。
<ul>
<li>不可重入函数意思是，在函数的执行过程中，受到异步时序影响<strong>再次执行</strong>此函数（原执行暂停，直到再次执行结束后再继续执行），最终得到的结果与两次<strong>串行执行</strong>函数不一致</li>
</ul>
</li>
<li>可重入函数的特点
<ul>
<li>不能含有全局变量和<code>static</code>变量</li>
<li>不能使用<code>malloc</code>、<code>free</code></li>
<li>不是<strong>标准IO</strong>函数</li>
</ul>
</li>
<li>信号处理程序能调用的可重入函数可参阅<code>man 7 signal</code></li>
</ul>
<h3 id="3-6-进程组与会话">3.6 进程组与会话</h3>
<p><em>终端与Shell进程：</em></p>
<ul>
<li>
<p>所谓终端，就是<strong>所有输入输出设备的总称</strong></p>
</li>
<li>
<p>UNIX系统中用户可以通过<strong>终端</strong>登录系统，并得到一个<strong>Shell进程</strong>，终端就是Shell进程的<strong>控制终端</strong>。控制终端记录在PCB中，而<code>fork</code>时复制PCB，所以Shell进程启动的其他进程的控制终端也是该终端</p>
</li>
<li>
<p>终端的启动流程：init<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rarr</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span>fork、exec<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rarr</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span>getty<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rarr</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span>login<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rarr</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span>exec、bash</p>
</li>
<li>
<p>终端与用户进程的交互：</p>
<p>用户进程</p>
<p>​	<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>↑</mo><mo>↓</mo></mrow><annotation encoding="application/x-tex">\uarr\darr</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mrel">↑↓</span></span></span></span></p>
<p>系统调用</p>
<p>​	<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>↑</mo><mo>↓</mo></mrow><annotation encoding="application/x-tex">\uarr\darr</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mrel">↑↓</span></span></span></span></p>
<p>line discipline</p>
<p>​	<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>↑</mo><mo>↓</mo></mrow><annotation encoding="application/x-tex">\uarr\darr</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mrel">↑↓</span></span></span></span></p>
<p>终端设备驱动程序</p>
<p>​	<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>↑</mo><mo>↓</mo></mrow><annotation encoding="application/x-tex">\uarr\darr</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mrel">↑↓</span></span></span></span></p>
<p>终端设备</p>
<blockquote>
<p>line disciline: 线路规程，用来过滤键盘输入的内容</p>
</blockquote>
</li>
<li>
<p><code>char *ttyname(int fd);</code>：由文件描述符查出对应的文件名/设备名</p>
</li>
</ul>
<hr>
<p><em>进程组的概念与特性：</em></p>
<ul>
<li>
<p>进程组，也称之为<strong>作业</strong>，代表一个或多个进程的集合。<strong>每个进程都属于一个进程组</strong>，操作系统设计的进程组的概念，是为了简化<strong>对多个进程的管理</strong>。</p>
</li>
<li>
<p>父进程<code>fork</code>创建子进程的时候，默认子进程与父进程属于同一进程组，父进程为组长进程。<strong>组长进程</strong>的<strong>进程ID</strong>等于<strong>组进程ID</strong>。</p>
</li>
<li>
<p>进程组<strong>生存期</strong>：进程组创建的<strong>最后一个进程离开</strong>(终止或转移到另一个进程组)</p>
<blockquote>
<p>只要进程组中有一个进程存在，进程组就存在，与<strong>组长进程是否终止</strong>无关</p>
</blockquote>
</li>
</ul>
<hr>
<p><em>进程组操作函数：</em></p>
<ul>
<li>
<p><code>pid_t getpgrp(void);</code>：获取当前进程的进程组ID</p>
</li>
<li>
<p><code>pid_t getpgid(pid_t pid); </code>：获取指定进程的进程组ID</p>
<ul>
<li>如果<code>pid</code>为0，与<code>getpgrp</code>作用相同</li>
</ul>
</li>
<li>
<p><code>int setpgid(pid_t pid, pid_t pgid);</code>：改变进程默认所属的进程组</p>
<ul>
<li>
<p>可用来<strong>加入</strong>一个现有的进程组或<strong>创建</strong>一个新进程组(并作为组长)</p>
</li>
<li>
<p>成功返回0失败返回-1并设置errno</p>
</li>
<li>
<p>权级问题：非root进程只能改变<strong>自己创建的子进程</strong>，或<strong>有权限操作</strong>的进程</p>
<blockquote>
<p>也可以改变自己的进程组</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<hr>
<p><em>会话的概念与特性：</em></p>
<ul>
<li>会话就是<strong>一组进程组</strong></li>
<li>创建会话的进程<strong>不能是原组长</strong>进程。创建会话的进程会成为<strong>首进程/会长</strong>(session leader)，并且会成为一个<strong>新进程组的组长</strong></li>
<li><strong>新会话</strong><u>丢弃原有的控制终端</u>，<strong>没有控制终端</strong>，只在后台执行</li>
<li>Shell进程创建出的进程，进程组会变化，但会话与Shell进程保持一致</li>
</ul>
<hr>
<p><em>会话操作函数：</em></p>
<ul>
<li><code>pid_t getsid(pid_t pid);</code>：获取进程<strong>所属的会话ID</strong>
<ul>
<li>成功返回会话ID，失败返回-1并设置errno</li>
<li><code>pid</code>为0表示查看当前进程会话ID</li>
</ul>
</li>
<li><code>pid_t setsid(void);</code>：创建一个会话，并以自己的ID设置<strong>新进程组ID</strong>，同时也是<strong>新会话ID</strong>
<ul>
<li>成功返回新会话ID，失败返回-1并设置errno</li>
<li>创建会话的一般流程：父进程<code>fork</code>并退出，子进程<code>setsid</code></li>
</ul>
</li>
</ul>
<hr>
<p><em>守护进程：</em></p>
<ul>
<li>
<p>Daemon(精灵)进程，是Linux中的<strong>后台服务进程</strong>，通常独立于控制终端，并且<strong>周期性</strong>地执行某种任务或等待处理某些发生的事件。一般采用以d结尾的名字。</p>
</li>
<li>
<p><strong>创建守护进程</strong>的模型</p>
<ol>
<li>
<p>创建子进程，父进程退出</p>
<blockquote>
<p>形式上<strong>脱离了控制终端</strong></p>
</blockquote>
</li>
<li>
<p>在子进程中创建新会话</p>
<blockquote>
<p>使子进程<strong>完全独立</strong>出来，脱离控制，不受用户登录和注销的影响</p>
</blockquote>
</li>
<li>
<p>改变<strong>工作目录</strong>为根目录等不会被删除的目录</p>
<blockquote>
<p><code>chdir()</code>函数</p>
</blockquote>
</li>
<li>
<p>重设文件权限掩码</p>
<blockquote>
<p><code>umask()</code>函数</p>
<p>防止继承的文件创建屏蔽字拒绝某些权限，增加守护进程灵活性</p>
</blockquote>
</li>
<li>
<p>关闭标准输入、输出、错误的<strong>文件描述符</strong></p>
<blockquote>
<p>继承的打开文件不会用到，浪费系统资源，无法卸载；</p>
<p>更常用的做法是，将0、1、2重定向到/dev/null，保持可用的文件描述符从3开始</p>
</blockquote>
</li>
<li>
<p>开始执行守护进程核心工作（周期性执行）</p>
</li>
<li>
<p>守护进程退出处理程序模型</p>
</li>
</ol>
<blockquote>
<p>如果想让守护进程随着机器重启，可以修改<code>~/.bashrc</code>，将守护进程的启动加入进去</p>
</blockquote>
</li>
</ul>
<h3 id="3-7-线程基础">3.7 线程基础</h3>
<h4 id="线程资源："><em>线程资源：</em></h4>
<ul>
<li>
<p>共享资源</p>
<ul>
<li>
<p>大部分内存地址空间 (.text/.data/.bss/heap/共享库)、文件描述符表</p>
<blockquote>
<p>除了<strong>栈</strong>和errno变量不共享，其他的包括<strong>全局变量</strong>都共享，所以可以在一个线程中释放其他线程的申请的空间（<code>malloc</code>、<code>mmap</code>）</p>
</blockquote>
</li>
<li>
<p>当前工作目录、用户ID和组ID</p>
</li>
<li>
<p>每种信号的处理方式</p>
</li>
</ul>
</li>
<li>
<p>非共享资源</p>
<ul>
<li>
<p>线程id</p>
</li>
<li>
<p>处理器现场和栈指针(内核栈)、独立的<strong>栈空间</strong>(用户空间栈)</p>
<blockquote>
<p>同一进程各线程栈的空间地址值是互相不冲突、不相同的</p>
</blockquote>
</li>
<li>
<p>errno变量</p>
</li>
<li>
<p><strong>信号屏蔽字</strong></p>
</li>
<li>
<p>调度优先级</p>
</li>
</ul>
</li>
</ul>
<hr>
<h4 id="线程操作函数："><em>线程操作函数：</em></h4>
<blockquote>
<p>编译链接时要加<code>-pthread</code>才可以链接到这些函数，同时注意版本<code>getconf GNU_LIBPTHREAD_VERSION</code></p>
</blockquote>
<ul>
<li>
<p><code>pthread_t pthread_self(void);</code>：获取线程ID</p>
<ul>
<li>
<p><code>pthread_t</code>在Linux中本质是无符号整数</p>
</li>
<li>
<p>该函数调用不会失败，返回的就是线程ID</p>
<blockquote>
<p>线程ID和LWP线程号不是同一个东西，<strong>LWP线程号</strong>是<strong>CPU给线程分配时间片</strong>的依据</p>
<blockquote>
<p><code>ps -Lf 进程ID</code>可以查看线程LWP号</p>
</blockquote>
</blockquote>
</li>
</ul>
</li>
<li>
<p><code>int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine) (void *), void *arg);</code>：</p>
<ul>
<li>
<p><code>thread</code>：是传出参数，代表创建的线程ID</p>
</li>
<li>
<p><code>attr</code>：线程属性，默认可以传NULL</p>
</li>
<li>
<p><code>start_routine</code>：线程的主控函数</p>
</li>
<li>
<p><code>arg</code>：主控函数的参数</p>
</li>
<li>
<p>成功返回0，失败直接返回error number</p>
<blockquote>
<p>Linux环境下所有线程API都是这样的返回</p>
</blockquote>
</li>
<li>
<p>循环创建多个子线程</p>
<p><code>pthread_create(&amp;tid, NULL, thrd_func, (void *)arg)</code></p>
<ul>
<li>
<p>子线程中<code>arg</code>可能的使用方式：<code>(int)arg</code></p>
</li>
<li>
<p>如果使用<code>(void *)&amp;arg</code>这种方式，传入的是父线程的地址空间，可能会造成问题</p>
<blockquote>
<p>这种情况下可能的使用方式：<code>*((int *)arg)</code></p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p><code>void pthread_exit(void *retval);</code></p>
<ul>
<li>
<p><code>retval</code>表示线程退出状态，通常传<code>NULL</code></p>
</li>
<li>
<p>用<code>pthread_exit</code>退出主控线程或子线程，若<strong>进程内还有其他线程</strong>存在，则进程不会结束</p>
<blockquote>
<p>如果在主控线程或子线程中使用<code>exit</code>函数退出，会直接退出整个进程；</p>
<p>如果在主控线程中使用<code>return</code>退出，会直接退出整个进程；</p>
<p>如果在子线程的主控函数中使用<code>return</code>退出，相当于用<code>pthread_exit</code>退出</p>
</blockquote>
</li>
</ul>
</li>
<li>
<p><code>int pthread_join(pthread_t thread, void **retval);</code>：<strong>阻塞</strong>等待线程退出，获取线程退出状态</p>
<ul>
<li><code>retval</code>：存储线程结束状态，指向的是<code>pthread_exit</code>函数的入参，所以是<code>void**</code>类型</li>
<li>可能的使用方式：<code>pthread_join(tid, (void **)&amp;retval)</code>，<code>retval</code>是<strong>一级指针</strong></li>
<li>与进程的区别是，线程与线程之间也可以调用<code>pthread_join</code>来“回收”</li>
<li>成功返回0，失败返回error number</li>
</ul>
</li>
<li>
<p><code>int pthread_detach(pthread_t thread);</code>：分离线程</p>
<ul>
<li>线程分离状态：线程与主控线程断开关系，结束后<strong>自动释放</strong>（清理PCB）</li>
<li>如果用<code>pthread_join</code>回收分离的线程，会出错，返回22</li>
<li>成功返回0，失败返回error number</li>
</ul>
</li>
<li>
<p><code>int pthread_cancel(pthread_t thread);</code>：杀死(取消)线程</p>
<ul>
<li>
<p>线程的取消并不是实时的，需要等待线程<strong>到达</strong>某个**<u>取消点(检查点)</u>**时</p>
<ul>
<li>
<p>取消点：线程检查是否被取消，并按请求进行动作的一个位置，通常是某些系统调用</p>
<blockquote>
<p><code>man 7 pthreads</code>可以查看具备取消点的系统调用列表</p>
</blockquote>
</li>
<li>
<p>自行添加取消点：<code>pthread_testcancel();</code></p>
</li>
</ul>
</li>
<li>
<p>如果用<code>pthread_join</code>回收取消的线程，会出错，返回-1</p>
<blockquote>
<p><code>pthread.h: #define PTHREAD_CANCELED ((void *) -1)</code></p>
</blockquote>
</li>
<li>
<p>成功返回0，失败返回error number</p>
</li>
</ul>
</li>
<li>
<p><code>int pthread_equal(pthread_t t1, pthread_t t2);</code>：比较两个线程ID是否相等</p>
<ul>
<li>当然，目前<code>pthread_t</code>就是整型，可以直接用<code>==</code>判等，之后如果改成其他的比如结构体类型，就需要用<code>pthread_equal</code>了</li>
</ul>
</li>
</ul>
<hr>
<h4 id="线程属性："><em>线程属性：</em></h4>
<ul>
<li>
<p><code>pthread_attr_t </code>结构体的重要成员</p>
<ul>
<li>
<p><code>int etachstate;   //线程的分离状态</code></p>
</li>
<li>
<p><code>size_t stacksize;     //线程栈的大小</code></p>
<blockquote>
<p>线程栈默认大小是<strong>均分进程栈（8MB）</strong></p>
</blockquote>
</li>
<li>
<p><code>size_t guardsize;    //线程栈末尾的警戒缓冲区大小</code></p>
<blockquote>
<p>警戒区用于防止线程栈溢出</p>
</blockquote>
</li>
</ul>
</li>
<li>
<p>线性属性初始化与销毁</p>
<ul>
<li><code>int pthread_attr_init(pthread_attr_t *attr);</code>：初始化线程属性
<ul>
<li>应先初始化线程属性，再<code>pthread_create</code>创建线程。当然这个函数只是初始化，不是设置属性</li>
<li>成功返回0，失败返回错误号</li>
</ul>
</li>
<li><code>int pthread_attr_destroy(pthread_attr_t *attr);</code>：销毁线程属性所占用的资源
<ul>
<li>成功返回0，失败返回错误号</li>
</ul>
</li>
</ul>
</li>
<li>
<p>线程分离的属性</p>
<ul>
<li>
<p><code>int pthread_attr_setdetachstate(pthread_attr_t *attr, int detachstate);</code>：设置线程的分离属性</p>
<ul>
<li>
<p><code>detachstate</code></p>
<p><code>PTHREAD_CREATE_DETACHED</code>：分离</p>
<p><code>PTHREAD _CREATE_JOINABLE</code>：不分离</p>
</li>
</ul>
</li>
<li>
<p><code>int pthread_attr_getdetachstate(pthread_attr_t *attr, int *detachstate);</code>：获取线程的分离属性</p>
</li>
</ul>
<blockquote>
<p>如果设置一个线程为分离线程，而这个线程运行又非常快，它很可能在<code>pthread_create</code>函数返回之前就终止了，终止后可能将<strong>线程号和系统资源</strong>移交给其他的线程使用，这样调用<code>pthread_create</code>的线程就得到了<strong>错误的线程号</strong>。可以用线程同步的手段解决这个问题。</p>
</blockquote>
</li>
<li>
<p>线程的栈空间属性</p>
<ul>
<li>
<p><code>int pthread_attr_setstack(pthread_attr_t *attr, void *stackaddr, size_t stacksize);</code>：设置栈地址和大小</p>
<blockquote>
<p>可以将线程的栈地址设置到<strong>堆</strong>中（<code>malloc</code>）</p>
</blockquote>
</li>
<li>
<p><code>int pthread_attr_getstack(pthread_attr_t *attr, void **stackaddr, size_t *stacksize);</code>：获取栈地址和大小</p>
</li>
<li>
<p><code>int pthread_attr_setstacksize(pthread_attr_t *attr, size_t stacksize);</code>：设置栈大小</p>
</li>
<li>
<p><code>int pthread_attr_getstacksize(pthread_attr_t *attr, size_t *stacksize);</code>：获取栈大小</p>
</li>
</ul>
</li>
</ul>
<hr>
<h4 id="线程使用注意事项："><em>线程使用注意事项：</em></h4>
<ul>
<li>线程库版本问题<code>getconf GNU_LIBPTHREAD_VERSION</code></li>
<li>避免僵尸线程，要么<code>join</code>回收，要么<code>detach</code>分离（或者修改线程属性使其分离）</li>
<li>尽量避免在多线程模型中使用<code>fork</code>。<code>fork</code>后子进程中只存在调用<code>fork</code>的“线程”，其他“线程”都退出了</li>
<li>尽量避免在多线程模型中使用信号机制</li>
</ul>
<h3 id="3-8-线程和进程的同步与互斥">3.8 线程和进程的同步与互斥</h3>
<h4 id="互斥量mutex："><em>互斥量<code>mutex</code>：</em></h4>
<ul>
<li>
<p><code>pthread_mutex_t</code>本质是结构体，可以简单认为其只有0、1两种取值</p>
</li>
<li>
<p><code>mutex</code>相关函数</p>
<blockquote>
<p>这些函数均是成功返回0，失败返回错误号</p>
</blockquote>
<ul>
<li>
<p><code>int pthread_mutex_init(pthread_mutex_t *restrict mutex, const pthread_mutexattr_t *restrict attr);</code>：初始化一个互斥锁</p>
<ul>
<li>
<p>可以理解为<code>mutex = 1</code></p>
</li>
<li>
<p><code>restrict</code>关键字：所有修改<strong>该指针指向内存</strong>的操作，只能通过本指针完成，不能通过除本指针以外的其他变量或指针修改</p>
</li>
<li>
<p><code>attr</code>：互斥锁的属性，传入<code>NULL</code>为默认属性</p>
</li>
<li>
<p>也可以使用<strong>宏</strong>直接初始化：（静态初始化）</p>
<p><code>pthead_mutex_t muetx = PTHREAD_MUTEX_INITIALIZER;</code></p>
</li>
</ul>
</li>
<li>
<p><code>int pthread_mutex_destroy(pthread_mutex_t *mutex);</code>：销毁一个互斥锁</p>
</li>
<li>
<p><code>int pthread_mutex_lock(pthread_mutex_t *mutex);</code>：上锁</p>
<ul>
<li>可理解为<code>mutex--</code></li>
<li>锁被占用则阻塞，直到成功获得锁</li>
</ul>
</li>
<li>
<p><code>int pthread_mutex_unlock(pthread_mutex_t *mutex);</code>：解锁</p>
<ul>
<li>可理解为<code>mutex++</code></li>
</ul>
</li>
<li>
<p><code>int pthread_mutex_trylock(pthread_mutex_t *mutex);</code>：尝试上锁</p>
<ul>
<li>锁被占用不阻塞，返回<code>EBUSY</code>代表无法获得锁</li>
</ul>
</li>
</ul>
</li>
<li>
<p><code>mutex</code>的应用</p>
<ol>
<li>定义锁：<code>pthread_mutex_t mutex;</code>
<ul>
<li>一般为<strong>全局变量</strong></li>
</ul>
</li>
<li>初始化锁</li>
<li>上锁</li>
<li>解锁</li>
</ol>
<blockquote>
<p>锁的<strong>粒度</strong>应当尽量小</p>
</blockquote>
</li>
<li>
<p>死锁</p>
<ul>
<li>两种产生情况
<ul>
<li>不可重入锁</li>
<li>两把锁</li>
</ul>
</li>
<li>对应解决方法
<ul>
<li>可重入锁</li>
<li><code>trylock</code>失败则释放锁</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h4 id="读写锁rwlock："><em>读写锁<code>rwlock</code>：</em></h4>
<ul>
<li>
<p><code>rwlock</code>特性</p>
<ul>
<li>:star:写独占、读共享</li>
<li>:star:写锁优先级高</li>
</ul>
</li>
<li>
<p><code>rwlock</code>相关函数</p>
<blockquote>
<p>这些函数均是成功返回0，失败返回错误号。用法与<code>mutex</code>很相似</p>
</blockquote>
<ul>
<li>
<p><code>int pthread_rwlock_init(pthread_rwlock_t *restrict rwlock, const pthread_rwlockattr_t *restrict attr);</code>：初始化一把读写锁</p>
<ul>
<li>
<p><code>attr</code>：传入<code>NULL</code>代表使用默认属性</p>
</li>
<li>
<p>也可以使用<strong>宏</strong>直接初始化：（静态初始化）</p>
<p><code>pthread_rwlock_t rwlock = PTHREAD_RWLOCK_INITIALIZER;</code></p>
</li>
</ul>
</li>
<li>
<p><code>int pthread_rwlock_destroy(pthread_rwlock_t *rwlock);</code>：销毁一把读写锁</p>
</li>
<li>
<p><code> int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock);</code>：请求读锁</p>
</li>
<li>
<p><code>int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock);</code>：请求写锁</p>
</li>
<li>
<p><code>int pthread_rwlock_unlock(pthread_rwlock_t *rwlock);</code>：解锁</p>
</li>
<li>
<p><code>int pthread_rwlock_tryrdlock(pthread_rwlock_t *rwlock);</code>：非阻塞请求读锁</p>
</li>
<li>
<p><code>int pthread_rwlock_trywrlock(pthread_rwlock_t *rwlock);</code>：非阻塞请求写锁</p>
</li>
</ul>
</li>
<li>
<p><code>rwlock</code>的应用：<code>pthread_rwlock t rwlock;</code></p>
<blockquote>
<p>与<code>mutex</code>很相似</p>
</blockquote>
</li>
<li>
<p><code>rwlock</code>的优点：适合读多写少的场景，减少不必要的竞争</p>
</li>
</ul>
<hr>
<h4 id="条件变量cond："><em>条件变量<code>cond</code>：</em></h4>
<ul>
<li>
<p>特点：</p>
<ul>
<li>条件变量本身不是锁！但它也可以造成线程阻塞。</li>
<li>通常与互斥锁配合使用，给多线程提供一个会合的场所。</li>
</ul>
</li>
<li>
<p><code>cond</code>相关函数：</p>
<blockquote>
<p>这些函数均是成功返回0，失败返回错误号。</p>
</blockquote>
<ul>
<li>
<p><code>int pthread_cond_init(pthread_cond_t *restrict cond, const pthread_condattr_t *restrict attr);</code>：初始化一个条件变量</p>
<ul>
<li>
<p>也可以使用<strong>宏</strong>直接初始化：（静态初始化）</p>
<p><code>pthread_cond_t cond = PTHREAD_COND_INITIALIZER;</code></p>
</li>
</ul>
</li>
<li>
<p><code>int pthread_cond_destroy(pthread_cond_t *cond);</code>：销毁一个条件变量</p>
</li>
<li>
<p>:star:<code>int pthread_cond_wait(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex);</code>：阻塞等待一个条件变量满足</p>
<ul>
<li>
<p><code>mutex</code>：需要传入一个也初始化好的<code>mutex</code>，并且已经对其<strong>加锁</strong>了</p>
</li>
<li>
<p>会释放已掌握的互斥锁（<strong>解锁互斥量</strong>），相当于<code>pthread_mutex_unlock(&amp;mutex)</code></p>
<blockquote>
<p><strong>检查条件变量是否满足与加锁</strong>的操作是不可分割的</p>
</blockquote>
</li>
<li>
<p>当被<strong>唤醒</strong>，函数返回即将时，会解除阻塞并重新申请<strong>获取互斥锁</strong>，相当于<code>pthread_mutex_lock(&amp;mutex)</code></p>
</li>
</ul>
</li>
<li>
<p><code>int pthread_cond_signal(pthread_cond_t *cond);</code>：唤醒<strong>至少一个</strong>阻塞在条件变量上的线程</p>
</li>
<li>
<p><code>int pthread_cond_broadcast(pthread_cond_t *cond);</code>：唤醒<strong>全部</strong>阻塞在条件变量上的线程</p>
</li>
<li>
<p><code>int pthread_cond_timedwait(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex, const struct timespec *restrict abstime);</code>：限时等待一个条件变量</p>
<ul>
<li>
<p>也会释放锁和申请锁</p>
</li>
<li>
<p><code>abstime</code>：绝对时间，是相对于<code>1970-1-1 00:00:00</code>的时间</p>
<blockquote>
<p>可以在<code>man sem_timedwait</code>中找到对应结构体的定义</p>
</blockquote>
<blockquote>
<p>正确用法：</p>
<p><code>time_t cur = time(NULL);</code></p>
<p><code>struct timespec t;</code></p>
<p><code>t.tv_sec = cur + 1</code></p>
<p><code>pthread_cond_timedwait(&amp;cond, &amp;mutex, &amp;t)</code></p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>条件变量的优点：相比于<code>mutex</code>，可以减少不必要的竞争，提高效率</p>
<blockquote>
<p>例如生产者与消费者模型中，在没有产品时，使用条件变量，消费者就<strong>不必互相竞争，而是都等待</strong></p>
</blockquote>
</li>
</ul>
<hr>
<h4 id="信号量semaphore："><em>信号量<code>semaphore</code>：</em></h4>
<ul>
<li>
<p><code>semaphore.h</code>，信号量，可以理解成互斥锁的“加强版”，可以进一步细化锁，保证互斥与同步，又提高并发度</p>
</li>
<li>
<p>主要应用函数（注意，没有<code>pthread</code>前缀，进程线程都可以用）</p>
<blockquote>
<p>这些函数都是成功返回0， 失败返回-1，同时设置errno</p>
</blockquote>
<ul>
<li>
<p><code>int sem_init(sem_t *sem, int pshared, unsigned int value);</code>：初始化一个信号量</p>
<ul>
<li>
<p><code>pshared</code>：0表示只用于线程间，非0表示可用于进程间</p>
</li>
<li>
<p><code>value</code>：信号量初值</p>
<blockquote>
<p><strong>信号量的初值决定了占用信号量的线程/进程个数</strong></p>
</blockquote>
</li>
</ul>
</li>
<li>
<p><code>int sem_destroy(sem_t *sem);</code>：销毁一个信号量</p>
</li>
<li>
<p><code>int sem_wait(sem_t *sem);</code>：给信号量加锁（<code>sem--</code>）</p>
</li>
<li>
<p><code>int sem_post(sem_t *sem);</code>：给信号量解锁（<code>sem++</code>）</p>
</li>
<li>
<p><code>int sem_trywait(sem_t *sem);</code>：尝试对信号量加锁</p>
</li>
<li>
<p><code>int sem_timedwait(sem_t *sem, const struct timespec *abs_timeout);</code>：限时尝试对信号量加锁</p>
</li>
</ul>
</li>
<li>
<p>信号量的特点：可以由多个线程/进程占用</p>
</li>
</ul>
<hr>
<h4 id="进程间同步："><em>进程间同步：</em></h4>
<ul>
<li>
<p>通过互斥量<code>mutex</code>实现：指定初始化时的属性<code>pthread_mutexattr_t mattr attr</code></p>
<ul>
<li>
<p><code>int pthread_mutexattr_init(pthread_mutexattr_t *attr);</code>：初始化一个**<code>mutex</code>属性**对象</p>
</li>
<li>
<p><code>int pthread_mutexattr_destroy(pthread_mutexattr_t *attr);</code>：销毁**<code>mutex</code>属性**对象</p>
</li>
<li>
<p><code>int pthread_mutexattr_setpshared(pthread_mutexattr_t *attr, int pshared);</code>：修改<code>mutex</code>的共享属性</p>
<ul>
<li>
<p><code>PTHREAD_PROCESS_PRIVATE</code>：进程间私有，即线程锁</p>
<blockquote>
<p>也是默认属性</p>
</blockquote>
</li>
<li>
<p><code>PTHREAD_PROCESS_SHARED</code>：进程锁</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>借助文件锁实现：<code>int fcntl(int fd, int cmd, ... /* arg */ );</code></p>
<ul>
<li>
<p><code>cmd</code>：函数操作类型</p>
<ul>
<li>
<p><code>F_SETLK</code>：设置文件锁（trylock）</p>
</li>
<li>
<p><code>F_SETLKW</code>：设置文件锁（lock、unlock）</p>
<blockquote>
<p>通过下面结构体的<code>l_type</code>成员指定</p>
</blockquote>
</li>
<li>
<p><code>F_GETLK</code>：获取文件锁</p>
</li>
</ul>
</li>
<li>
<p>可变参：<code>struct flock</code></p>
<p><code>struct flock &#123;</code></p>
<p>​       <code>short l_type;       锁的类型：F_RDLCK 、F_WRLCK 、F_UNLCK</code></p>
<p>​       <code>short l_whence;     偏移位置：SEEK_SET、SEEK_CUR、SEEK_END </code></p>
<p>​       <code>off_t l_start;        起始偏移：1000</code></p>
<p>​       <code>off_t l_len;         长度：0表示整个文件加锁</code></p>
<p>​       <code>pid_t l_pid;        持有该锁的进程ID：(F_GETLK only)</code></p>
<p>​    <code> &#125;;</code></p>
<blockquote>
<p>提供了读锁和写锁，也允许只锁一个文件的<strong>一部分</strong></p>
</blockquote>
</li>
</ul>
<blockquote>
<p>多线程同步不能使用文件锁，因为同一个进程中的多线程共享文件描述符，也共享相应的文件结构体</p>
</blockquote>
</li>
</ul>
<h2 id="4-网络编程">4 网络编程</h2>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="https://sundocker.online">SunDocker</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://sundocker.online/posts/72802800.html">https://sundocker.online/posts/72802800.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Computer/">Computer</a><a class="post-meta__tags" href="/tags/Linux/">Linux</a></div><div class="post_share"><div class="social-share" data-image="/bgs/bg2.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> Donate</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/wechat.jpg" alt="WeChat"/></a><div class="post-qr-code-desc">WeChat</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/alipay.jpg" alt="AliPay"/></a><div class="post-qr-code-desc">AliPay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/27633ee8.html"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/bgs/bg11.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">Database System</div></div></a></div><div class="next-post pull-right"><a href="/posts/8f298335.html"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/bgs/bg16.jpeg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">Go gRPC</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><div><a href="/posts/53d0684b.html" title="Linux"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/bgs/bg9.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2023-01-22</div><div class="title">Linux</div></div></a></div><div><a href="/posts/a9ab4cb3.html" title="Data Mining"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/bgs/bg10.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2023-01-02</div><div class="title">Data Mining</div></div></a></div><div><a href="/posts/cc8189c7.html" title="Machine Learning"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/bgs/bg2.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2023-01-02</div><div class="title">Machine Learning</div></div></a></div><div><a href="/posts/caeaa4a1.html" title="C++"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/bgs/bg10.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2023-01-22</div><div class="title">C++</div></div></a></div><div><a href="/posts/f137c912.html" title="Data Analysis"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/bgs/bg16.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2023-01-02</div><div class="title">Data Analysis</div></div></a></div><div><a href="/posts/bae4ff13.html" title="Redis"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/bgs/bg12.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2023-01-21</div><div class="title">Redis</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7"><span class="toc-text">1 常用工具</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-gcc"><span class="toc-text">1.1 gcc</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-gdb"><span class="toc-text">1.2 gdb</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-makefile"><span class="toc-text">1.3 makefile</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%86%85%E5%AD%98%E4%B8%8E%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-text">2 内存与文件系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-text">2.1 内存管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-IO"><span class="toc-text">2.3 IO</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B"><span class="toc-text">3 进程与线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-text">3.1 进程相关数据结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="toc-text">3.2 进程控制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1"><span class="toc-text">3.3 进程间通信</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-%E8%BF%9B%E7%A8%8B%E4%BF%A1%E5%8F%B7"><span class="toc-text">3.4 进程信号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-%E7%AB%9E%E6%80%81%E6%9D%A1%E4%BB%B6"><span class="toc-text">3.5 竞态条件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-%E8%BF%9B%E7%A8%8B%E7%BB%84%E4%B8%8E%E4%BC%9A%E8%AF%9D"><span class="toc-text">3.6 进程组与会话</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-7-%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80"><span class="toc-text">3.7 线程基础</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E8%B5%84%E6%BA%90%EF%BC%9A"><span class="toc-text">线程资源：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0%EF%BC%9A"><span class="toc-text">线程操作函数：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%B1%9E%E6%80%A7%EF%BC%9A"><span class="toc-text">线程属性：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%EF%BC%9A"><span class="toc-text">线程使用注意事项：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-8-%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5"><span class="toc-text">3.8 线程和进程的同步与互斥</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E9%87%8Fmutex%EF%BC%9A"><span class="toc-text">互斥量mutex：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB%E5%86%99%E9%94%81rwlock%EF%BC%9A"><span class="toc-text">读写锁rwlock：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8Fcond%EF%BC%9A"><span class="toc-text">条件变量cond：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8Fsemaphore%EF%BC%9A"><span class="toc-text">信号量semaphore：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E9%97%B4%E5%90%8C%E6%AD%A5%EF%BC%9A"><span class="toc-text">进程间同步：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B"><span class="toc-text">4 网络编程</span></a></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2023 By SunDocker</div><div class="footer_custom_text">Nice to meet you !<br> <a target="_blank" rel="noopener" href="https://www.upyun.com/?utm_source=lianmeng&utm_medium=referral"> <div id="you-pai-cloud" align="center"> 本网站由 <img class="cdn-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/又拍云_logo6.png" width="5%"> 提供<b>CDN加速/云存储</b>服务 </div> </a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">Search</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  Loading the Database</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex/dist/contrib/copy-tex.min.js"></script><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script></div><div class="aplayer no-destroy" data-id="8759530202" data-server="tencent" data-type="playlist" data-order="random" data-fixed="true" data-preload="auto" data-autoplay="true" data-mutex="true"></div><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  typeof preloader === 'object' && preloader.initLoading()
  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --><script data-pjax>
    function butterfly_categories_card_injector_config(){
      var parent_div_git = document.getElementById('recent-posts');
      var item_html = '<style>li.categoryBar-list-item{width:32.3%;}.categoryBar-list{max-height: 380px;overflow:auto;}.categoryBar-list::-webkit-scrollbar{width:0!important}@media screen and (max-width: 650px){.categoryBar-list{max-height: 320px;}}</style><div class="recent-post-item" style="height:auto;width:100%;padding:0px;"><div id="categoryBar"><ul class="categoryBar-list"><li class="categoryBar-list-item" style="background:url(/bgs/bg2.jpg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/Computer-Theory/&quot;);" href="javascript:void(0);">Computer Theory</a><span class="categoryBar-list-count">8</span><span class="categoryBar-list-descr">OS, DB, Network, ...</span></li><li class="categoryBar-list-item" style="background:url(/bgs/bg7.jpeg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/Java-Kotlin/&quot;);" href="javascript:void(0);">Java &amp; Kotlin</a><span class="categoryBar-list-count">13</span><span class="categoryBar-list-descr">JavaEE, Spring, ...</span></li><li class="categoryBar-list-item" style="background:url(/bgs/bg1.jpg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/Data-Persistence/&quot;);" href="javascript:void(0);">Data Persistence</a><span class="categoryBar-list-count">2</span><span class="categoryBar-list-descr">MySQL, Redis, ...</span></li><li class="categoryBar-list-item" style="background:url(/bgs/bg11.jpg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/Frontend/&quot;);" href="javascript:void(0);">Frontend</a><span class="categoryBar-list-count">6</span><span class="categoryBar-list-descr">HTML, JS, Vue, ...</span></li><li class="categoryBar-list-item" style="background:url(/bgs/bg13.jpg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/Golang/&quot;);" href="javascript:void(0);">Golang</a><span class="categoryBar-list-count">3</span><span class="categoryBar-list-descr">Go, Gin, gRPC, ...</span></li><li class="categoryBar-list-item" style="background:url(/bgs/bg10.jpg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/Operations/&quot;);" href="javascript:void(0);">Operations</a><span class="categoryBar-list-count">4</span><span class="categoryBar-list-descr">Linux, Docker, ...</span></li><li class="categoryBar-list-item" style="background:url(/bgs/bg14.jpg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/Project-Management/&quot;);" href="javascript:void(0);">Project Management</a><span class="categoryBar-list-count">3</span><span class="categoryBar-list-descr">Git, Maven, Gradle, ...</span></li></ul></div></div>';
      console.log('已挂载butterfly_categories_card')
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
      }
    if( document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
    butterfly_categories_card_injector_config()
    }
  </script><script data-pjax>
  function butterfly_clock_anzhiyu_injector_config(){
    var parent_div_git = document.getElementById('aside-content');
    var item_html = '<div class="card-widget card-clock"><div class="card-glass"><div class="card-background"><div class="card-content"><div id="hexo_electric_clock"><img class="entered loading" id="card-clock-loading" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/loading.gif" style="height: 120px; width: 100%;" data-ll-status="loading"/></div></div></div></div></div>';
    console.log('已挂载butterfly_clock_anzhiyu')
    if(parent_div_git) {
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = '/';
  var qweather_key = '09f05ee29ba043a69e57ecde9f1852e1';
  var gaud_map_key = 'a152cd225b0ee3daa90af4b09bdad828';
  var baidu_ak_key = 'undefined';
  var flag = 0;
  var clock_rectangle = '116.3,39.9';
  var clock_default_rectangle_enable = 'false';

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_clock_anzhiyu_injector_config();
  }
  else if (epage === cpage){
    butterfly_clock_anzhiyu_injector_config();
  }
  </script><script src="https://widget.qweather.net/simple/static/js/he-simple-common.js?v=2.0"></script><script data-pjax src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.js"></script><script data-pjax>
  function butterfly_swiper_injector_config(){
    var parent_div_git = document.getElementById('recent-posts');
    var item_html = '<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms;"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/6c24763b.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/bgs/bg6.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-01-04</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/6c24763b.html&quot;);" href="javascript:void(0);" alt="">Knowledge Tree</a><div class="blog-slider__text">No description now, why not come in to have a look?</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/6c24763b.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/ed318fdc.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/bgs/bg10.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-01-04</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/ed318fdc.html&quot;);" href="javascript:void(0);" alt="">Quickly Learn About This Blog</a><div class="blog-slider__text">Come to see what exactly the blog contains and what can you get</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/ed318fdc.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/d33aa198.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/bgs/bg8.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-01-04</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/d33aa198.html&quot;);" href="javascript:void(0);" alt="">Life Sharing Tree</a><div class="blog-slider__text">No description now, why not come in to have a look?</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/d33aa198.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>';
    console.log('已挂载butterfly_swiper')
    parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  var elist = 'undefined'.split(',');
  var cpage = location.pathname;
  var epage = '/';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_swiper_injector_config();
  }
  else if (epage === cpage){
    butterfly_swiper_injector_config();
  }
  </script><script defer src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.js"></script><script defer data-pjax src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper_init.js"></script><script data-pjax>
  function butterfly_footer_beautify_injector_config(){
    var parent_div_git = document.getElementById('footer-wrap');
    var item_html = '<div id="workboard"></div><p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" data-title="博客框架为Hexo_v6.3.0" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&amp;logo=hexo" alt=""/></a><a class="github-badge" target="_blank" href="https://butterfly.js.org/" style="margin-inline:5px" data-title="主题版本Butterfly_v4.4.0" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&amp;logo=bitdefender" alt=""/></a><a class="github-badge" target="_blank" href="https://beian.miit.gov.cn/#/Integrated/index" style="margin-inline:5px" data-title="本站已在粤进行备案" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/粤ICP备-2022157052号-e1d492?style=flat&amp;logo=data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAdCAYAAAC9pNwMAAABS2lUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4KPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS42LWMxNDIgNzkuMTYwOTI0LCAyMDE3LzA3LzEzLTAxOjA2OjM5ICAgICAgICAiPgogPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4KICA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIi8+CiA8L3JkZjpSREY+CjwveDp4bXBtZXRhPgo8P3hwYWNrZXQgZW5kPSJyIj8+nhxg7wAACNlJREFUSInF1mmMVeUdx/Hv2e+5+519mJWBYQZkGxZZxLKJqBXGoLS1iXWrmihotFXaJiTWWlsbl6q1aetWd5u0VkKjNG4YEJSlOCibDLMwM8x679z9nnPP1jcVJUxf+7z6J8+LT37/Z4VvaQhfFS8+sBXbctCDGrVTKlBUH4mxAbI9Hfj0IJLsp6paJ5/tmn20N/D0wKDRMq9F/c3M2U1/V0vDfWMFh+tv/Ig1zYPMabDImPJ52OaXO87W580KggCiiOsJOJ6I3wcNFaaeNKxrt72f2fLGu4FpJ/sDQABRzD22fH7/Yze069vGc6mrDLNIJCDik10sxz2by3VdPM87xzkP9jwPTZFRVI1YUJKH+oy7n3tbvv/P2wW/UQxRWe6w4ZJRptYLHDoCuz8v5cP92XbI762O+h6UVWHnUFbPpU0fEb2A60mMJ7MUi9b/b7UgKhiZMaIxm8YLplLMDPz8hl/EH+rs8TNlUpFf32uyZJGLPDwCiTGUyTWodTN49eUCdz2YwXb9NNcObp1X98WDoufynzMVCEKGn27ayPTWBi5ad8P5iQUkJEnFLjqM9Z+hrVX0vfDe6K2dPRWsW2bwyp9EUifSJB84gdxrkR0eRgv1o/3I4fbbprJ6scqamzVO9pffec1S5ZWY2Nfz5qEy/FqOC2Y3s3j53HMSi18VRjFPwSwg+1RfVbl115vvJrsfej7UGIsYPPGgQ7JXoO+Xx5B3dHEomyJ9x1qiQozkr95h5937aFnVyouPlgJK+Ss7Fxz64OTSxSX+LHYxT2IsRW5kbGI4oHcR0jqoqTjV9se3I7/f8rS/ClS23GxSXhph6L5d9Akm7qqZhHWBQGUJ+CWGFzcg7e7m6D3/ZuW1Ea5YKdA3EojuONi813TqNi+YPYOKUhXDtCeGL26/hakLLiEcdsaHRkRAoLRc4fJrmhnekyF0apgZowWSwwkaa+rw3f8WA1GZZsPP5JEChX8dhZTN6iU6kAcs5s+dHd183SJ0VVKL57pfw6YdRQw23aeWTns47DPTALWlRTR7kMLew6hGgYqUhWXYFFUdPZ6lUBahLA8hVcOftckfi7No7VRAAQqsX1dybfvG1qwriM9mM5mJ4e4jO5Cc01dPqixbr8tWGBQUL4vjGigEEShi+xUmZ2RiR/sJ1pbS8NkgZrKAGw0TsgQsQyFaF/nfYTGprAlMFysbA1pI3mhkR6snhGsaymYGvPyFEb9IdbUE2AzFFTwpRqCtBY0wmdER+hZW4j63gcJj38V+/ErSUZXsYBfjIZHIRW0c2Z8BskCAqN+CbBJBFnyyKjR+Ez57nBxLqpfMUeSISElMBFz6x2Q6OxzWrYjyxWVzEewioU3LCS5vQY6nMUrLwNaxXvoQ59IloFSx54PPAZtQLExVZZDxsVE8J4dn6v4JYatgbSjk0owPw7RGH2ADMo88Z7L20ip8f7gC7fAo0q4+0rt7kEQDvaghVZbiPHUHcyeXcfLjT3jmpR7AYsnSScya3UR8bARVMck7Y/cB75/X6rDf3Fg2dw2jKZm5dXGm1LuAzO5DCo9v6aT0ibco5kzOvLOP+NGTFJtDpPYeZKijk/Rn3QxsfZV7txwhX7ABiZUXBsGvIvguQApNQQva9RMmTvZ2dpVUls+tX/UD7GN/Y8Ws05w6rQF+9vyzg1vZjbvMRJhXiRSU8DpTFFe0QE8S6SfPkOkZoktrB2oAhZWrwljxOPmchiSMYOWNoxNuruFU5vWeXdsojiUon345113dBBQBmTYlTimgdB8nfPo4WjaNFgN9OMEkJ02dnadVt5ki54Esqy+bzKJltVhSPbI3iN2zCyMTeXNCuG7Omm2Zok7PR2+R7jvD8ouruHhmCrB5jVZeYxLdrTP4sr4Vtd9g4MA4qc4c+6cu5NPamfw4P59t2WrA4YdXKkASf7SFivo6PDdEPmf1fRM++zp1bH/0r4I1dD1ODtOWaW4IsvPjL7nqXhloQiSPwjjgMYkMASyGEBkjhISCQwkwzve/18AbT+pk8pVY4UacQi9y+gyZ0eRAw4qHa89LXEx1LXMSPfhDJYRb59BtlLKg2WPT2l6qYl1svtGkrLYckyA1S+t5+2ATm37WCui0LSynsckDNH5zTxAchbQtkx08hDHYiW6NgC0enHBzEZ102UDH8QORdEckjEzZrNWkRydzyx17uGnDXqbUnGZ6dRPjSY91q2TqwjFuvTxLo5Zn5Qo/pumRSFcTLQtybEhGE0fQrDhhJ0VvH2lTnnHPhGtsmWan469apERjI2MH3qN7+7MEfH6ql29CbV7PvsMG32k6yU2XDhEKyZw66eJaRdrXR7CzCcqUNC3zwgymPJRCH4KRRLINimpL14A5Y4GDeOqbsPRVcfuN7Xj44pav/hFfrNT2kr2rsqf2Ibp5pEA14ZIImUyW3t5REkkTXRGQ/DGGhtLginhqCWknQDE5hKf5UFSF9Lj020Q2ul5V1AR2hr+8vuP8Vlc2zMPRxoSjnx7XBC14sDoydahSGq7KdO/HFyrBchxCVfX4fDKp4T7SCQejYODZLrYgIqgKFsNIgQqEYob8mW6yiUyb7Z64LVK/+B85xznnJ3AWzqTzuIX46mr5wLs+UUTyIriBCjRNxguHMJIFDLEEvXEOVRWnSJ0+jCd4CJoGjoedM1CLcXQziW3nMV2TSMBeOx7vWZvPt1r+cMPzE8KunaUkFn0vNrvtqXj34c1W6gzxlEQ6naIoBahtnkMwoFMwIVzSRNguMt53Aj2s4nkSlgPoGqLkICsRNF0gl8rYWuP8+11/w/OOJDEhHPKLCIpOXmi+M9AgP+maiesLifF2T1Rn5ZNj5Lo/Qc/GcPMmhdoqlEgIGzCK4PiCmJKK68p4KfF3qYGuF0qCRUkJTzleUbvQyWRTuE5xYthxQbBs7EISAbkzUFG3VfXXbK2YFi3X/eryfKKnqVBItNjJxDzH8erddC4SqWwcN5WyTtlyO1RP/Lh3eHD76MB40swmiDVJyDLYRhpc5+ub6tse/wWKbvSQEAw1awAAAABJRU5ErkJggg==" alt=""/></a><a class="github-badge" target="_blank" href="https://github.com/" style="margin-inline:5px" data-title="本站项目由Github托管" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&amp;logo=GitHub" alt=""/></a><a class="github-badge" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" style="margin-inline:5px" data-title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&amp;logo=Claris" alt=""/></a></p>';
    console.log('已挂载butterfly_footer_beautify')
    parent_div_git.insertAdjacentHTML("beforeend",item_html)
    }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_footer_beautify_injector_config();
  }
  else if (epage === cpage){
    butterfly_footer_beautify_injector_config();
  }
  </script><script async src="/js/footer.js"></script><!-- hexo injector body_end end --><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/koharu.model.json"},"display":{"position":"right","width":120,"height":240,"hOffset":50},"mobile":{"show":false},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/"});</script></body></html>