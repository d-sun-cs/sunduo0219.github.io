---
title: 编译原理
abbrlink: 118b8ca3
date: 2022-11-18 10:22:28
tags:
    - Computer
    - Compile Principle
category: Computer Theory
---

## 1 绪论

### 1.1 编译相关的概念

-   编译的概念

    -    编译就是将高级语言(**源语言**)翻译成汇编语言或机器语言(**目标语言**)的过程

-   三种程序

    -   **翻译**程序(**Translator**)： 将某一种语言描述的程序(Source Program)翻译成等价的另一种语言描述的程序(Object Program)的程序

        -   翻译程序-**解释**程序(**Interpreter**)：一边解释一边执行的**翻译程序**

            >   类似生活中的“口译”

        -   翻译程序-**编译**程序(**Compiler**)：将源程序完整地转换成机器语言程序或汇编语言程序，然后再处理、执行的**翻译程序**

### 1.2 编译系统的结构

-   编译系统的构成

    -   **编译程序**
        -   预处理器
        -   编译器
        -   汇编器
        -   链接器/加载器
    -   运行系统

-   编译器的8个模块

    ```
                                            |
                                            |SourceProgram
                                            V
        ------------                ----------------                  ------------
        |          |<-------------->|LxicalAnalyzer|<---------------->|          |
        |          |                ----------------                  |          |
        |          |                        |                         |          |
        |          |                        |Tokens                   |          |
        |          |                        V                         |          |
        |          |                    --------                      |          |
        |          |<------------------>|Parser|<-------------------->|          |
        |          |                    --------                      |          |
        |          |                        |                         |          |
        |          |                        |GrammarticalUnit         |          |
        |          |                        V                         |          |
        |   Form   |   --------------------------------------------   |  Error   |
        |Management|<->|SemanticAnalyzer IntermediateCodeGenerator|<->|Management|
        |          |   --------------------------------------------   |          |  
        |          |                        |                         |          |
        |          |                        |IntermediateCode         |          |
        |          |                        V                         |          |
        |          |                 ---------------                  |          |
        |          |<--------------->|CodeOptimizer|<---------------->|          |
        |          |                 ---------------                  |          |
        |          |                        |                         |          |
        |          |                        |IntermediateCode         |          |
        |          |                        V                         |          |
        |          |              ---------------------               |          |
        |          |<------------>|ObjectCodeGenerator|<------------->|          |
        ------------              ---------------------               ------------
                                            |
                                            |ObjectCode
                                            V
    ```

    -   分析
        1.  词法分析（lexical analyzer/scanner）
        2.  语法分析（syntax analyzer/parser）
        3.  语义分析
    -   综合
        1.  中间代码生成
        2.  代码优化
        3.  目标代码生成
    -   辅助
        1.  表格管理/符号表管理
        2.  出错处理

### 1.3 词法分析概述

-   功能
    -   生成token：词法分析器扫描源程序字符串，识别**单词**，确定类型，生成单词(***token***)串
        -   token：**(种别码, 属性值)**序对
    -   表格管理：登记标识符
    -   错误管理：查词法错误

-   输入与输出
    -   输入：源程序字符串
    -   输出：token序列

### 1.4 语法分析概述

-   功能

    -   token：从**token序列**中，识别**语法成分/短语**，构造**语法分析树**，指导**翻译**过程

        -   用token组成各类**语法成分/短语**：表达式、因子、项、语句、子程序…

            >    “组词成句”

    -   错误管理：指出**语法错误**

-   输入与输出

    -   输入：token序列
    -   输出：语法分析树（包括**语法成分**）

### 1.5 语义分析概述

-   功能
    -   语法分析树：根据语法分析树，分析由语法分析器识别出来的**语法成分的语义**
        -   语义分析一般和语法分析同时进行，称为**语法制导翻译(syntax-directed translation)**
        -   高级语言程序中的语句大体分为两类，一类是**声明语句**，一类是**可执行语句**。对于声明语句来说，语义分析的主要任务是**收集标识符的属性信息**
    -   表格管理：收集**标识符**属性信息，完善**符号表**；进行子程序和变量的**静态绑定**
        -   属性信息：种别、类型、值、作用域、...
        -   子程序：代码的相对地址
        -   变量：数据的相对地址，大小
    -   错误管理：**语义检查**
        -   变量或过程**未经声明就使用**
        -   变量或过程名**重复声明**
    
        -   **运算分量**类型不匹配
    
        -   **操作符**与**操作数**之间的类型不匹配
    
-   输出与输出
    -   输入：语法分析树（包括**语法成分**）
    -   输出：语法分析树（包括**语法成分**）

### 1.6 中间代码生成及编译

-   功能：

    -    生成与机器无关、易于优化与转化的中间表示形式（常用**三地址码**），以此**实现语义**

         >   三地址码又有多种表示形式，其中**四元式**较为常用
         >
         >   中间代码的**优点**：
         >
         >   -   方便通过中间表示形式进行**代码优化**
         >
         >   -   方便源程序的跨平台**移植**

-   输入与输出

    -   输入：语法分析树（包括**语法成分**）
    -   输出：中间表示形式（常用**三地址码**）

### 1.7 代码优化

-   功能
    -    通过**等价**程序变换对中间代码进行优化，使程序更有效利用机器资源，节省**存储空间**，提高**运行速度**和效率

-   优化方式
    -   与机器无关的优化
        -   局部优化
            -   常数合并
            -   公共子表达式提取
        -   循环优化
            -   强度削减
            -   代码外提
        -   全局优化
    -   与机器有关的优化
        -   寄存器的利用
        -   体系结构
        -   存储策略
        -   任务划分

### 1.8 目标代码生成

-   功能：将**中间代码**转换成**目标机**上的机器指令代码或汇编代码

    >   目标代码的形式：
    >
    >   -   具有**绝对地址**的机器指令
    >   -   模块结构的机器指令（需要**链接程序**）
    >   -   汇编语言

-   输入与输出

    -   输入：中间表示形式（常用**三地址码**）
    -   输出：目标代码（一般为汇编语言）

### 1.8 表格管理

管理各种**符号**和**符号表**，辅助语法检查、语义检查，完成静态绑定，为编译的各个阶段提供信息

### 1.9 错误管理

进行各种错误的检查、报告、纠正，以及相应的**续编译处理**

### 1.10 编译程序的组织与生成

*编译程序设计的目标：*

-   程序本身：
    -    规模小、速度快、诊断能力强、可移植性好，可扩充性好

-   目标程序：
    -    规模小、速度快

---

*前端与后端：*

-   前端：

    -    与源语言有关、与目标机无关

         >   词法分析、语法分析、语义分析与中间代码生成、与机器无关的代码优化

-   后端：

    -    与目标机有关的部分

         >   与机器有关的代码优化、目标代码生成

*编译器的实现与T形图：*

-   编译器的实现思想：

    -    自展：先实现**语言子集**编译器，再用子集编译更大的集合，直至整个语言

-   T形图：

    -   内容：描述了**源语言**经编译程序到**目标语言**的过程

        ```
         --------------------------------              
         |SourceLanguage  ObjectLanguage|                
         ---------                -------           
                 |CompilingProgram|
                 ------------------
        ```

        >   **编译程序(CompilingProgram)的实现语言**可以是高级语言、汇编语言、机器语言，但终究只有**用机器语言实现**才能运行该程序

    -   作用：T形图可以直观描述语言**移植**、**新语言编译**等问题

## 2 程序设计语言及其文法

### 2.1 字母表和串

-   **字母表**及其乘积、幂、闭包等运算

-   **串**及其连接、幂等运算

### 2.2 文法

文法是一个具有**推导**和**归约**功能的**四元组**：

-   **终结符集**（$V_T$）

-   **非终结符集**（$V_N$）：与终结符集不相交

-   **产生式集**（$P$）

    -   左部属于$(V_T\cup V_N)^+$

    -   右部属于$(V_T\cup V_N)^*$

        >   所以只有**产生式的右部**可以出现$\epsilon$

-   **开始符号**（$S$）：至少在产生式左侧出现一次

    -   $S\in V_N$


文法主要包括**语法和词法**：

-   **语法**：语句的组成规则

-   **词法**：单词的组成规则

### 2.3  语言

-   语言的定义
    -   由文法**开始符号**推导出的所有**句子**构成的集合称为**文法生成的语言**。

-   语言的表示/描述
    -   文法解决了**无穷语言的有穷表示**问题。

-   语言的运算
    -   语言有并、连接、幂、闭包等运算。

### 2.4 文法的分类

>   从上至下，**要求依次累加**

-   无限制文法/短语结构文法（0型文法、图灵机）

    -   新增的约束：产生式**左部**至少包含一个**非终结符**

-   上下文有关文法（1型文法、线性界限自动机）

    -   新增的约束：产生式**左部长度小于右部**

        >   当然，也允许**空产生式**的出现，这是个特例

-   上下文无关文法（2型文法、下推自动机）

    -   新增的约束：产生式**左部仅为非终结符**

        >   左部仅有一个非终结符，右部长度大于左部

    -   应用：识别**语言**（语法、语义分析）

-   正则文法（3型文法、有穷自动机）

    -   新增的约束：仅允许**左线性(非终结符**只能出现在最左边)或**右线性**(**非终结符**只能出现在最右边)
        -   产生式右部中，非终结符要么不出现，要么只出现一个
    -   应用：识别**单词**（词法分析）

### 2.5 CFG的分析树

-   分析树是**推导**的图形化表示：

    -   根节点：文法**开始符号**
    -   内部结点：代表**产生式**
        -   **左部**：该节点
        -   **右部**：子结点从左到右
    -   叶结点：非终结符或终结符
    -   **树的产出/边缘**：从左到右排列叶节点

-   （句型的）短语：分析树中每一棵**子树的边缘**（若干步推导）

    -   直接短语（简单短语）：高度为2的子树的边缘（一步推导）

        >   注意子树的定义，需要从一个节点**延伸直到叶子节点**才叫子树，而且高度要大于等于2

    -   句柄：句型的**最左直接短语**/最左边高为为2子树的边缘

        >   不同子树的边缘可以相同，但**短语不必重复**。不过，对于出现在树中不同位置的**相同文法符号**，在短语中应当**区别**对待，可以用**下标**来区分它们

-   二义性文法与消歧规则

    -   二义性文法：文法可以为某个句子生成多棵分析树
    -   消歧规则：人为规定一些**优先级**关系

### 2.6 程序设计语言

-   概念
    -   程序设计语言(ProgrammingLanguage)：组成程序的**所有语句**的集合
    -   程序(Program)：满足**语法**规则的**语句序列**
    -   语句(Sentence) ：满足**语法**规则的**单词序列**
    -   单词(Token) ：满足**词法**规则的字符串

## 3 词法分析

### 3.1 正则表达式

-   正则表达式是描述**正则语言**的**更紧凑**的表示方法，它可以**递归构建**

-   与**正则文法、有穷自动机**等价

    >   正则表达式很**简洁**；
    >
    >   正则文法方便文法**性质**的证明；
    >
    >   有穷自动机没那么抽象，方便**实现**；

-   有自己的**代数定律**

### 3.2 有穷自动机

>   核心就是：`状态 + 输入 + 转换`

-   有穷自动机（FA）：

    -   一种处理系统的数学模型。这种处理系统由**输入带、读头、有穷控制器**构造，可以根据当前**状态**和**输入**转入下一状态。
    -   FA有其定义/接收的**语言**
    -   FA遵循最长子串匹配

-   DFA：一种代表FA模型的**五元组**

    -   **有穷状态集**（S）

    -   **输入字母表**（$\Sigma$）

        >   $\epsilon\notin\Sigma$

    -   **转换函数**（$\sigma$）：$S\times\Sigma\rarr S$

    -   **开始状态**（$s_0$）

    -   **接收状态集合**（$F$）

-   NFA：一种代表FA模型的**五元组**

    -   **有穷状态集**（$S$）

    -   **输入字母表**（$\Sigma$）

    -   **转换函数**（$\sigma$）：$S\times\Sigma\rarr 2^S$

        >   $\epsilon-NFA$与$NFA$的区别就在于转换函数：$S\times(\Sigma\cup\{\epsilon\})\rarr 2^S$

    -   **开始状态**（$s_0$）

    -   **接收状态集合**（$F$）

### 3.3 RE与FA的转换

-   $RE\rarr NFA$：**分解、递归**
    -   RE与NFA的对应规则

-   $NFA\rarr DFA $：**状态转换表**
    -   子集构造法

### 3.4 词法单元token

-   概念：
    -    词法单元token是源程序中**单词的机内表示**，由**种别码和属性值**构成

-   种别码：
    -    记录单词**类型**

    -    一词一码：关键字、运算符、界限符
    -    一型一码：常量、运算符
    -    多词一码：标识符

-   属性值：
    -    记录单词**字面值**

    -    一词一码：**不需要属性值**
    -    一型一码：用**属性值区分**同一类型的单词
    -    多词一码：用属性值记录**无法枚举**的标识符字面值

### 3.5 词法分析器

-   词法分析器的功能

    -   词法分析器扫描源程序字符串，识别**单词**，确定类型，生成单词(***token***)串

        -   根据**词法规则**识别及组合单词，进行词法检查

        -   对**数字**常数完成数字字符串到**二进制数值**的转换

        -   预处理：删去**空格**字符和**注释**

            >   给人看的，对**机器**无意义

-   词法分析器的工作

    -   输入缓冲区（Look ahead）：设置一个单词开始指针和扫描指针，**一前一后**，中间的部分是要识别的单词
    -   识别出关键字后需要登记符号表

### 3.6 词法分析阶段的错误处理

-   错误类型

    -   **单词拼写**错误
    -   **非法字符**
    -   不封闭
    -   重复声明

-   错误恢复与续编译：错误处理程序

    -   调用时机：**当前状态与当前输入信息为空**

    -   处理方式：查找已扫描字符串的最后一个**终态字符**

        >   终态指的是自动机终态

        -   找到了：识别成一个**单词**，回到初态
        -   没找到：错误恢复策略（**恐慌模式**）

    -   恐慌模式：从**剩余输入中删除字符**直到遇到正确字符

## 4 语法分析

### 4.1 句法分析概述

-   主要任务: 
    -    从***token***序列**中，识别**语法成分/短语**，构造**语法分析树**，指导**翻译过程

-   基本方法: 
    -   自顶向下: 自顶向下构造语法分析树, 根据**输入符**，选择合适的**产生式**推导**最左非终结符**, 直到推导出完整的输入串
        -   递归下降分析法
        -   预测分析法
    -   自底向上: 自底向上构造语法分析树, 根据**输入符,** 选择合适的**句柄**进行归约, 直至将输入符串归约为文法开始符号
        -   算符优先分析法
        -   LR分析法

### 4.2 自顶向下分析概述

*自顶向下分析的基本思想与主要问题：*

-   基本思想

    -    自顶向下构造语法分析树, 根据**输入符**，选择合适的**产生式**推导**最左非终结符**, 直到推导出完整的输入串

    -    最左非终结符也是当前语法分析树的**最左非终结符节点**, 代表**最左推导**
    -    替换后会在语法分析树上**生成子节点**

-   主要问题

    >   本质上是**文法改造问题**，都是基于**上下文无关文法**的改造

    -    二义性问题

         -   问题描述：文法中存在句子有不只一棵**语法分析树**

             >   注：不存在算法判断一个上下文无关文法是**无二义性**的，但可以给出一组**充分条件**，满足充分条件的文法是无二义性的
             >
             >   做题的时候尝试去寻找同一句型的多棵分析树即可
    
         -   解决方法：改造文法，引入**细粒度的文法变量**；或人为规定优先级
    
             >   例如：
             >
             >   -   解决加法和乘法优先级问题：引入**项**和**因子**的文法符号
             >   -   解决`if`匹配问题：引入**“匹配”**和**“不匹配”**的文法符号
             >       -   `if-else`的就近原则
    
    -    回溯问题

         -   问题描述：多个**候选式**存在**公共前缀**

         -   解决方法：改造文法；提取左公因子（本质是在推迟决定）
             -   通过**FIRST集**和**FOLLOW集**判断是否会出现回溯
             
             -   提取左公因子的一般形式：`S->cA|cB ----> S->cS' S'->A|B`
             
                 >   把相同的留着，不同的交给新的文法变量去推
    
    -    左递归问题
    
         -   问题描述：直接左递归、间接左递归
    
         -   解决方法：消除左递归
    
             -   消除**直接左递归**的一般形式：$A\rarr A\alpha_1|A\alpha_2|...|A\alpha_n|\beta_1|\beta_2|...|\beta_m $
    
                 -   转化为：
    
                     -   $A\rarr\beta_1A'|\beta_2A'|...|\beta_mA'$
    
                     -   $A'\rarr\alpha_1A'|\alpha_2A'|...|\alpha_nA'|\epsilon$
    
                         >   把不左递归的先推出来，原左递归的交给新的文法符号改成右递归，再加空
                         >
                         >   本质上是将左递归转换成了**右递归**，付出的代价是引入一新的**非终结符**和**空产生式**，注意最后的**空产生式**
    
             -   消除**间接左递归**：先代入到最大编号，再消除直接左递归
             
                 -   给所有产生式**左部编号**，按编号**从小到大遍历**
                 -   如果出现**左部编号大于右部开头编号**，则出现左递归
                 -   若出现左递归，将相关产生式**代入到左部编号最大的产生式**中，转换成**直接左递归**，然后消除直接左递归

---

*预测分析法的基本思想：*

-   预测分析: 
    -    一般的自顶向下分析往往会因为**产生式选择的不确定性**而需要**回溯**，但**预测分析**就不需要回溯，它依据**预测分析表**，是一种**确定的自顶向下分析方法**

-   文法改造与检查：
    -    并不是所有文法都直接适用于自顶向下的分析，文法转换就是要**改造这些文法**以使其适合**自顶向下的分析**。
         -    消除文法的二义性
         -    消除文法的回溯
         -    消除文法的左递归

    -    改造文法后，还要检查文法是否为LL(1)的

---

*递归下降分析法的基本思想：*

-   根据文法产生式，定义可以递归调用的函数

### 4.3 预测分析法

>   总结
>
>   1.  构造与检查文法
>       1.  构造一般文法
>       2.  改造文法：消除二义性、消除左递归、消除回溯
>       3.  检查是否为LL(1)文法
>
>   1.  设计算法
>       1.  构造**预测分析表**
>       2.  非递归的预测分析：下推自动机

*重要集合的引入与计算：* 

-   FIRST集

    -   定义：文法符号(串)经过**若干步推导**得到的所有符号(串)的**首终结符**的集合

        -   若干步：零步、一步、多步

            >   后面出现的所有“推导”，若无特殊说明，均指的是“经若干步推导”

        -   特例：若能推导出$\epsilon$，则$\epsilon$也加入FIRST集

    -   计算：不断包含右部“开头”符号的FIRST集

        -   终结符的FIRST集**：**只包含该终结符一个元素的集合

        -   **非终结符FIRST集**：**不断包含右部“开头”符号的FIRST集**

            -   右部开头是**终结符**或右部为**空**：直接包含终结符或$\epsilon$
            -   右部开头是**非终结符**：
                -   包含该非终结符的FIRST集（先不包括$\epsilon$）
                -   同时若该非终结符能推导出$\epsilon$，则继续加入右边紧邻符号的FIRST集，直到不能推导出$\epsilon$
                -   若都能推导出$\epsilon$，再将$\epsilon$加入FIRST集中

            >   **文法符号串的FIRST集：**
            >
            >   -   从左向右看，加入**第一个符号的FIRST集**
            >   -   若第一个符号能推导出$\epsilon $，就累加下一个**符号的FIRST集**，直到不能再推出$\epsilon$
            >
            >   -   如果都能推导出$\epsilon $就再加入$\epsilon $

-   FOLLOW集

    -   定义：是**非终结符**相关的一种集合，即**推导**过程中可以**紧跟在该非终结符右侧**的**终结符**的集合
    -   计算：不断包含**右侧的FISRT集**和作为右部结尾时**左部的FOLLOW集**
        -   将**结束标记**加入开始符号的FOLLOW集中
        -   加右边的FIRST集：单看**产生式右部**，跟在某一非终结符**后面的符号串的FIRST集**加入该非终结符的FOLLOW集中，但不能加入$\epsilon$
        -   加左部的FOLLOW集：看**整条产生式**，**右部结尾**的非终结符，以及可能因右方非终结符推导出$\epsilon$而**变成右部结尾**的非终结符，其FOLLOW集要**包含**左部非终结符的FOLLOW集

-   SELECT集

    -   定义：是产生式相关的一种集合，即推导过程中可以选择该产生式时的**输入符号**的集合
    -   计算：产生式的SELECT集的计算
        -   若是空产生式，则为**左部**非终结符的**FOLLOW集**
        -   若非空产生式，则为**右部**符号串的**FIRST集**，不过若这个FIRST集中包含$\epsilon$，就要去掉$\epsilon$再并上左部的FOLLOW集

---

*适合预测分析的文法：*

>   目标：构造不需要回溯、可用于预测分析的文法（前提是要先适用于自顶向下分析）

-   S_文法

    -   产生式**右部**以**终结符**开始（不包含$\epsilon$产生式）
    -   同一非终结符各个候选式的**首终结符**都不相同

-   q_文法

    -   产生式**右部**或为$\epsilon$，或以**终结符**开始
    -   具有相同左部的产生式有**不相交的可选集**
        -   可选集：可以使用该产生式推导时的**输入符号**集合，称为这个产生式的可选集

-   LL(1)文法：同一非终结符各个**产生式**的**SELECT集**互不相交

    >   从**左**向右扫描，构造最**左**推导

    >   下面这三条限制就是为了保证“同一非终结符各个产生式的**SELECT集**互不相交”，是**所有非终结符**都要满足的
    
    -   同一非终结符的候选式的FISRT集互不相交
    -   只能有一个候选式可以推出空，若存在这样的一个候选式，则还要求左部的FOLLOW集与所有候选式的FIRST集互不相交

---

*预测分析法的工作：*

-   预测分析的格局/表驱动的下推自动机

    -   控制程序：包含通用的控制**算法**

        >   例如接下来要讲的表驱动的预测分析算法

    -   栈：分析栈，指导**语法分析树**的形成。初始时栈底符号为#，栈顶符号为文法开始符号

        >   预测分析中，栈中的内容就是**句型**

    -   输入：**输入**缓冲区，#为输入串结束符

    -   表：**预测分析表M**

        -   内容：行是**非终结符**，列是**输入符号和#**，表项是以行非终结符为左部的产生式

            >   列输入符号要包含于表项产生式的SELECT集

        -   使用：栈顶非终结符作为行，当前输入作为列，找到表项中的产生式进行推导

-   预测分析表的构建

    -   对于任意产生式，只要输入符号在右部的FIRST集中，就可以选择
    -   同时对于右部能推出空的产生式，输入符号在左部的FOLLOW集中时也可以选择
    
-   **表驱动的预测分析法/**非递归的预测分析法：

    -    借助**下推自动机和预测分析表**

    -    对比输入符号与栈顶符号，直到**栈顶和输入**都为结束符
    -    若栈顶符号为**终结符**
         -   二者**相等**，则弹栈，消耗输入符号，读头后移
         -   二者不相等，则报错
    -    若栈顶符号为**非终结符**：查询预测分析表得到**产生式**，左部弹栈，右部入栈（**自右向左**入栈）不消耗**输入符号**

---

*预测分析法的错误处理：*

-   错误检测

    -   最左/栈顶**终结符**与当前**输入符号不匹配**
    -   最左/栈顶**非终结符**与当前输入符号在**预测分析表**中**无可用产生式**

-   错误恢复：恐慌模式

    -   最左/栈顶**终结符**与当前输入不匹配时：直接忽略输入符号（删除）

    -   最左/栈顶**非终结符**与当前输入符号在**预测分析表**中无可用产生式：

        -   若输入符号不在该非终结符的**FOLLOW集**中，则忽略输入符号（删除）

        -   若输入符号在该非终结符的**FOLLOW集**中（同步词法单元），则忽略/弹出该非终结符

            >   FOLLOW集本质就是非终结符**推出空**时的SELECT集

### 4.4 递归下降分析法

-   文法：要求文法是LL(1)的

-   分析：从文法**开始符号的产生式**开始，遍历右部符号（即**调用文法开始符号的过程**）

    >   遍历符号的过程中，每次取得一个输入，终结符消耗输入，非终结符根据输入选择产生式

    -   若为终结符，则必须等于当前输入符号，否则报错

    -   若为非终结符，则“递归”调用**该非终结符对应的过程**

        >   非终结符对应的过程：
        >
        >   -   若有**多条产生式**，先根据输入和SELECT集选择产生式
        >   -   遍历产生式右部符号，若是终结符，则当前输入必须与之相等，否则报错；若是非终结符，则调用其过程

    -   最后一个输入符号必须是终结符

### 4.5 自底向上分析概述

*自底向上分析的基本思想与主要问题：*

-   基本思想

    -   自底向上构造语法分析树, 根据**输入符,** 选择合适的**句柄**进行归约, 直至将输入符串归约为文法开始符号

        -   句柄：当前句型的**最左直接短语**
        -   归约句柄：**最左归约**

    -   移入-归约的思想

        -    自底向上分析也叫**移入-归约分析**

             >   借助**栈**来理解

        -   移入：将**输入符号**压入栈

        -   归约：从栈中依次**弹出**能构成**产生式右部**的若干个符号，然后将**左部压入栈**（最左归约）

            >   最左归约称为规范归约、最右推导称为规范推导，每次用于归约的符号串称之为**句柄**，也就是**产生式右部**

-   主要问题

    -   何时移入、何时归约、归约时用什么归约
    -   移入-归约分析中的关键问题是**正确识别句柄**

-   系统框架

    -   控制程序

    -   栈：分析栈

        >   自底向上分析中，**栈和输入**中的内容组合起来是(规范)句型，栈中的内容只是句型的**前缀**

    -   输入：输入缓冲区

    -   表：指导**语法分析树**的形成，确定**移进和归约**的时机

---

*优先法的基本思想：*

-   优先级的概念：优先级指的是**归约的优先级**

-   优先级的作用：确定何时移进何时规约
    -   **栈顶**最近的终结符优先级**小于或等于输入**符号：移入
    -   **栈顶**最近的终结符优先级**大于输入**符号：归约
        -   归约的句柄是从栈顶到第一次优先级**小于**输入的位置（不包括）

-   核心问题：优先级的确定


---

*状态法/LR分析的基本思想：*

>   从**左**到右扫描，反向构造最**右**推导

-   **状态**：

    -    用**状态**表示**句柄识别的进展程度**

         >   状态的可视化表示就是在产生式右部插入一个圆点，代表**离可以使用该产生式归约**还差什么符号，**圆点右边的符号**就是需要的符号

    -   移进状态：圆点后面是终结符

    -   待约状态：圆点后面是非终结符

    -   归约状态：圆点后面没有符号

-   **栈**：

    -    有两个栈，**状态栈与符号栈**，它们是平行的（栈中**元素个数保持相等**）

-   **分析表**：

    -    只要构造出正确的**分析表**就可以直观且快速地识别了，分析表的概述如下：

    -   内容：

        -   **一行**对应一个**状态**，一个状态的**一条边**对应于该行的**一个表项**

            >   这里的**边**指的是自动机中的边

        -   **一列**对应一个**文法符号**，终结符和结束符在**ACTION列组**，非终结符在**GOTO列组**

    -   应用：

        -   从状态栈只有初始状态0、符号栈只有结束符$开始，根据**当前状态(行)和输入符号(列)**找到表项，执行对应的操作，直到读取输入后找到的表项为acc或err

            >   acc时，栈中为S，输入缓冲中为#

        -   表项中，$s_n$代表将**所在列对应符号和状态n**同时压入栈符号栈和状态栈；$r_n$代表使用第n个产生式归约，同时弹出**产生式右部**符号(串)和与其**平行的状态**，并压入**左部非终结符**，再根据**当前栈顶状态**和**该非终结符**找到GOTO列组的项k，这代表着再**将状态k压入栈**；acc代表成功识别，err代表出错

            >   所以，**构造出文法的分析表**是LR分析的关键

### 4.4 算符优先分析法

*适合算符优先分析的文法：*

-   算符文法：

    -    文法中不存在具有**相邻非终结符**的产生式

-   算符优先文法：

    -   定义：可以根据产生式推断出**不矛盾优先级**关系的**算符文法**

    -   终结符优先级的确定：

        -   **相邻或只间隔一个非终结符**，则优先级相等

        -   经由非终结符**推导**至少一步后**相邻或只间隔一个非终结符**，则被推导出的优先级更高，且应当认为**左边**的处于**栈**中，**右边**的处于**输入缓冲**中

            >   对于不能通过产生式判断优先级的算符文法，也可以**人为规定优先级**

---

*算符优先矩阵：*

-   FIRSTOP与LASTOP

    -   非终结符的FIRSTOP集：该非终结符经过至少一步推导得到的**串首终结符或**去掉串首的**一个非终结符**后成为串首终结符的集合
    -   非终结符的LASTOP集：该非终结符经过至少一步推导得到的**串尾终结符或**去掉串尾的**一个非终结符**后成为串首终结符的集合

-   算符优先矩阵

    -   内容：

        -   行：栈内符号

        -   列：输入符号

            >   注意行列不要颠倒；也可以包括#，栈中的#对应于FIRSTOP，输入中的#对应于LASTOP

    -   填写：

        -   遍历所有产生式右部的所有相邻符号，确定优先级
        -   应当认为左边的处于栈中，右边的处于输入缓冲中

-   优先函数

    -   构造方法：

        -   通过算符优先矩阵规定的偏序关系，构造DAG，计算拓扑排序，基于拓扑排序构造优先函数

    -   优点：节省存储空间

    -   缺点：错误检测能力降低
    
        >   详见笔记仓库

---

*算符优先法的素短语：*

-   素短语：**含终结符**且不含有更小**含终结符短语**的短语

-   算符优先法归约的是**最左素短语**，并非**最左直接短语**

### 4.5 LR分析法

>   ⭐️LR系列的相关概念较多，暂不探讨定义这些概念的内在原因，只要能将其**应用到问题中**即可

*LR(0)分析：*

-   LR(0)相关概念

    -   **增广文法**：新增开始符号，它能推导出原开始符号（$S'\rarr S$）

        >   增广文法让文法**开始符号**仅出现在一个产生式的**左边**，这样分析器**只有一个接受状态**

    -   **项目**：项目描述了**句柄识别的状态**

        -   移进项目

        -   待约项目

            >   开始符号对应的待约项目称为初始项目（$S'\rarr\cdot S$）

        -   归约项目

            >   开始符号对应的归约项目称为接收项目（$S'\rarr S\cdot$）
            >
            >   产生式$A\rarr\epsilon$只生成一个项目$A\rarr\cdot$

    -   **后继项目**：同属一个产生式但圆点只差一个符号，圆点在后的是后继项目

    -   **等价的项目/项目集闭包**：对于一个**待约**项目，它的等价项目就是，以该待约项目**圆点后面的符号**为**左部**的所有产生式将圆点放在**右部第一个符号前**得到的项目；被等价推出的**待约**项目可以继续等价推出，直到不能再推出新的待约项目。这样推出的所有项目都放在一个集合中，这个集合就是**项目集闭包**。

        >   对于移进项目和归约项目，它们可以被待约项目等价推出，但不能等价推出别的项目。如果它们不能由某个待约项目等价推出，则它们没有等价项目

    -   项目集对应于**文法符号X**(包括终结符和非终结符)的**后继项目集闭包**（`GOTO(I, X)`函数）：项目集中**圆点右紧邻符号为X**的每一个项目的**后继**项目集闭包的并

-   LR(0)自动机与分析表

    -   自动机的构造

        -   初始项目（$S'\rarr\cdot S$）的**项目集闭包**构成**状态0**
        -   对于**每一个现有状态**，求其对于**每一个文法符号(包括终结符和非终结符)**的后继项目集闭包（`GOTO(I, X)`），若`GOTO(I, X)`不为空，则将其作为一个新的状态（如果是已经存在的状态就不必当成新状态了），并生成一条当前状态指向`GOTO(T, X)`对应状态的**有向边**，边上的符号为当前文法符号
        -   循环执行2**直到不再增加有向边**

    -   分析表的构造

        -   行：所有**状态；**列：ACTION列（所有终结符+结束符）和GOTO列（除了增广的非终结符）

        -   **接收项目**是单独在一个状态里，对应**接收状态**，在表中与结束符$形成表项acc

        -   对于一个状态i（一行）

            >   一个状态中若既有**归约项目**又有其他类型的项目，则会出现冲突，这里暂不考虑

            -   出边上是**非终结符**的，对应该行的**GOTO表项**，为有向边指向的状态编号j
            -   出边上是**终结符**的，对应该行的**ACTION表项**，为有向边指向的状态$s_j$
            -   若**没有出边**，或者说状态中**只有一个归约项目**，则该行的ACTION表项全为$r_k$（k为该归约项目对应的**产生式编号**）

-   LR(0)会有**移进/归约**冲突和**归约/归约**冲突

    >   总得来说，就是该不该归约的问题

    -   对应到自动机中，就是一个状态中**同时存在归约项目和其他类型项目**，或者同时存在**多个归约项目**，导致遇到下一个输入时无法判断执行什么动作
    -   对应到分析表中，就是ACTION列组的**一个表项**会有**两个可选值**
    -   出现问题的本质原因是，LR(0)分析没有**向前查看符号**，没考虑**上下文环境**

---

*SLR分析：*

-   SLR分析基本思想

    >   S：Simple，仅通过FOLLOW集化解冲突

    -   是对LR(0)分析的改进，**在LR(0)分析的基础上**，不是**子成分**都全了就能归约的，因为归约后左部符号的**FOLLOW集**中可能没有该输入符，也就是归约后的符号可能不是**待分析句子中的一个成分**

    -   当遇到LR(0)中所述冲突时，要考察两种集合(是两种，不是两个。第一种里只有一个，第二种里可以有多个)：

        -   第一种是状态中**所有移进/待约项目**圆点右侧符号构成的集合，
        -   第二种是状态中所有**归约项目**对应产生式左部非终结符的**所有FOLLOW集**。

    -   当这些集合两两不相交时：

        >   若不能做到两两不相交，则说明SLR无法解决这种冲突

        -   若**输入符号**在圆点右侧符号构成的集合中，则执行对应的移进ACTION；
        -   若**输入符号**在某个归约项目左部的FOLLOW集中，则执行对应的归约ACTION。
        -   其他情况报错

-   SLR自动机与分析表

    -   自动机的构造：与LR(0)一样的

    -   分析表的构造：在LR(0)构造的分析表基础上，只有**ACTION列的终结符(输入符号)**在对应状态中归约项目左部符号的**FOLLOW集**中时，才进行归约，否则的话，要么是**移进**，要么**表项为空**

        >   若这样做之后一个表项中还是会留下多个动作，则说明SLR无法解决这种冲突

-   SLR分析中的冲突

    -   上述的两种集合不能做到**两两不相交**
    -   本质原因是，对于归约项目，输入符号在其左部**FOLLOW集**中，只是能归约一个**必要条件**，并非充分条件

---

*LR(1)分析：*

-   基本思想与概念

    -   在LR分析的**特定位置**，对于非终结符A，并非FOLLOW(A)中的所有符号都可以接在A后面，所以并不是输入符在FOLLOW(A)中了就可以使用以A为左部的这条产生式进行归约，我们需要找到**非终结符A在特定位置的后继符**

        >   也就是说，需要考虑程序**上下文**，而LR(1)就是在考虑**下文的第1个符号**

    -   规范LR(1)项目：$A\rarr\alpha\cdot\beta, a（第一分量,第二分量）$

        -   第一分量：右部带圆点的产生式（就是之前对于项目的定义）

        -   第二分量：展望符，代表当前状态下A后面可以紧跟的终结符。对于归约项目（$A\rarr\alpha\cdot,a$），代表输入符号为a时才能使用该产生式归约

            >   对于移入项目和待约项目（$A\rarr\alpha\cdot\beta, a且\beta\ne\epsilon$），**展望符与之无关**，但为了定义的完整，把它写出来了

    -   **等价**LR(1)项目/**展望符**的计算：

        -   第一分量：就是之前定义过的**等价项目**

        -   第二分量/展望符：要看等价项目产生式的**左部**在原项目中**右边的符号(串)**$\beta$。若$\beta$能推出空（或者$\beta$本身就是空的），则直接继承相同的展望符构成项目, 同时，对于$FIRST(\beta)$中的每个终结符，都可以再作为**展望符**与相同的**第一分量**构成一个等价的项目

            >   从计算展望符的角度讲，就要从初始项目$S'\rarr\cdot S,\$ $出发按照自动机的构造方法去计算了，移进的时候展望符不变；第一分量相同的项目，可以合并到一起写，**展望符用/隔开**，但要知道这是多个项目

-   LR(1)的自动机和分析表

    >   相比于LR(0)，LR(1)对于CLOSURE、GOTO、项集族、自动机、分析表构造算法都做了适合于**展望符与归约项目**的修改

    -   自动机的构造：从初始项目$S'\rarr\cdot S,\$ $开始，与LR(0)的生成规则类似，只是在计算项目等价的时候要考虑**展望符**

    -   分析表的构造：

        -   对于不涉及归约项目的状态，处理方法与LR(0)相同

        -   对于涉及**归约项目**的状态，只有ACTION列(输入符号)是状态中归约项目的**展望符**时才能规约(且必须归约)

            >   之前构造SLR的时候，是遇到左部FOLLOW集中的符号都能规约

---

*LALR分析：*

-   LALR基本思想与概念

    -   LR(1)的状态过多，其中有些状态是可以合并的
    -   **同心项目集**（同心状态）：只保留第一分量时(重复的只留一个)，完全相同的项目集
    -   同心项目集是可以合并成一个状态的，其实是在对**展望符**进行合并

-   LALR的自动机与状态表

    -   自动机：在构造出的LR(1)自动机基础上，合并同心项目并修改边
    -   分析表：与LR(1)的构造方法相同

-   LALR的问题

    -   归约-归约冲突：同一个输入符，不知道该用状态中的哪个产生式归约了，因为它们的**展望符**都相同

    -   推迟错误发现：合并同心项集后，虽然不产生冲突，但可能会**推迟错误的发现**

        >   LALR分析法可能会作多余的**归约动作**，但绝不会作错误的**移进操作**。因为LALR其实是在合并展望符集合，而展望符与归约有关，与移进无关

-   LALR的特点

    -   形式上与LR(1)相同，都有**展望符**
    -   大小上与LR(0)/SLR相当，因为**合并了状态**
    -   分析能力上，SLR<LALR<LR。相比于SLR，LALR细化了状态；相比于LR(1)，LALR会延迟错误的发现。

---

*错误处理：*

-   当没有可选动作时，在符号栈中寻找上一个**归约出来的非终结符**，然后丢弃输入符号直至当前输入在该非终结符的FOLLOW集中，然后移进该输入，再压入一个与该非终结符平等的状态，继续分析

    >   本质上是找到上一次正确归约的语法分成，跳过当前出错的语法成分，继续分析下一个语法成分

## 5 语法制导翻译

>   对产生式的理解：在编译原理中，产生式往往有着具体到代码层面**实际意义**，产生式的**结构/应用场景**决定了其在翻译过程中的实际意义
>
>   对语义分析的理解：语法分析中用产生式进行推导/规约，其实就是在**分析语法结构**，找到结构后就要做**翻译动作**，进行一些**静态语义检查**和**中间代码生成**

### 5.1 相关概念与基本思想

-   概念：将**静态语义检查**和**中间代码生成**结合到语法分析中进行的技术称为**语法制导翻译**

-   基本思想：语法制导翻译的基本思想是，用**产生式**代表**语法规则**，再为产生式关联**语义规则**，在**构造语法分析树**时通过语义规则**计算语义属性值或执行某些动作**

-   语法制导定义SDD：

    >   对上下文无关文法的推广

    -   **语义属性**：为每个文法符号设置若干**语义属性**

        -   **语义属性的作用**：在推导/规约过程中**传递信息**

            >   不传递的话之后要用就找不到了

    -   **语义规则**：为每条产生式关联若干**语义规则**，语义规则用于**计算语义属性值**

-   语法制导翻译方案SDT：

    -   **语义动作**：在SDD的基础上，直接**将语义规则嵌入产生式右部**，称为**语义动作**

        >   将**属性值计算**的工作解耦给**语义动作**

        -   **语义动作的执行：**在产生式中的**位置**决定了其**执行时间**

    -   **SDT与SDD的关系**：SDT可以看作是SDD的**具体实施方案**，有SDT就能按照一定的**工作流程**计算所有语义属性值

        >   SDT通用的实现方法：首先建立一棵**语法分析树**，然后按照**从左到右的深度优先顺序**来执行这些动作

### 5.2 语法制导定义

-   文法符号的属性：

    -   **综合属性**：
        -   非终结符的综合属性：只能通过**子结点**或其本身的属性值定义
        -   终结符的综合属性/**固有属性**：由词法分析器提供的词法值（**token属性值**）
    -   **继承属性**：
        -   非终结符的综合属性：只能通过**父结点、兄弟结点**或其本身的属性值定义
        -   终结符没有继承属性

-   副作用与属性文法：

    -   **副作用**：有的语义规则目的是产生**副作用**，用到其他结点的属性值，但不计算新的属性值，可以理解成在计算**虚属性**

        >   比如打印、在符号表中创建记录并设置类型等等

    -   **属性文法**：没有副作用的SDD称为**属性文法**，仅通过其他属性值和常量定义属性值

-   属性求值方法：

    -   属性求值遵循的顺序：**依赖图的拓扑排序**
    -   依赖图：依赖图是描述分析树**结点属性的依赖关系**的有向图，以语法分析树为基础图，若结点X有属性a，则将a也作为依赖图中的结点（画在X旁边）；若属性X.a的值计算依赖于Y.b，则添加一条Y.b指向X.a的有向边；如果有“虚属性”，也可以画在结点旁边。
    -   求值的可行性：一个SDD不一定存在可行的求值顺序，有可能发生**循环依赖**

-   属性定义：

    -    SDD的有用子类，一定存在一个**求值顺序**

    -    **S-属性定义/S-属性文法/S属性的SDD**：只具有**综合属性**的SDD

         -   属性求值方法：S-SDD可以按照语法分析树**自底向上**的顺序计算各属性值
         -   在语法分析中的实现：S-SDD可以**在自底向上的语法分析**中实现

    -    **L-属性定义/L-属性文法/L属性的SDD**：每个属性要么是**综合属性**，要么是只依赖 **父结点继承**属性、**左兄弟**结点属性、**本身**属性 的**继承属性**（但本身的属性不能形成**环路**）

         >   语法分析均为**最左推导或最左归约**，所以要求**左兄弟**

         -   属性求值方法：从左到右遍历子结点，在遍历到符号前，计算其**继承属性**，遍历结束后计算父节点**综合属性**

### 5.3 语法制导翻译方案

-   基本思想

    -    语法制导翻译方案也叫**翻译模式**，给出了使用语义规则进行计算的**顺序**

-   SDD向SDT的转换

    -   S-SDD转换为SDT：
        -   将每个语义动作都放在**产生式右部的最右端**，代表在**规约**时计算属性值
        -   如果S-SDD的**基本文法**可以使用LR分析技术，那它的SDT就可以在LR分析过程中实现
    -   L-SDD转换为SDT：
        -   计算产生式左部符号**综合属性**的语义动作放在**产生式右部的最右端**
        -   计算产生式右部非终结符**继承属性**的语义动作插入**非终结符紧邻左边**

-   S-SDD的自底向上翻译

    -   扩展LR语法**分析栈**：在分析栈中附加一个域存储**综合属性**（值或指针），与文法符号平行（语义栈）
    -   分析栈的工作：在**规约**时执行语义动作，找到栈中对应位置的依赖，计算属性值，存入附加域

-   S-SDD的预测分析翻译

    -   文法改造

        -   消除左递归

            -   先消除左递归，再添加语义规则

            -   先添加语义规则，再消除左递归，并**添加新的语义规则**

                >   这就需要引入**继承属性**并插入**语义动作**，传递信息

    -   其他部分与L-SDD的翻译一致

-   L-SDD的预测分析翻译

    -   文法改造

    -   扩展预测分析栈

        -   继承属性在即将出现时计算，存放在**与非终结符平行的记录`A`**中（横向扩展、语义栈）
        -   综合属性在子结点分析完后计算，**新增一条综合记录`Asyn`**存放（纵向扩展）
        -   增加一种**动作记录`action`**，指向要执行的动作（纵向扩展）

    -   分析栈的工作

        -   依然按照右部**从右向左**的顺序入栈，**综合记录`syn`先**于本身记录入栈，动作记录`action`同样按照所处位置入栈

            >   往往会给语义动作对应的动作记录取一个简洁的**别名**

        -   栈内元素的出栈行为：

            -   栈顶为**动作记录**时，直接出栈并执行对应动作；

            -   栈顶为**综合记录**时，直接出栈并将**综合属性值传递**给栈内的特定语义动作；

            -   **变量本身记录**出栈时，若有继承属性，则要将**继承属性值传递**给入栈的特定语义动作；

            -   **终结符**出栈时要将**综合属性值**传递给栈中的特定语义动作

                >   这里的“传递”具体到程序上就是`stack[top+-n].xxx=stack[top].xxx, top=top+-n`，其中`top+-n`对应了语义动作出现的位置

        -   **综合属性**的计算：综合属性在对应产生式右部**最右端语义动作出栈**时计算

        -   **继承属性**的计算：变量本身记录的继承属性在对应产生式**紧邻左边动作出栈**时计算

            >   这里的“计算”具体到程序上，也是给`stk[top+-n]`赋值，涉及到一些计算，其中`top+-n`对应了综合记录或变量本身记录出现的位置

-   L-SDD的递归下降分析翻译

    -   文法改造

    -   在**递归下降分析**基础上，将非终结符的过程扩展为**函数**，参数为左部的**继承属性**，返回值为左部的**综合属性**

        >   递归的预测分析中过程调用的框架在这里要沿用

    -   对右部符号的每个属性都设置**局部变量**

        >   函数返回值由综合属性的局部变量接收

    -   将每个**语义动作**的代码依次加入函数体，使用对应的变量书写其动作逻辑

        -   继承属性局部变量的计算：按照**语义动作**计算并赋值给对应局部变量

        -   综合属性局部变量的计算：调用非终结符对应的函数

            >   终结符的话直接从token中取值

-   L-SDD的自底向上翻译

    -   **修改文法**以适应自底向上

        -   用各个“**标记非终结符**”替换**内嵌**的各个**语义动作**，每个标记非终结符都对应一条空产生式

        -   标记非终结符的空产生式最右端添加新语义动作

            -   将原动作依赖的属性作为**标记非终结符的继承属性**

            -   将原动作要计算的属性作为**标记非终结符的综合属性**来计算

                >   可以证明，如果一个文法是LL的，那么标记非终结符可以插入到产生式的任何位置，并且得到的文法是LR文法

    -   分析栈的工作

        -   与S-SDD基本一致，原继承属性的计算变成了**对标记非终结符综合属性的计算**
        -   计算标记非终结符时，要结合原产生式和继承属性的实际情况确定依赖位置和计算方式

## 6 语义分析与中间代码生成

>   这一小节十分需要用具体的例子辅助理解，详见编译原理随堂笔记仓库

### 6.0 中间代码的表示形式

-   逆波兰表示

-   三地址码

    -   定义： 每条指令最多只能包含**三个地址**， 两个操作数地址和一个结果地址

    -   指令类型

        -   算术与赋值：`x := y op z`、`x[i] := y[j]`、`*x := &y`

            >   **多维数组**需要计算出**一维下标**

        -   跳转

            -   无条件跳转：`goto L`
            -   条件跳转：`if x relop y goto L`、`if x goto L`

        -   过程调用与返回

            -   指明参数：`param x`
            -   过程调用：`y = call p, n`
            -   返回：`return y`

    -   表示形式：四元式

### 6.1 声明语句的翻译

*主要任务/语义动作的主要内容：*

-   类型：通过**类型表达式**，收集**标识符类型**等属性信息
    -   类型检查
    -   辅助翻译

-   宽度和相对地址：由类型表达式计算**宽度**，从而为每个标识符分配一个**相对地址**

-   符号表：将标识符类型和相对地址等信息保存至对应**符号表**。如果是嵌套声明，还要正确构建内层与外层符号表的访问链。


---

*类型表达式(Type Expreessions)：*

-   **基本类型**是一种类型表达式，常见基本类型有：

    -    `integer real char boolean type_error void`

-   可以给类型表达式命名，**类型名**也是一种类型表达式

-   **类型构造符**作用于类型表达式可以构成新的类型表达式

    -   数组构造符`array(elem_num, type)`

        >   举例：`int[2][3]`对应于`array(2, array(3, int))`

    -   指针构造符`pointer(type)`

    -   笛卡尔乘积构造符$\times$：`T1 × T2`

    -   函数构造符$\rarr$：`T1 × T2 × ... × Tn → R`

        -   `Ti`是类型表达式，相当于参数
        -   `R`也是类型表达式，相当于返回值

    -   记录构造符`record((N1×T1), (N2×T2), ..., (Nn×Tn))`

        -   `Ni`是标识符
        -   `Ti`是类型表达式

-   类型的**结构等价**

    -    *T*(1)和*T*(2)是相同的基本类型
    -    *T*(1)和*T*(2)是将同一类型构造符应用于结构等价的类型上形成的
    -    *T*(1)是表示*T*(2)的类型名

---

*声明语句的SDT：*

-   文法符号与综合属性

    -   `P`：开始符号

    -   `D`：声明语句

    -   `T`：标识符类型

        -   `T.type`：类型表达式
        -   `T.width`：类型宽度

    -   `B`：基本类型

        -   `B.type`：基本类型
        -   `B.width`：基本类型宽度

    -   `C`：数组标志

        -   `C.type`：数组类型
        -   `C.width`：数组类型宽度

    -   `id`：标识符

        -   `id.lexeme`：构成标识符的字符序列

            >   是词法分析器提供的词法值

    -   `num`：整数的正则定义

        -   `num.val`：整数值

    -   `int`：整型

    -   `real`：实型

    -   `↑`：指针标志

-   特殊变量

    -   `offset`：下一个可用的**相对地址**，有初始值，可设为0

    -   `t`和`w`：将**类型和宽度信息**从语法分析树的B结点传递到产生式$$$$C\rarr\epsilon$$$$对应的结点
        >   这里把类型看成由**基本类型+数组标志组成**，所以这两部分之间需要传递信息。如果把类型看成**基本类型或数组类型两类**，就不需要这样传递了

-   副作用

    -   `enter(name, type, offset)`：在符号表中为标识符`name`创建记录，将`name`的类型设置为`type`，相对地址设置为`offset`

-   语法规则和语义动作(推导角度)

    -   开始：$P\rarr\{a_1\}D$

        $$
            \begin{align} &a_1:\{\\ &~~~~offset=0\\ &\} \end{align}
        $$

           >   程序形成前要将`offset`置为初始值

    -   **声明语句**的生成：

        -   $D\rarr T~id;\{a_1\}D$
            $$
            \begin{align} &a_1:\{\\ &~~~~enter(id.lexem,~T.type,~offset);\\ &~~~~offset=offset+T.width;\\ &\} \end{align}
            $$

               >   声明语句形成后在**符号表**创建记录，并后移`offset`

        -   $D\rarr\epsilon$

    -   **标识符类型**的形成：

        -   $T\rarr B\{a_1\}C\{a_2\}$

            $$
                \begin{align} &a_1:\{\\ &~~~~t=B.type;\\ &~~~~w=B.width;\\ &\}\\ &a_2:\{\\ &~~~~T.type=C.type;\\ &~~~~T.width=C.width;\\ &\} \end{align}
            $$

               >   **基本类型**形成后用`t`和`w`记录**类型和宽度**，以便向后传递；
               >
               >   **标识符类型**形成后要设置**类型表达式和宽度**

               >   另一种方案(归约角度)：
               >
               >   -   `T -> int {T.type = int, T.width = 4}`
               >
               >   -   `T -> real {T.type = real, T.width = 8}`
               >
               >   -   `T -> array[num] of T1 {T.type = array(num.val, T1.type); T.width = num.val * T1.width}`

        -   $T\rarr\uarr T_1\{a_1\}$
            $$
             \begin{align} &a_1:\{\\ &~~~~T.type=pointer(T_1.type);\\ &~~~~T.width=4;\\ &\} \end{align}
            $$

            >    形成指针后要设置其**类型和宽度**

    -   **基本类型**的形成：

        -   $B\rarr int\{a_1\}$
            $$
                \begin{align} &a_1:\{\\ &~~~~B.type=int;\\ &~~~~B.width=4;\\ &\} \end{align}
            $$

               >   形成整型后要记录其类型和宽度

        -   $B\rarr real\{a_1\}$
            $$
                \begin{align} &a_1:\{\\ &~~~~B.type=real;\\ &~~~~B.width=8;\\ &\} \end{align}
            $$

               >   形成实型后要设置其类型和宽度

    -   **数组标志**的形成：

        -   $C\rarr\epsilon\{a_1\}$

            $$
                \begin{align} &a_1:\{\\ &~~~~C.type=t;\\ &~~~~C.width=w;\\ &\} \end{align}
            $$

               >   数组标志结束后要从`t`和`w`中读取信息，以便后续**数组类型和宽度**的计算

        -   $C\rarr[num]C_1\{a_1\}$
            $$
            \begin{align} &a_1:\{\\ &~~~~C.type=array(num.val,C_1.type);\\ &~~~~C.width=num.val*C_1.width;\\ &\} \end{align}
            $$

            >   形成数组标志时要用**数组构造符**其设置类型并**计算宽度**

---

*嵌套过程声明语句的SDT：*

-   特殊变量

    -   `tbptr`：保存嵌套声明的**外层符号表**的栈
    -   `offset`：保存嵌套声明的**外层偏移量**的栈

-   副作用

    -   `maketable(previous)`：创建一个**新的符号表，访问链**指向`previous`
    -   `enter(table, name, type, offset)`：向指定符号表中添加变量记录
    -   `addwidth(table, width)`：将**符号表大小**记录在表头上
    -   `enterproc(table, name, newtable)`：在`table`中为`name`建立表项，指向`newtable`

-   语法规则和语义动作

    -   开始/程序声明：`P -> prog id (input,output) M D; S {a}`

        ```
        M: {
            t := mktable(nil);
            push(t, tbptl);
            push(0, offset);
        }
        a: {
            addwidth(top(tblptr), top(offset));
            pop(tblptr);
            pop(offset);
        }
        ```

        >   program形成前，创建根符号表；program形成后，记录宽度于表头，出栈

    -   声明语句

        -   `D -> D; D`

        -   `D -> proc id N D; S {a}`

            ```
            N: {
                t = mktbl(top(tbptr));
                push(t, tbptl);
                push(0, offset);
            }
            a: {
                t := top(tblptr);
                addwidth(t, top(offset));
                pop(tblptr);pop(offset);
                enterproc(top(tblptr), id.name, t);
            }
            ```

            >   procedure形成前，创建子符号表，指向父表；procedure形成后，记录宽度于表头，出栈，父表添加指向子表的记录

        -   `D -> id : T {a}`

            ```
            a: {
                enter(top(tbptr), id.name, T.type, top(offset));
                top(offset) += T.width
            }
            ```

---

*结构体声明语句的SDT：*

>   为记录类型单独构造一个符号表，也可以类似过程那样嵌套

-   `T -> record M D end {a}`

    ```
    M: {
        t = mktbl(nil);
        push(t, tblptr);
        push(0, offset);
    }
    a: {
        T.type = record(top(tblptr)):
        T.width = top(offset);
        pop(tblptr);
        pop(offset);
    }
    ```


### 6.2 简单赋值和运算语句的翻译

*主要任务：*

-   生成**对表达式求值**的三地址码

    >   三地址码中地址不直接参与运算，而是**存放在所指向地址的值参与运算**
    >
    >   例如下文中经常出现的`E.addr`，如果放到运算表达式中，其实代表的是存放在所指向地址的值

-   正确处理**数组元素**等复杂表达式，将多维数组形式转换成**一维下标索引**

    >   对于**数组元素**要计算其**地址索引**：
    >
    >   -   $addr(a[i_1][i_2]...[i_k])=base+i_1\times w_1+i_2\times w_2+...+i_k\times w_k $
    >   -   `a[i1, i2, i3, i4, ...]`相当于`a[w*(...(i1*n2+i2)*n3+i3)*n4+i4)...)]`

-   符号表：检查变量是否已经**声明**


---

*简单赋值和运算语句的SDT：*

-   文法符号与综合属性

    -   `S`**：开始**符号，代表一个**代码块**
        -   `S.code`：存放代码块的所有**三地址码**
    -   `E`：表达式
        -   `E.code`：存放**表达式之间赋值**的三地址码
        -   `E.addr`：表达式**值的存放地址**
    -   `id`：标识符
        -   `id.lexeme`：构成标识符的字符序列
    -   `L`：**数组元素**
        -   `L.type`：数组元素的**类型**
        -   `L.offset`：数组元素的**地址偏移量**
        -   `L.array`：数组**入口地址**，也是数组标识符在符号表中记录的地址

-   副作用

    -   `lookup(lexeme)`：查询符号表中**标识符**指向的**地址**

        -   `lookup(id.lexeme).type.elem`：（如果`id`是数组标识符）数组元素**类型**

        -   `lookup(id.lexeme).type.elem.width`：数组元素**类型的宽度**

            >   数组相关信息会提前存放至**内情向量表**中

    -   `newtemp()`：生成**临时变量**并返回其地址

        >   这里虽然叫做“临时变量”，但这个变量依然会被写进**三地址码**中，只是在逻辑上起**临时记录值**的作用。
        >
        >   临时变量对优化有利，但过多的临时变量会增加符号表负担和运行时存储空间。
        >
        >   可以基于临时变量的生存期**动态申请并释放临时变量**

    -   `gen(code)`：生成新的**三地址码**（并拼接已生成的三地址码，赋值给综合属性）

        >   ⭐️增量翻译：在语义动作中简化类似`E.code=E1.code||E2.code||gen(xxx)`的代码，直接写成`gen(xxx)`，这样代表了**生成三地址码**后自动将子结点的`code`属性与之**顺序拼接**并赋值给父节点的`code`属性

-   语法规则和语义动作（归约角度理解）

    -   文法开始/**完整赋值语句**的形成：

        -   $S\rarr id=E;\{a_1\}$
            $$
            \begin{align} &a_1:\{\\ &~~~~p=lookup(id.lexeme);\\ &~~~~if~p==nil~then~error;\\ &~~~~gen(p=E.addr);\\ &\} \end{align}
            $$

            >   形成**单一标识符**赋值语句时，检查是否已经声明，并生成**标识符赋值**的三地址码

        -   $S\rarr L=E;\{a_1\}$
            $$
            \begin{align} &a_1:\{\\ &~~~~gen(L.array[L.offset]=E.addr);\\ &\} \end{align}
            $$

            >   形成**数组元素**赋值语句时生成**元素地址索引并给其赋值**的三地址码

    -   **算术表达式**的形成

        -   $E\rarr E_1+E_2\{a_1\}$
            $$
            \begin{align} &a_1:\{\\ &~~~~E.addr=newtemp();\\ &~~~~gen(E.addr=E_1.addr+E_2.addr);\\ &\} \end{align}
            $$

            >   形成加法运算表达式时生成用**临时变量存放运算结果**的三地址码

        -   $E\rarr E_1*E_2\{a_1\}$
            $$
            \begin{align} &a_1:\{\\ &~~~~E.addr=newtemp();\\ &~~~~gen(E.addr=E_1.addr*E_2.addr);\\ &\} \end{align}
            $$

            >   形成乘法运算表达式时生成用**临时变量存放运算结果**的三地址码

        -   $E\rarr-E_1\{a_1\}$
            $$
            \begin{align} &a_1:\{\\ &~~~~E.addr=newtemp();\\ &~~~~gen(E.addr=uminus~E_1.addrr);\\ &\} \end{align}
            $$

            >   形成取相反数运算表达式时生成用**临时变量存放运算结果**的三地址码

        -   $E\rarr(E_1)\{a_1\}$
            $$
            \begin{align} &a_1:\{\\ &~~~~E.addr=E_1.addr;\\ &\} \end{align}
            $$

            >   形成括号运算表达式时传递变量地址

        -   $E\rarr id\{a_1\}$
            $$
            \begin{align} &a_1:\{\\ &~~~~E.addr=lookup(id.lexeme);\\ &~~~~if~E.addr==nil~then~error;\\ &\} \end{align}
            $$

            >   由标识符形成表达式时要检查是否**声明**并**记录标识符地址**

    -   **数组元素表达式**的形成

        -   $E\rarr L\{a_1\}$
            $$
            \begin{align} &a_1:\{\\ &~~~~E.addr=newtemp();\\ &~~~~gen(E.addr=L.array[L.offset]);\\ &\} \end{align}
            $$

            >   形成**完整数组元素表达式**时生成用**临时变量存放数组元素地址索引**的三地址码

        -   $L\rarr id[E]\{a_1\}$
            $$
            \begin{align} &a_1:\{\\ &~~~~L.array=lookup(id.lexeme);\\ &~~~~if~L.array==nil~then~error;\\ &~~~~L.type=L.array.type.elem;\\ &~~~~L.offset=newtemp();\\ &~~~~gen(L.offset=E.addr*L.type.width);\\ \} \end{align}
            $$

            >   确定数组**标识符**后，传递**数组名**、数组元素**类型**，计算数组元素**偏移量**，并生成 用类型**宽度**和表达式值计算**偏移量** 的三地址码

        -   $L\rarr L_1[E]\{a_1\}$
            $$
            \begin{align} &a_1:\{\\ &~~~~L.array=L_1.array;\\ &~~~~L.type=L_1.type.elem;\\ &~~~~t=newtemp();\\ &~~~~gen(t=E.addr*L.type.width);\\ &~~~~L.offset=newtemp();\\ &~~~~gen(L.offset=L_1.offset+t);\\ \} \end{align}
            $$

            >   更高维数组元素形成时，传递**数组名**、数组**类型**，计算数组元素偏移量，生成 借助**临时变量**计算**更深维度偏移量** 的三地址码

---

*数组元素的另一种SDT：*

-   文法符号与综合属性

    -   `L.addr`：数组**基址**
    -   `L.offset`：数组元素**偏移量**
    -   `Elist.array`： 指向符号表中**数组名表项**
    -   `Elist.ndim`： Elist中下标表达式的个数， 即**数组当前维数**
    -   `Elist.addr`： 存放下标表达式计算出来的值

-   副作用

    -   `limit(array, j)`：返回`nj`

        >   代表第`j`维的宽度，可以从数组的**内情向量表**中获取

-   语法规则和语义动作（归约的角度）

    -   `L -> id {a}`

        ```
        a: {
            L.addr = id.addr;
            L.offset = null;
        }
        ```

    -   `Elist -> id[E {a}`

        ```
        a: {
            Elist.addr = E.addr;
            Elist.ndim = 1;
            Elist.array = id.addr;
        }
        ```

        >   数组元素刚开始形成时，记录**下标值、维度、标识符**

    -   `Elist -> Elist1, E {a}`

        ```
        a: {
            t = newtmp;
            m = Elist1.ndim + 1;
            gencode(t = Elist1.addr * limit(Elist1.array, m));
            gencode(t = t + E.addr);
            Elist.array = Elist1.array;
            Elist.addr = t;
            Elist.ndim = m;
        }
        ```

        >   生成临时变量计算**深一维度的偏移量**，传递**下标值**、**维度**、**标识符**
        >
        >   `a[i1, i2, i3, i4, ...]`
        >
        >   `a[w*(...(i1*n2+i2)*n3+i3)*n4+i4)...)]`

    -   `L -> Elist] {a}`

        ```
        a: {
            L.addr = newtmp;
            L.offset = newtmp;
            gencode(L.addr = base(Elist.array)-invariant(Elist.array));
            gencode(L.offset = Elist.addr * w)
        }
        ```

        >   数组元素标志形成结束后，计算最终的**数组基址**和**偏移量**

### 6.3 布尔表达式的翻译

*主要任务：*

-   对布尔表达式进行求值（数值表示法）

-   处理布尔表达式在不同逻辑值下的**跳转**（真假出口表示法）

---

*布尔表达式的SDT：*

-   文法符号与属性

    -   `B`：布尔表达式
        -   `B.true`：布尔表达式的“真”出口，也就是表达式为真时，下一条要执行的语句
        -   `B.false`：布尔表达式的“假”出口，也就是表达式为假时，下一条要执行的语句
        -   `B.code`：布尔表达式翻译出的三地址码
        -   `B.addr`：布尔表达式的值
    -   `E`：表达式
        -   与**赋值语句**中的一致
    -   `relop`：关系运算符的正则定义，包括`<, <=, >, >=, ==, !=`
    -   `or、and、not`
    -   优先级：`not > and > or`
    -   在语法规则中，可以通过人为地限制**使用产生式归约的条件**来实现不同的优先级
    -   `true、false`

-   副作用

    -   `newlabel()`
    -   `label(L)`
    -   `gen(code)`
    -   `nextquad`：下一条三地址指令的序号

-   语法规则和语义动作（数值表示法、从归约的角度理解）

    -   `B -> E1 relop E2`

        ```
        a : {
            gen(if E1.addr relop E2.addr goto nextquad+3);
            gen(B.addr = 0);
            gen(goto nextquad+2);
            gen(B.addr = 1);
        }
        ```

    -   `B -> true`

        ```
        a : {
            B.addr = newtmp;
            gen(B.addr = 1);
        }
        ```

    -   `B -> false`

        ```
        a : {
            B.addr = newtmp;
            gen(B.addr = 0);
        }
        ```

    -   `B -> B1 or B2`

        ```
        a : {
            B.addr = newtmp;
            gen(B.addr = B1.addr or B2.addr);
        }
        ```

    -   `B -> B1 and B2`

        ```
        a : {
            B.addr = newtmp;
            gen(B.addr = B1.addr and B2.addr);
        }
        ```

    -   `B -> not B1`

        ```
        a : {
            B.addr = newtmp;
            gen(B.addr = not B1.addr);
        }
        ```

    -   `B -> (B1)`

        ```
        a : {
            B.addr = B1.addr;
        }
        ```

-   语法规则和语义动作（真假出口表示法、从推导的角度理解）

    -   由**关系运算符**形成布尔表达式

        -   $B\rarr E_1~relop~E_2\{a_1\}$
            $$
            \begin{align} &a_1:\{\\ &~~~~gen(if~E_1.addr~relop~E_2.addr~goto~B.ture);\\ &~~~~gen(goto~B.false);\\ &\}\\ \end{align}
            $$

            >   生成关系运算符的**跳转**三地址码

    -   由**逻辑值**形成布尔表达式

        -   $B\rarr true\{a_1\}$

            $$
            \begin{align} &a_1:\{\\ &~~~~gen(goto~B.true);\\ &\}\\ \end{align}
            $$

            >   直接生成跳转到**真出口**的三地址码
            >
            >   这里所说的“**出口**”指的就是要跳转到的**指令标号**

        -   $B\rarr false\{a_1\}$

            $$
            \begin{align} &a_1:\{\\ &~~~~gen(goto~B.false);\\ &\}\\ \end{align}
            $$

            >   直接生成跳转到**假出口**的三地址码

    -   通过**逻辑运算符**连接布尔表达式

        -   $B\rarr(\{a_1\}B_1)$

            $$
            \begin{align} &a_1:\{\\ &~~~~B_1.true=B.true;\\ &~~~~B_1.false=B.false;\\ &\}\\ \end{align}
            $$

            >   计算继承属性，让其**真、假出口**与父表达式保持相等

        -   $B\rarr not\{a_1\}B_1$

            $$
            \begin{align} &a_1:\{\\ &~~~~B_1.true=B.false;\\ &~~~~B_1.false=B.true;\\ &\}\\ \end{align}
            $$

            >   让其**真、假出口**与父表达式保持相反

        -   $B\rarr\{a_1\}B_1~or~\{a_2\}B_2$

            $$
            \begin{align} &a_1:\{\\ &~~~~B_1.false=newlabel();\\ &~~~~B_1.true=B.true;\\ &\}\\ &a_2:\{\\ &~~~~label(B_1.false);\\ &~~~~B_2.true=B.true;\\ &~~~~B_2.false=B.false;\\ &\}\\ \end{align}
            $$

            >   计算B1继承属性时，真出口可以确定是父B的真出口，但假出口的代码是B2，还没生成，所以newlabel
            >
            >   计算B2继承属性时，马上要生成B2的代码了，所以B1的假出口可以确定了，B2的真假出口也可以由父B确定

        -   $B\rarr\{a_1\}B_1~and~\{a_2\}B_2$

            $$
            \begin{align} &a_1:\{\\ &~~~~B_1.true=newlabel();\\ &~~~~B_1.false=B.false;\\ &\}\\ &a_2:\{\\ &~~~~label(B_1.true);\\ &~~~~B_2.true=B.true;\\ &~~~~B_2.false=B.false;\\ &\}\\ \end{align}
            $$

            >   与`or`类似

-   语法规则和语义动作（真假出口表示法、仅为L-SDD）

    -   `B -> E1 relop E2`

        ```
        a : {
            B.code = gen(if E1.addr relop E2.addr goto B.ture)
                ||gen(goto B.false);
        }
        ```

    -   `B -> true`

        ```
        a : {
            B.code = gen(goto B.true);
        }
        ```

    -   `B -> false`

        ```
        a : {
            B.code = gen(goto B.false);
        }
        ```

    -   `B -> B1 or B2`

        ```
        a : {
            B1.true = B.true;
            B1.false = newlabel;
            B2.true = B.true;
            B2.false = B.false;
            B.code = B1.code||gen(B1.false:)||B2.code
        }
        ```

    -   `B -> B1 and B2`

        ```
        a : {
            B1.true = newlabel;
            B1.false = B.false;
            B2.true = B.true;
            B2.false = B.false;
            B.code = B1.code||gen(B1.true:)||B2.code
        }
        ```

    -   `B -> not B1`

        ```
        a : {
            B1.true = B.flase;
            B1.false = B.true;
            B.code = B1.code
        }
        ```

    -   `B -> (B1)`

        ```
        a : {
            B1.true = B.true;
            B1.false = B.false;
            B.code = B1.code
        }
        ```


### 6.4 控制流语句的翻译

*主要任务：*

-   结合布尔表达式的翻译，生成具有**控制流结构**的三地址码

-   正确处理**指令标号**的记录和**跳转**三地址码的生成

---

*控制流语句的代码结构：*

-   跳转的逻辑结构很简单，重点是在合适的地方插入`goto`语句

    >   详见编译原理随堂笔记仓库

---

*控制流语句的SDT：*

-   文法符号与属性

    -   `P`：开始符号

    -   `S`：控制流代码块

        -   `S.code`：综合属性，存放完整的三地址码

        -   `S.next`：继承属性，是一个地址，地址中存放了紧跟在`S.code`之后的指令标号，即`S`**后继指令的标号**

            -   >   **指令标号**可以标识一条**三地址指令**

        -   `S.first`：继承属性，是一个地址，地址中存放了在`S.code`的**第一条指令的标号**

    -   `B`：布尔表达式

        -   `B.ture`：继承属性，是一个地址，地址中存放了当`B`为真时控制流转向的指令标号
        -   `B.false`：继承属性，是一个地址，地址中存放了当`B`为假时控制流转向的指令标号

    -   `E`：表达式

        -   >   与赋值语句中的一致

    -   `L`：数组元素

        -   >   与赋值语句中的一致

-   副作用

    -   `newlabel()`：生成一个用于**存放标号**的临时变量，返回其**地址**
    -   `label(L)`：将**下一条**三地址指令的**标号**赋值给`L`（指向的地址）
    -   `gen(code)`

-   语法规则和语义动作（真假出口表示法、从推导的角度理解）

    -   文法开始/完整控流代码块形成：

        -   $P\rarr\{a_1\}S\{a_2\}$

            $$
            \begin{align} &a_1:\{\\ &~~~~S.next=newlabel();\\ &\}\\ &a_2:\{\\ &~~~~label(S.next);\\ &\} \end{align}
            $$

            >   形成代码块前，先生成存放其后继指令的**地址空间**（因为这是继承属性，规定要这么算，而且**代码块内**可能会用到）；
            >
            >   形成代码块后，将**下一条**三地址指令标号赋值给其**后继指令**

        -   $S\rarr\{a_1\}S_1\{a_2\}S_2$

            $$
            \begin{align} &a_1:\{\\ &~~~~S_1.next=newlabel();\\ &\}\\ &a_2:\{\\ &~~~~label(S_1.next);\\ &~~~~S_2.next=S.next\\ &\} \end{align}
            $$

            >   next继承属性肯定是要在符号出现前计算的，能用父S确定的就直接给父S的next，确定不了的（相应代码结构还没出现）就newlabel

    -   **完整赋值语句**的形成：$S\rarr id=E;\{a\}|L=E;\{a\}$

        >   上一小节已经讲过，这里省略

    -   控制流结构的形成

        -   $S\rarr if~\{a_1\}B~then~\{a_2\}S_1$

            $$
            \begin{align} &a_1:\{\\ &~~~~B.true=newlabel();\\ &~~~~B.false=S.next;\\ &\}\\ &a_2:\{\\ &~~~~label(B.ture);\\ &~~~~S_1.next=S.next;\\ &\} \end{align}
            $$

            >   形成布尔表达式前计算继承属性，false能用父S确定的，true还没生成，所以要等到S1之前用label赋值，然后S1的next继承属性用父S确定即可

        -   $S\rarr if~\{a_1\}B~then~\{a_2\}S_1~\{a_3\}else~\{a_4\}S_2$
            $$
            \begin{align} &a_1:\{\\ &~~~~B.true=newlabel();\\ &~~~~B.false=newlabel();\\ &\}\\ &a_2:\{\\ &~~~~label(B.ture);\\ &~~~~S_1.next=S.next;\\ &\}\\ &a_3:\{\\ &~~~~gen(goto~S.next);\\ &\}\\ &a_4:\{\\ &~~~~label(B.false);\\ &~~~~S_2.next=S.next;\\ &\} \end{align}
            $$
    
            >   与`if-then`类似，要么能用父S.next确定，要么还没生成，先newlabel，到对应的位置再label；必须要注意的是，记得**生成S1之后的goto**
    
        -   $S\rarr while~\{a_1\}B~do~\{a_2\}S_1\{a_3\}$
    
        $$
            \begin{align} &a_1:\{\\ &~~~~S.begin=newlabel();\\ &~~~~label(S.begin);\\ &~~~~B.true=newlabel();\\ &~~~~B.false=S.next;\\ &\}\\ &a_2:\{\\ &~~~~label(B.true);\\ &~~~~S_1.next=S.begin;\\ &\}\\ &a_3:\{\\ &~~~~gen(goto~S.begin);\\ &\}\\ \end{align}
        $$
    
        >   与前面`if`的类似，这里单独注意一下`S.begin`和`goto`，因为`while`的特点就是会跳回前面
    
-   语法规则和语义动作（真假出口表示法、仅为L-SDD）

    -   `S -> if B then S1`

        ```
        a: {
            B.true = newtmp;
            B.false = S.next;
            S1.next = S.next;
            S.code = B.code||gen(B.true:)||S1.code
        }
        ```

    -   `S -> if B then S1 else S2`

        ```
        a: {
            B.true = newtmp;
            B.false = newtmp;
            S1.next = S.next;
            S2.next = S.next;
            S.code = B.code||gen(B.true:)||S1.code
                ||gen(goto S.next)
                ||gen(B.false:)||S2.code
        }
        ```

    -   `S -> while B do S1`

        ```
        a: {
            S.begin = newtmp;
            B.true = newtmp;
            B.false = S.next;
            S1.next = S.begin;
            S.code = gen(S.begin:)||B.code
                ||gen(B.true:)||S1.code
                ||gen(goto S.begin)
        }
        ```

    -   `S -> S1; S2`

        ```
        a: {
            S1.next = newtmp;
            S2.next = S.next;
            S.code = S1.code||gen(S1.next)||S2.code
        }
        ```

*`switch-case`语句的翻译：*

-   `switch-case`的直观翻译方式：
    $$
    switch~E\{a_1\}\\ case~V_1:\{a_2\}S_1\{a_3\}\\ case~V_2:\{a_4\}S_2\{a_5\}\\ ...\\ case~V_{n-1}:\{a_{2n-2}\}S_{n-1}\{a_{2n-1}\}\\ default~:\{a_{2n}\}S_n\{a_{2n+1}\}
    $$

    -    新增特殊变量

         -   `Vk`：第`k`个分支的**入口值**
         -   `Lk`：存放第`k+1`个分支**第一条指令标号**的地址空间
         -   `t`：存放分支依据**表达式的值**
         -   `next`：存放整体代码块**下一条指令标号**的地址空间

         $$
         \begin{align} &a_1:\{\\ &~~~~t=newtemp();\\ &~~~~gen(t=E.addr);\\ &~~~~next=newlabel();\\ &\}\\ &a_{2k-2}:\{\\ &~~~~label(L_{k-1});\\ &~~~~L_k=newlabel();\\ &~~~~gen(if~t~!=V_k~goto~L_k);\\ &\}\\ &a_{2k-1}:\{\\ &~~~~gen(goto~next);\\ &\}\\ &a_{2n}:\{\\ &~~~~label(L_{n-1});\\ &\}\\ &a_{2n+1}:\{\\ &~~~~label(next);\\ &\}\\ \end{align}
         $$

    -    `switch-case`语句开始分支测试前，生成将依据**表达式值**保存至临时变量的三地址码，并为存放**整体代码块下一条指令的标号**开辟内存空间

         >   那个`next=newlabel()`放在第一次使用`next`前也可以

    -    每个测试分支中，形成代码块前，先给该**分支对应标号赋值**，再生成**不满足条件跳转**至下一个分支标号的三地址码；形成代码块后，生成跳转至整体代码块下一条指令的三地址码

         >   第一个测试分支不需要给自己的标号赋值，只需要生成不满足条件的跳转三地址码

    -    默认分支中，形成代码块前，给该**分支对应标号赋值**；形成代码块后，给**整体代码块下一条指令对应**的标号赋值

-   `switch-case`的**分支测试代码集中**翻译方式：
    $$
    switch~E\{a_1\}\\ case~V_1:\{a_2\}S_1\{a_3\}\\ case~V_2:\{a_4\}S_2\{a_5\}\\ ...\\ case~V_{n-1}:\{a_{2n-2}\}S_{n-1}\{a_{2n-1}\}\\ default~:\{a_{2n}\}S_n\{a_{2n+1}\}
    $$

    -    新增特殊变量

         -   `test`：分支集中测试块的第一条指令标号地址

    -    新增副作用

         -   `map`：记录分支测试**入口值**与分支测试**标号**的映射关系，方便批量生成**分支测试代码**

         $$
         \begin{align} &a_1:\{\\ &~~~~t=newtemp();\\ &~~~~gen(t=E.addr);\\ &~~~~test=newlabel();\\ &~~~~gen(goto~test);\\ &~~~~next=newlabel();\\ &\}\\ &a_{2k-2}:\{\\ &~~~~L_k=newlabel();\\ &~~~~label(L_{k});\\ &~~~~map(V_k,L_k);\\ &\}\\ &a_{2k-1}:\{\\ &~~~~gen(goto~next);\\ &\}\\ &a_{2n}:\{\\ &~~~~L_n=newlabel();\\ &~~~~label(L_{n});\\ &\}\\ &a_{2n+1}:\{\\ &~~~~gen(goto~next);\\ &~~~~label(test);\\ &~~~~gen(if~t=V_k~goto~L_k);\\ &\}\\ \end{align}
         $$

    -    `switch-case`语句开始分支测试前，生成将依据**表达式值**保存至临时变量的三地址码，生成**跳转至集中分支测试**的三地址码，并为存放**整体代码块下一条指令的标号**开辟内存空间

    -    每个测试分支中，形成代码块前，开辟该分支对应的标号，并给**标号赋值**为下一条指令，再将该分支测试**入口值**与**标号**的添加至映射表；形成代码块后，生成跳转至整体代码块下一条指令的三地址码

    -    默认分支中，形成代码块前，开辟该分支对应的标号，并给**标号赋值**为下一条指令；形成代码块后，生成跳转至整体代码块下一条指令的三地址码，再给**集中分支测试的标号**赋值，然后根据**映射表**批量生成分支**入口值对比并跳转至对应标号**的三地址码

         >   可以增加一种`case`指令，`case t V L`等同于`if t==V goto L`，但`case`指令更容易被最终的代码生成器**探测**到，从而对这些指令进行**特殊处理**

---

*`for-to-step-do`语句的翻译：*

-   再说 吧

---

*`repeat-until`语句的翻译：*

-   再说 吧

### 6.5 过程调用语句的翻译

*主要任务：*

-   解析过程调用的参数，生成**设置实参和调用过程**的三地址码

---

*过程调用语句的代码结构：*

-   语句模式：`id(E1, E2, ..., En)`

-   代码流程

    -   运算各表达式的三地址码，计算参数值：

        ```
        id(
        	E1.code,
        	E2.code,
        	...
        	En.code
        )
        ```

    -   通过`param`指令将各表达式的值作为函数的实参：

        ```
        param E1.addr
        param E2.addr
        ...
        param En.addr
        ```

        >   这种是`param`指令集中的形式。也可以让`param Ek.addr`指令紧跟在`Ek.code`后面，就是分散形式。
        >
        >   分散形式下，需要使用一种数据结构（通常是队列`q`）来存放`Ek.addr`，以便集中生成`param`指令

    -   调用函数：`call id.addr n`

        >   `n`代表参数个数

---

*过程调用语句的SDT：*

-   文法符号与属性

    -   `S`：文法开始符号/过程调用代码结构
    -   `Elist`：参数列表
    -   `E`：参数表达式
        -   `E.addr`：表达式**值的存放地址**

-   副作用

    -   `gen(code)`

-   语法规则和语义动作

    -   文法开始/形成**过程调用**框架：$S\rarr call~id(Elist)\{a_1\}$
        $$
        \begin{align} &a_1:\{\\ &~~~~n=0;\\ &~~~~for~q中的每个t~do\\ &~~~~~~~~gen(param~t);\\ &~~~~~~~~n=n+1;\\ &~~~~gen(call~id.addr,n);\\ &\}\\ \end{align}
        $$

        >   过程调用框架形成后，根据队列`q`集中生成所有**设置实参**的`param`三地址指令，最后再生成一条**过程调用**的三地址指令

    -   形成**参数列表**

        -   $Elist\rarr E\{a_1\}$
            $$
            \begin{align} &a_1:\{\\ &~~~~将q初始化为只包含E.addr的队列;\\ &\}\\ \end{align}
            $$

            >   参数列表开始形成时初始化队列`q`

        -   $Elist\rarr Elist_1,E\{a_1\}$
            $$
            \begin{align} &a_1:\{\\ &~~~~将E.addr添加到q的队尾;\\ &\}\\ \end{align}
            $$

            >   参数列表中每增加一个参数就添加一个参数地址至队列`q`中

### 6.6 回填

*基本思想：*

-   生成**跳转**三地址码时，暂不指定跳转的**目标标号**，并将这样的指令放入**列表**中，同一个列表中所有跳转指令的**目标相同**，待能确定目标时，再**填充**列表中指令的目标标号

-   待填充跳转指令组成的**列表**会通过文法符号**综合属性**进行传递，不再需要使用`next true false`这类**继承属性**了，更符合**归约**的思想

>   如果不使用回填，可以两遍扫描，先把**语法分析树**建好，再遍历树，确定标号。但这样效率较低

---

*布尔表达式的回填：*

-   有改动或新增的文法符号及其综合属性

    -   `B`：布尔表达式
        -   `B.truelist`：指向包含待填充跳转指令的**列表**，列表中的跳转指令**目标均为`B`的真出口**
        -   `B.falselist`：指向包含待填充跳转指令的**列表**，列表中的跳转指令**目标均为`B`的假出口**
    -   `M`：辅助记录的符号
        -   `M.quad`：会将下一条指令的标号暂存至该综合属性，之后会用到

-   新增的特殊变量

    -   `nextquad`：即将生成的下一条三地址码的标号

-   新增的副作用

    -   `makelist(i)`：创建一个只包含跳转指令`i`的列表，返回列表**指针**

    -   >   这里的`i`是这条跳转指令本身的标号，不是目标标号

    -   `merge(p1, p2)`：将`p1`和`p2`指向的两个列表合并，返回合并后列表**指针**

    -   `backpatch(p, i)`：将`i`作为**目标标号**填充`p`指向的列表中的所有**跳转指令**

-   有改动的语法规则和语义动作

    -   由**关系运算符**形成布尔表达式：$B\rarr E_1~relop~E_2\{a_1\}$

        $$
        \begin{align} &a_1:\{\\ &~~~~B.truelist=makelist(nextquad);\\ &~~~~B.falselist=makelist(nextquad+1);\\ &~~~~gen(if~E_1.addr~relop~E_2.addr~goto~\_);\\ &~~~~gen(goto~\_);\\ &\}\\ \end{align}
        $$

        >   先设置待**填充跳转指令列表**，把**即将生成的两条指令**分别加入真假出口对应的两个列表，再生成关系运算符的**待填充跳转三地址码**

    -   由**逻辑值**形成布尔表达式

        -   $B\rarr true\{a_1\}$
            $$
            \begin{align} &a_1:\{\\ &~~~~B.truelist=makelist(nextquad);\\ &~~~~gen(goto~\_);\\ &\}\\ \end{align}
            $$

            >   先设置待**填充跳转指令列表**，把**即将生成的指令**加入真出口对应的列表，再生成**待填充的跳转三地址码**

        -   $B\rarr false\{a_1\}$
            $$
            \begin{align} &a_1:\{\\ &~~~~B.falselist=makelist(nextquad);\\ &~~~~gen(goto~\_);\\ &\}\\ \end{align}
            $$

            >   先设置待**填充跳转指令列表**，把**即将生成的指令**加入假出口对应的列表，再生成**待填充的跳转三地址码**

    -   通过**逻辑运算符**连接布尔表达式

        -   $B\rarr(B_1)\{a_1\}$
            $$
            \begin{align} &a_1:\{\\ &~~~~B_1.truelist=B.truelist;\\ &~~~~B_1.falselist=B.falselist;\\ &\}\\ \end{align}
            $$

            >   子表达式形成后，让其**真、假出口列表**与父表达式保持相等

        -   $B\rarr not~B_1\{a_1\}$
            $$
            \begin{align} &a_1:\{\\ &~~~~B_1.truelist=B.falselist;\\ &~~~~B_1.falselist=B.truelist;\\ &\}\\ \end{align}
            $$

            >   相反子表达式形成后，让其**真、假出口列表**与父表达式保持相反

        -   $B\rarr B_1~or~M~B_2\{a_1\}$

            $M\rarr\epsilon\{a_2\}$
            $$
            \begin{align} &a_1:\{\\ &~~~~backpatch(B_1.falselist,M.quad);\\ &~~~~B.truelist=merge(B_1.truelist,B_2.truelist);\\ &~~~~B.falselist=B_2.falselist;\\ &\}\\ &a_2:\{\\ &~~~~M.quad=nextquad;\\ &\}\\ \end{align}
            $$

            >   子表达式形成并连接后：
            >
            >   -   处理不短路的跳转位置：用记录下的第二个布尔表达式的**第一条指令标号**回填第一个子表达式的**假出口列表**
            >
            >   -   处理B的出口列表
            >       -   真出口合并：将两个子表达式的**真出口列表合并**至父表达式的真出口列表
            >       -   假出口：将第二个子表达式的**假出口列表**赋值给父表达式的假出口列表
            >
            >   父表达式的真假出口列表待**控制流语句**形成后回填

        -   $B\rarr B_1~and~M~B_2\{a_1\}$

            $M\rarr\epsilon\{a_2\}$

            $$
            \begin{align} &a_1:\{\\ &~~~~backpatch(B_1.truelist,M.quad);\\ &~~~~B.falselist=merge(B_1.falselist,B_2.falselist);\\ &~~~~B.truelist=B_2.truelist;\\ &\}\\ &a_2:\{\\ &~~~~M.quad=nextquad;\\ &\}\\ \end{align}
            $$

            >   子表达式形成并连接后：
            >
            >   -   处理不短路的跳转位置：用记录下的第二个布尔表达式的**第一条指令标号**回填第一个子表达式的**真出口列表**
            >   -   处理B的出口列表
            >       -   假出口合并：将两个子表达式的**假出口列表合并**至父表达式的真出口列表
            >       -   真出口：将第二个子表达式的**真出口列表**赋值给父表达式的假出口列表
            >
            >   父表达式的真假出口列表待**控制流语句**形成后回填

---

*控制流语句的回填：*

-   有改动或新增的文法符号及其综合属性

    -   `S`：控制流代码块
        -   `S.nextlist`：指向包含待填充跳转指令的**列表**，列表中的跳转指令**目标均为`S`的下一条指令**
    -   `M`：辅助记录的符号
        -   `M.quad`：会将下一条指令的标号暂存至该综合属性，之后会用到
    -   `N`：辅助记录的符号
        -   `N.nextlist`：会将包含**下一条跳转指令**的列表指针标号暂存至该综合属性，之后会用到

-   新增的特殊变量

    -   `nextquad`

-   新增的副作用

    -   `makelist(i)`
    -   `merge(p1, p2)`
    -   `backpatch(p, i)`

-   有改动的语法规则和语义动作

    -   文法开始/完整控流代码块形成：

        -   $P\rarr S\{a_1\}$

            $$
            \begin{align} &a_1:\{\\ &~~~~backpatch(S.nextlist,nextquad);\\ &\}\\ \end{align}
            $$

            >   形成代码块后，用**下一条**三地址指令标号回填整体代码块的**后继列表**；
            >
            >   这条回填产生式是我自己猜的，我希望是对的

        -   $S\rarr S_1~M~S_2\{a_1\}$

            $$
            \begin{align} &a_1:\{\\ &~~~~backpatch(S_1.nextlist, M.quad)\\ &~~~~S.nextlist=S_2.nextlist\\ &\}\\ \end{align}
            $$

        >   两个代码块拼接完成后，先用记录下的第二个代码块的**第一条指令标号**回填第一个代码块的**后继列表**，再将第二个代码块的后继列表赋值给整体代码块的后继列表

    -   **完整赋值语句**的形成：$S\rarr id=E;\{a\}|L=E;\{a\}$
        $$
        \begin{align} &a:\{\\ &~~~~S.nextlist=null;\\ &\}\\ \end{align}
        $$

        >   完整赋值语句形成后，直接让代码块**后继列表为空**即可；
        >
        >   因为赋值语句只是顺序执行，不需要特殊的跳转

    -   控制流结构的形成

        -   $S\rarr if~B~then~M~S_1\{a_1\}$

            $$
            \begin{align} &a_1:\{\\ &~~~~backpatch(B.truelist, M.quad);\\ &~~~~S.nextlist=merge(B.falselist,S_1.nextlist);\\ &\}\\ \end{align}
            $$

            >   单分支控制流形成后：
            >
            >   -   真出口：回填子代码块**第一条指令**
            >
            >   -   假出口：与子代码块的`nextlist`合并，给到父代码块。因为`S.next`完全没出现在这条产生式中

        -   $S\rarr if~B~then~M_1~S_1~N~else~M_2~S_2\{a_1\}$

            $N\rarr\epsilon\{a_3\}$
            $$
            \begin{align} &a_1:\{\\ &~~~~backpatch(B.truelist,M1.quad);\\ &~~~~backpatch(B.falselist,M2.quad);\\ &~~~~S.nextlist=merge(merge(S_1.nextlist,N.nextlist),S_2.nextlist);\\ &\}\\ &a_3:\{\\ &~~~~N.nextlist=makelist(nextquad);\\ &~~~~gen(goto~\_);\\ &\}\\ \end{align}
            $$

            >   双分支控制流形成后：
            >
            >   -   真出口：回填第一个子代码块**第一条指令**
            >
            >   -   假出口：回填第二个子代码块**第一条指令**
            >
            >   -   中途跳转出口：与两个**子代码块**的`nextlist`合并然后给到父代码块

        -   $S\rarr while~M_1~B~do~M_2~S_1\{a_1\}$

            $$
            \begin{align} &a_1:\{\\ &~~~~backpatch(S_1.nextlist,M_1.quad);\\ &~~~~backpatch(B.truelist,M_2.quad);\\ &~~~~S.nextlist=B.falselist;\\ &~~~~gen(goto~M_1.quad);\\ &\}\\ \end{align}
            $$

            >   循环控制流形成后：
            >
            >   -   真出口：回填子代码块**第一条指令**
            >
            >   -   假出口：产生式中没出现，给到父代码块，待之后回填
            >
            >   -   子代码块`nextlist`：回填布尔代码块**第一条指令**
            >
            >   -   中途跳转：跳回布尔表达式

## 7 运行存储分配

### 7.1 运行存储分配概述

*运行存储分配策略：*

-   编译器要为源程序中出现的一些**数据对象**分配**运行时的存储空间**

-   静态存储分配策略：对于在编译时可以确定大小的**数据对象**，可以在**编译时**就静态地分配存储空间

    >   **静态**指的是**编译时、空间上**

-   动态存储分配策略：对于不能在编译时完全确定大小的**数据对象**，仅在编译时产生必要信息，而在**运行时**动态地分配存储空间

    >   **动态**指的是**运行时、时间上**

    -   栈式存储分配
    -   堆式存储分配

---

*名字与变量：*

-   概念问题：
    -   名字：编译时的名字
    -   变量/左值：运行时的内存位置
    -   标识符：名字的一种，指示数据对象的入口
    -   右值：运行时某一时刻变量的值

-   名字到值的映射
    -   `名字 --环境--> 左值/变量 --状态--> 值/右值`
    -   绑定：**环境**将**名字**绑定到**左值/变量**上

---

*作用域：*

-   静态作用域

    -   定义：编译时即可确定声明的作用域，即**编译**时就可以确定每个变量**来自于哪个声明**

    -   寻找变量规则：

        -   声明语句在一个程序块内，则作用域就是这个**程序块**

        -   如果允许嵌套，那么在寻找变量时首先找本层，然后找**最近的外层**，即**最近作用域规则**

            >   **空间**上最近

-   动态作用域

    -   定义：不是静态作用域，即有些变量只能在**运行时**确定其**来自于哪个声明**

    -   寻找变量规则：找到最近被调用的过程中的声明

        >   **时间**上最近

---

*内存划分与过程活动：*

-   运行时内存划分：
    -   **静态代码**区
    -   **静态数据**区
    -   **动态数据**区域
        -   **栈区**
        -   空闲内存
        -   堆区

-   活动记录：
    -   概念：
        -   活动(activation)：过程体的**每次执行**称为该过程的一个活动
        
        -   活动记录(activation record)：编译器以**过程**为单位、为**活动**分配的、用来管理**一次执行所需信息**的连续**存储空间**
        
            >   活动记录的体积在编译时是可以确定的
        
    -   一般形式/构成
        -   实参
        -   返回值
        -   控制链/动态链：指向**调用者**的活动记录
        -   访问链/静态链：用于访问**非局部数据**
        -   保存的**机器状态**/机器状态字段：各种**寄存器**值和其他**状态信息**
        -   局部数据
        -   临时变量：中间代码生成时需要的临时变量
    
-   参数传递方式
    -   传值：新开变量，传右值
    -   传地址：如果实参是左值，则传左值；如果实参不是左值，则创建**临时变量**充当左值，设置其右值，然后传左值
    -   传值结果：同时传左值和右值，在主体中**只使用右值**，在**结束**前修改**左值状态**
    -   传名：过程体中用到形参的地方直接替换成一模一样的实参左值（包括运算符）

### 7.2 静态存储分配

>   静态数据和静态代码无疑是静态存储分配的，所以该小节主要讲**活动记录的静态存储分配**

*静态存储分配的规则与条件：*

-   规则：

    -   **编译器**为每个**活动记录**直接指定**存储位置**
    -   因此，过程中**标识符的存储位置**可以确定，每次都绑定到同样的存储单元，可以将这些地址编译到目标代码中

-   条件：

    -   **数组上下界**必须是常数

    -   不允许**递归调用**

    -   不允许**动态建立**数据实体

        >   满足这些条件的语言有BASIC、FORTRAN等

---

*顺序分配法：*

-   特点：
    -   按照过程出现的先后顺序**逐段分配**存储空间
    -   各过程的活动记录占用**互不相交**的存储空间

-   优点：处理简单

-   缺点：对内存空间的使用不够经济合理


---

*层次分配法：*

-   层次分配的特点：

    -   构建**过程调用图**，确保图中不出现**环**
    -   无相互调用关系的**并列过程**尽量使其局部数据**共享存储空间**

-   层次分配的算法：

    -   依据过程调用图，**从下至上**分配

    -   **同层**可以互相“**覆盖**”

    -   **上层**从子过程的**最高地址**开始分配

        >   代码实现的算法详见编译原理笔记仓库

### 7.3 栈式存储分配与调用返回序列

*栈式存储分配与活动树：*

-   栈式存储分配的概念：

    -   将过程的**活动记录**以**栈**的形式进行管理
    -   当过程被**调用**时，活动记录**入栈**；当过程**结束**时，活动记录**出栈**

-   栈式存储分配的优点：

    -   允许**活跃时段不交叠**的过程调用**共享存储空间**

    -   非局部变量的相对地址固定，与调用序列无关

        >   关于非局部变量会在后面讲到

-   活动树与控制栈：

    -   活动树的概念：描述程序运行期间控制**进入和离开各个活动**的情况的树
    -   活动树的结构：
        -   每个**结点**对应一个**活动**，根结点是**程序入口**过程的活动
        -   **子结点**表示被父结点活动**调用的活动**，按被调用的顺序自左向右排列
        -   一个子结点活动必须在其右兄弟结点活动开始之前结束
    -   活动树与控制栈的关系：
        -   活动树**根的活动记录**位于**栈底**，程序控制所在的活动记录位于**栈顶**
        -   **控制栈**中全部活动记录的**序列**对应于**活动树**中从**根结点**到达**当前控制**所在活动结点的**路径**

-   设计活动记录的原则：

    -   **传递的项**：调用者和被调用者之间**传递的值**放置在被调用活动记录的**起始位置**
    -   **固定长度项**：固定长度的项放置在活动记录的**中间位置**，包括**控制链、访问链、机器状态字段**
    -   **不定长度项**：初期不确定长度的项放置在活动记录的**尾部**
    -   **栈顶指针**：栈顶指针寄存器`top_sp`指向活动记录中**局部数据开始的位置**，以该位置作为**基地址**

---

*调用序列与返回序列：*

-   调用序列与返回序列概述：

    -   过程**调用**和过程**返回**都需要执行一些**代码**来管理**活动记录栈**，保存或恢复机器状态字等
    -   **调用序列**：实现**过程调用**的**代码段**。为活动记录**分配栈空间**，并填写活动记录的**字段**
    -   **返回序列**：实现**过程返回**的**代码段**。回收活动记录的栈空间，**恢复机器状态**，使**调用者过程**能继续执行
    -   调用序列和返回序列中的代码段通常被**分割到调用者过程和被调用者过程**中

-   **调用**序列的主要内容：

    -   参数：**调用者**计算实际参数的值

    -   返回地址：**调用者**将返回地址（当前程序计数器的值）存到被调用活动记录的**机器状态字段**中

    -   `top_sp`：**调用者**将`top_sp`的值存到被调用活动记录的**控制链**中，并**增加**`top_sp`的值，使其指向被调用活动记录**局部数据开始的位置**

    -   机器状态：**被调用者**保存寄存器值和其他状态信息（**保存现场**）

    -   局部数据：**被调用者**初始化其**局部数据**并开始执行

    -   访问链：**调用者**设置被调用活动记录的**访问链**

        >   关于访问链会在后面讲到

-   **返回**序列的主要内容：

    -   返回值：**被调用者**将**返回值**存到与**参数**相邻的位置

    -   `top_sp`：**被调用者**根据**控制链**中的数据恢复`top_sp`

        >   虽然`top_sp`的值被减小，但调用者依然可以知道**返回值**的位置

    -   机器状态：**被调用者**根据**机器状态字段**中的信息恢复寄存器值和其他状态信息（**恢复现场**）

    -   返回：**被调用者**根据**机器状态字段**中的信息跳转到**返回地址**

---

*变长数据的存储分配：*

-   变长数据的栈分配策略：

    -   编译时刻不能确定大小的过程**局部对象**可以分配到**运行时刻栈**中

        >   这样的局部对象不算作活动记录的一部分

    -   可以避免对变长数据空间的主动垃圾回收，减少相应开销

        >   现代程序设计语言中，编译时不能确定大小的对象往往分配在**堆区**，但如果是局部对象也可以分配到栈区

-   动态数组的分配：

    -   在活动记录的局部数据中存放**数组指针**

        >   **数组指针**在**编译时**可以确定大小，属于**活动记录**的一部分

    -   **运行**时在栈中**当前活动记录之下**开辟变长数组空间，存放数组元素

        >   变长数组虽然出现在栈中，但并不是**活动记录**的一部分，因为在**编译时**无法确定大小，需要在**运行时**动态分配

### 7.4 非局部数据与访问链

*非局部数据相关概念：*

-   非局部数据的概念：

    -   语言可分为**支持过程嵌套**声明的和**不支持过程嵌套**声明的

        >   支持过程嵌套：Pascal，不支持过程嵌套：C

    -   支持过程嵌套的语言中，过程可以使用**过程外定义的非局部数据**

        >   过程本就可以使用**过程自身定义**的局部数据和**全局定义**的数据。

        -   **全局**变量被分配在**静态区**，使用**静态**确定的地址访问它们

        -   **局部**变量被分配在**栈区**，在栈顶活动，通过**运行时**栈的`top_sp`访问

-   嵌套深度的概念：

    -   **过程**的嵌套深度：
        -   不内嵌在任何其他过程中的过程，其嵌套深度为1
        -   如果一个过程p在一个嵌套深度为i的过程中定义，则过程p的嵌套深度为i+1
    -   **变量**的嵌套深度：
        -   变量**声明所在过程**的嵌套深度即为该变量的嵌套深度

---

*访问链及其建立：*

-   访问链的概念：

    -   静态作用域规则：只要过程b嵌套在过程a的声明中，过程b就可以访问过程a中声明的对象
    -   访问链指针：在相互**嵌套**的过程的**活动记录**之间建立一种称为**访问链**的指针，使得内嵌的过程可以访问外层过程中声明的对象

-   访问链的建立：

    -   建立规则：如果**过程b**在源代码中**直接嵌套**在**过程a**中，那么**b的任何活动**中的访问链都指向最近的**a的活动**

        >   直接嵌套：过程b声明在过程a中且b的嵌套深度比a的嵌套深度大1
        >
        >   注意区分过程和活动，一个过程在运行时可以有多个活动

    -   建立步骤：建立访问链，其实就是在**调用序列**中加入相关代码，由**调用者**负责建立访问链

        假设嵌套深度为$n_x$的过程x调用嵌套深度为$n_y$的过程y（$x\rarr y$）

        -   如果$n_x<n_y$，即**外层调用内层**，那么需要在y的访问链中放置一个指向x的活动记录的指针

            >   这种情况下y一定是**直接定义**在x中的，因此$n_y=n_x+1$
            >
            >   因为外层**无法进一步深入内层**访问内层中的数据
            >
            >   外调内，内指外

        -   如果$n_x=n_y$，即**本层调用本层**，那么被调用活动记录的访问链与调用者活动记录相同，可以直接**复制**

            >   递归调用自己也是同理
            >
            >   同级调，**复制**

        -   如果$n_x>n_y$，即**内层调用外层**，那么从x的活动记录开始，沿着访问链经过$n_x-n_y+1$步找到的活动记录，就是y的访问链要指向的活动记录

            >   这种情况下，一定存在一个过程z，满足过程x**嵌套**在过程z中，且z中**直接定义**了过程y。在上述过程中经过$n_x-n_y+1$步找到的活动记录就是离栈顶最近的z的活动记录
            >
            >   -   这里说的“嵌套”不包括z直接定义x的情况，一定要存在一个嵌套的**中间过程**
            >
            >   内调外，指向最近**公共祖先**（不包括二者本身）

### 7.5 符号表的组织

>   由于本校考试不考查此部分，所以暂时没有知识总结

### 7.6 堆式存储分配

>   由于本校考试不考查此部分，所以暂时没有知识总结

## 8 代码优化

>   由于本校考试不考查此部分，所以暂时没有知识总结

## 9 代码生成

### 9.1 代码生成的主要任务

*指令选择：*

-   选择适当的**目标机指令**来实现中间表示（**IR**）语句

-   目标代码形式
    -   绝对机器语言代码
    -   可重定位的机器语言代码
    -   汇编语言代码

---

*寄存器分配和指派：*

-   选择适当的寄存器存放从内存中加载的值

---

*指令排序：*

-   选择适当的顺序安排指令的执行

### 9.2 目标机与指令选择

*目标机模型：*

-   特性：

    -   指令集：有加载、保存、运算、跳转等操作。指令之间可以有标号
    -   内存编址：内存按字节寻址
    -   寄存器：有n个通用寄存器$$$$R_0、R_1、...、R_{n-1}$$$$
    -   运算：所有运算分量都是整数

-   主要指令：

    -   加载指令：`LD dst, addr`

    -   保存指令：`ST x, r`

    -   运算指令：`OP dst, src1, src2`

    -   无条件跳转指令：`BR L`

    -   条件跳转指令：`Bcond r, L`

            >   例：`BLTZ r, L`
            >
            >   LTZ：Less then Zero

-   寻址模式：

    >    `contents(x)`表示取出地址`x`上的数据，`conteents(R)`表示取出寄存器`R`中的数据（有时也可以直接用`R`代替）

    -   **变量名**：直接用一个变量名表示**地址**

        >    例：`LD R1, a // R1 = contents(a)`

    -   偏移：用`基址(偏移量)`的方式表示地址

        -   `a(r)`：`a`是变量，`r`是寄存器

            >    例：`LD R1 a(R2) // R1 = contents(a + contens(R2))`

        -   `c(r)`：`a`是常整数，`r`是寄存器

            >   例：`LD R1 100(R2) // R1 = contents(100 + contens(R2))`

    -   间接：**指出的地址**中并不存放目标数据，而是又**存放着目标数据所在地址**

    -   `*`运算符可以理解成把地址中存放的数据取出来。在寻址模式中意思就是，**指出的地址中存放的数据**是真正要访问的地址

        -   `*r`：在寄存器`r`指示的地址中存放着目标数据所在地址

            >   例：`LD R1, *R2 // R1 = contents(contents(R2))`

        -   `*c(r)`：寄存器`r`中的值再加上常整数`c`所指示的地址中存放着目标数据所在地址

            >   例：`LD R1, *100(R2) // R1 = contents(contents(100 + contents(R2)))`

    -   立即数：`#c`表示立即数整数`c`

        >   例：`LD R1, #100 // R1 = 100`

---

*指令选择：*

-   **运算**三地址语句：`x = y - z`

    -   目标代码：

        -     `LD R1, y`

        -     `LD R2, z`

        -     `SUB R1, R1, R2`

        -     `ST x, R1`

        >   上面列出的4条指令一定能实现运算语句，但在特定情况下可以省略一些指令，例如：
        >
        >   -   所需的运算分量已经在寄存器中了
        >
        >   -   运算结果不需要放回内存

-   **数组寻址**三地址语句：

    >    `a`是一个实数数组，每个实数占8字节

    -   `b = a[i]`的目标代码：
        -     `LD R1, i`

        -     `MUL R1, R1, 8`

        -     `LD R2, a(R1) // R2 = contents(a + contents(R1))`

        -     `ST b, R2`
    -   `a[j] = c`的目标代码：
        -     `LD R1, c`

        -     `LD R2, j`

        -     `MUL R2, R2, 8`

        -     `ST a(R2), R1 // contents(a + contents(R2)) = R1`

-   **指针存取**三地址语句：

    -   `x = *p`的目标代码：
    -   `LD R1, p`

    -   `LD R2, 0(R1) // R2 = contents(0 + contents(R1))`

    -   `ST x, R2`

    -   `*p = y`的目标代码：
    -   `LD R1, p`

    -   `LD R2, y`

    -   `ST 0(R1), R2 // contents(0 + contents(R1)) = R2`

-   **条件跳转**三地址语句：`if x < y goto L`

    ```
    LD R1, x
    LD R2, y
    SUB R1, R1, R2
    ```

-   `BLTZ R1, M`

    >   `M`是标号为`L`的三地址语句所产生的若干条目标代码中的第一条指令标号

-   **过程调用**三地址语句

    -   静态存储分配：`call callee`的目标代码

        -    `ST callee.staticArea, #here + 20 // 存放返回地址`

        -    `BR callee.codeArea // 控制流转向被调用过程`

             >   `callee.staticArea`：`callee`的活动记录在静态区中的起始位置
             >
             >   `callee.codeArea`：`callee`的目标代码在静态代码区中的起始位置

    -   栈式存储分配：`call callee`的目标代码

        -     `ADD SP, SP, #caller.recordsize`

        -     `ST 0(SP), #here + 16`

        -     `BR callee.codeArea`

-   **返回**三地址语句

    -   静态存储分配：`return`的目标代码
        - `BR *callee.staticArea`
    -   栈式存储分配：`return`的目标代码
        - `BR *0(SP) // 由被调用者执行`

        - `SUB SP, SP, #caller.recoredsize // 由调用者执行`


---

*指令开销：*        

-   概念：存储开销，包括存储**指令本身**和指令涉及的其他**地址**
    -   涉及立即数和变量地址寻址会额外增加一个开销
    -   立即数会额外增加一个开销
    -   其中寄存器不需要额外增加开销
