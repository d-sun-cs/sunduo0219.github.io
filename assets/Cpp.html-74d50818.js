import{_ as n,W as a,X as t,a2 as i,Y as e,Z as l}from"./framework-6199cc12.js";const s={},o=i('<h1 id="c-basis" tabindex="-1"><a class="header-anchor" href="#c-basis" aria-hidden="true">#</a> C++ Basis</h1><h2 id="basic-grammar" tabindex="-1"><a class="header-anchor" href="#basic-grammar" aria-hidden="true">#</a> Basic Grammar</h2><h3 id="identifier" tabindex="-1"><a class="header-anchor" href="#identifier" aria-hidden="true">#</a> Identifier</h3><h4 id="variable-constant" tabindex="-1"><a class="header-anchor" href="#variable-constant" aria-hidden="true">#</a> <em>Variable &amp; Constant:</em></h4><ul><li><p>Why we need / What is variable: <strong>Name a memory space</strong> to operate it conveniently</p></li><li><p>Why we need / What is constant:</p><ul><li><p>Name a memory space where there is <strong>unchangeable</strong> data.</p></li><li><p>Or let the variable only a right value but <strong>not a left value</strong></p></li></ul></li><li><p>How to use variable:</p><ul><li>Declare: <code>type variable_name;</code></li><li>Define: <code>variable_name = variable_value;</code><ul><li>Declare and define: <code>type variable_name = variable_value;</code></li></ul></li></ul></li><li><p>How to use constant:</p><ul><li><p>Declare and define: <code>const type constant_name = constant_value;</code></p><blockquote><p>Constant must be <strong>initialized</strong> when defined</p></blockquote></li><li><p>Modify</p></li></ul></li></ul><hr><h4 id="basic-type" tabindex="-1"><a class="header-anchor" href="#basic-type" aria-hidden="true">#</a> <em>Basic Type:</em></h4>',7),r=e("ul",null,[e("li",null,[e("p",null,[e("u",null,"Why we need type:")]),e("ul",null,[e("li",null,[l("store data with different properties and allocate "),e("strong",null,"memory space"),l(" reasonably")])])]),e("li",null,[e("p",null,[e("u",null,"What types does C++ have:")]),e("ul",null,[e("li",null,[e("p",null,"Integer type:"),e("table",null,[e("thead",null,[e("tr",null,[e("th",null,"Type"),e("th",null,"Memory Usage")])]),e("tbody",null,[e("tr",null,[e("td",null,"bool"),e("td",null,"1 byte")]),e("tr",null,[e("td",null,"char"),e("td",null,"1 byte")]),e("tr",null,[e("td",null,"short"),e("td",null,"2 bytes")]),e("tr",null,[e("td",null,"int"),e("td",null,"4 bytes")]),e("tr",null,[e("td",null,"long"),e("td",null,"4 bytes")]),e("tr",null,[e("td",null,"long long"),e("td",null,[l("If 32-bit Linux, 4 bytes,"),e("br"),l("If 64-bit Linux, 8 bytes,"),e("br"),l("If Windows, 4 byte")])])])])]),e("li",null,[e("p",null,"Floating-point type:"),e("table",null,[e("thead",null,[e("tr",null,[e("th",null,"Type"),e("th",null,"Memory Usage")])]),e("tbody",null,[e("tr",null,[e("td",null,"float"),e("td",null,"4 bytes")]),e("tr",null,[e("td",null,"double"),e("td",null,"8 bytes")])])])])])]),e("li",null,[e("p",null,[e("u",null,"How to handle with types:")]),e("ul",null,[e("li",null,[e("p",null,[l("Get "),e("strong",null,"memory usage"),l(" of a type:")]),e("ul",null,[e("li",null,[e("code",null,"sizeof(type_or_variable)")]),e("li",null,"Unit: byte")])]),e("li",null,[e("p",null,[l("Literal "),e("strong",null,"integer"),l(":")]),e("ul",null,[e("li",null,[l("Default type is "),e("code",null,"int")]),e("li",null,"Base")])]),e("li",null,[e("p",null,[l("Literal "),e("strong",null,"decimal"),l(":")]),e("ul",null,[e("li",null,[e("p",null,[l("Default type is "),e("code",null,"double")]),e("ul",null,[e("li",null,[e("p",null,[l("Append "),e("code",null,"f"),l(" at the end to make it "),e("code",null,"float")]),e("blockquote",null,[e("p",null,[l("Like "),e("code",null,"3.14f")])])])])]),e("li",null,[e("p",null,"Valid number: Default is 6 bits")]),e("li",null,[e("p",null,[l("Scientific notation: "),e("code",null,"e")]),e("blockquote",null,[e("p",null,[e("code",null,"3e2"),l(" means "),e("span",{class:"katex"},[e("span",{class:"katex-mathml"},[e("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[e("semantics",null,[e("mrow",null,[e("mn",null,"3"),e("mo",null,"×"),e("mn",null,"1"),e("msup",null,[e("mn",null,"0"),e("mn",null,"2")])]),e("annotation",{encoding:"application/x-tex"},"3\\times10^2")])])]),e("span",{class:"katex-html","aria-hidden":"true"},[e("span",{class:"base"},[e("span",{class:"strut",style:{height:"0.7278em","vertical-align":"-0.0833em"}}),e("span",{class:"mord"},"3"),e("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),e("span",{class:"mbin"},"×"),e("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),e("span",{class:"base"},[e("span",{class:"strut",style:{height:"0.8141em"}}),e("span",{class:"mord"},"1"),e("span",{class:"mord"},[e("span",{class:"mord"},"0"),e("span",{class:"msupsub"},[e("span",{class:"vlist-t"},[e("span",{class:"vlist-r"},[e("span",{class:"vlist",style:{height:"0.8141em"}},[e("span",{style:{top:"-3.063em","margin-right":"0.05em"}},[e("span",{class:"pstrut",style:{height:"2.7em"}}),e("span",{class:"sizing reset-size6 size3 mtight"},[e("span",{class:"mord mtight"},"2")])])])])])])])])])])]),e("p",null,[e("code",null,"3e-2"),l(" means "),e("span",{class:"katex"},[e("span",{class:"katex-mathml"},[e("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[e("semantics",null,[e("mrow",null,[e("mn",null,"3"),e("mo",null,"×"),e("mn",null,"1"),e("msup",null,[e("mn",null,"0"),e("mrow",null,[e("mo",null,"−"),e("mn",null,"2")])])]),e("annotation",{encoding:"application/x-tex"},"3\\times10^{-2}")])])]),e("span",{class:"katex-html","aria-hidden":"true"},[e("span",{class:"base"},[e("span",{class:"strut",style:{height:"0.7278em","vertical-align":"-0.0833em"}}),e("span",{class:"mord"},"3"),e("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),e("span",{class:"mbin"},"×"),e("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),e("span",{class:"base"},[e("span",{class:"strut",style:{height:"0.8141em"}}),e("span",{class:"mord"},"1"),e("span",{class:"mord"},[e("span",{class:"mord"},"0"),e("span",{class:"msupsub"},[e("span",{class:"vlist-t"},[e("span",{class:"vlist-r"},[e("span",{class:"vlist",style:{height:"0.8141em"}},[e("span",{style:{top:"-3.063em","margin-right":"0.05em"}},[e("span",{class:"pstrut",style:{height:"2.7em"}}),e("span",{class:"sizing reset-size6 size3 mtight"},[e("span",{class:"mord mtight"},[e("span",{class:"mord mtight"},"−"),e("span",{class:"mord mtight"},"2")])])])])])])])])])])])])])])])]),e("li",null,[e("p",null,"Literal characters"),e("ul",null,[e("li",null,[l("Character encoding "),e("ul",null,[e("li",null,"ASCII")])]),e("li",null,[e("code",null,"‘c’")]),e("li",null,[e("code",null,"“string”"),l(" ("),e("code",null,"char *"),l(")")])])])])])],-1),c=i(`<hr><h4 id="struct-union" tabindex="-1"><a class="header-anchor" href="#struct-union" aria-hidden="true">#</a> <em>Struct &amp; Union:</em></h4><ul><li><p><u>What is / Why we need struct:</u> create user-defined data type <strong>by combining basic type</strong></p></li><li><p><u>What is / Why we need union:</u> store <strong>different types</strong> of data in the same <strong>memory space</strong></p></li><li><p><u>How to use struct:</u></p><ul><li><p>Define: <code>struct struct_name { member_list };</code></p></li><li><p>Declare:</p><ul><li><p><code>struct struct_name { member_list } struct_var_name;</code></p><blockquote><p>Declare when defining, not commonly-used</p></blockquote></li><li><p><code>struct struct_name struct_var_name;</code></p><blockquote><p><code>struct</code> can be omitted</p></blockquote></li></ul><blockquote><p>If <code>const</code>, the whole struct and all members are read-only</p></blockquote></li><li><p>Initialize:</p><ul><li><code>struct_var_name = { member_value_list };</code></li><li><code>struct_var_name.member_name = ...;</code></li></ul></li><li><p>Access:</p><ul><li><code>struct_var_name.member_name</code></li><li><code>struct_ptr-&gt;member_name</code></li></ul></li></ul></li><li><p><u>How to use union:</u></p><ul><li><p>Define: <code>union union_tag { member_list };</code></p></li><li><p>Declare:</p><ul><li><code>union union_tag { member_list } union_var_name;</code></li><li><code>union union_tag union_var_name;</code></li></ul></li><li><p>Initialize:</p><ul><li><code>union_var_name.member_name = ...</code></li></ul></li><li><p>Access: <code>union_var_name.member_name</code></p></li></ul></li></ul><h3 id="c-scope-namespace" tabindex="-1"><a class="header-anchor" href="#c-scope-namespace" aria-hidden="true">#</a> C++ Scope &amp; Namespace</h3><h4 id="scope-storage-duration" tabindex="-1"><a class="header-anchor" href="#scope-storage-duration" aria-hidden="true">#</a> <em>Scope &amp; Storage Duration:</em></h4><ul><li><p><u>What is scope:</u> program segment <strong>where</strong> variable, function and other user-defined elements works</p></li><li><p><u>What is storage duration:</u> time <strong>when</strong> variable works</p></li><li><p><u>What kinds of / How to set scope:</u></p><ul><li><p><strong>Local</strong> scope: within a <code>{...}</code>, explicit initialization</p><ul><li><p>Local variable</p></li><li><p>Other <strong>user-defined</strong> elements</p></li></ul></li><li><p><strong>Global</strong> scope: cross files, automatic initialization with <code>0</code></p><ul><li>Global variable</li><li><strong>Function</strong></li></ul><blockquote><p><code>extern</code> external link</p></blockquote></li><li><p><strong>File</strong> scope: within a file</p><ul><li><code>static</code> global variable or function</li><li><code>namespace</code></li><li>Other <strong>user-defined</strong> elements</li></ul></li><li><p><strong>Namespace</strong> scope</p></li><li><p><strong>Class</strong> scope</p></li></ul></li><li><p><u>What kinds of / How to set storage duration:</u></p><ul><li><strong>Automatic</strong> storage duration: during <code>{...}</code> executing <ul><li>local variable</li></ul></li><li><strong>Static</strong> storage duration: during program executing <ul><li>Global variable or function</li><li><code>static</code> local variable</li></ul></li><li><strong>Dynamic</strong> storage duration: heap</li><li><strong>Thread</strong> storage duration: <code>thread_local</code></li></ul></li></ul><hr><h4 id="namespace" tabindex="-1"><a class="header-anchor" href="#namespace" aria-hidden="true">#</a> <em>Namespace:</em></h4><ul><li><p><u>What is name space:</u> subset of <strong>file scope</strong></p></li><li><p><u>Why to use name space:</u> prevent naming conflict</p></li><li><p><u>How to use namespace:</u> in the same scope, or <code>include</code> firstly</p><ul><li><p>set: <code>namespace np_name { definitions }</code></p><blockquote><p>Accumulation if same name</p></blockquote></li><li><p><strong>Import</strong>: valid in <strong>current scope</strong></p><ul><li><code>using namespace_name::variable_name;</code></li><li><code>using namespace namespace_name;</code></li></ul><blockquote><p><strong>file scope</strong> if imported into a single file</p></blockquote></li><li><p>Direct <strong>reference</strong>: <code>namespace_name::variable_name</code></p><blockquote><p>Omit <code>namespace_name</code></p></blockquote></li><li><p><strong>Alias</strong>: <code>namespace namespace_alias = np_origin_name;</code></p></li><li><p>Nest</p></li></ul></li></ul><hr><h4 id="include" tabindex="-1"><a class="header-anchor" href="#include" aria-hidden="true">#</a> <em><code>#include</code>:</em></h4><ul><li>What’s <code>#include</code>: copy and paste the whole content of another file into current file</li><li>How to use <code>#include</code>: <ul><li><code>#include &lt;&gt;</code>: standard library</li><li><code>#include &quot;&quot;</code>: standard library and user defined file</li></ul></li></ul><h3 id="statements" tabindex="-1"><a class="header-anchor" href="#statements" aria-hidden="true">#</a> Statements</h3><h4 id="operators" tabindex="-1"><a class="header-anchor" href="#operators" aria-hidden="true">#</a> <em>Operators:</em></h4><ul><li>Arithmetic operators</li><li>Assignment operators</li><li>Comparison operators</li><li>Logical operators: <code>||</code> <code>&amp;&amp;</code> <code>!</code></li><li>Bitwise operators: <code>^</code> <code>|</code> <code>&amp;</code> <code>&lt;&lt;</code> <code>&gt;&gt;</code> <code>~</code></li></ul><hr><h4 id="flow-of-control" tabindex="-1"><a class="header-anchor" href="#flow-of-control" aria-hidden="true">#</a> <em>Flow of Control:</em></h4><ul><li>Sequential</li><li>Selective / Case</li><li>Loop</li></ul><hr><h4 id="macro" tabindex="-1"><a class="header-anchor" href="#macro" aria-hidden="true">#</a> <em>Macro:</em></h4><ul><li><p>Why macro:</p><ul><li>...</li></ul></li><li><p>How to use macro:</p><ul><li><code>#define macro_name macro_value</code></li><li>...</li></ul></li></ul><h3 id="pointer-array-function" tabindex="-1"><a class="header-anchor" href="#pointer-array-function" aria-hidden="true">#</a> Pointer &amp; Array &amp; Function</h3><h4 id="pointer-reference" tabindex="-1"><a class="header-anchor" href="#pointer-reference" aria-hidden="true">#</a> <em>Pointer &amp; Reference:</em></h4><ul><li><p><u>What is pointer:</u></p><ul><li>Concept: memory space <strong>address</strong></li><li>Size: the size of pointer itself</li></ul></li><li><p><u>What is reference:</u></p><ul><li><p>Nature: <strong>pointer constant</strong> with convenient operations encapsulated</p><blockquote><p>Automatic <strong>dereference</strong> when used</p></blockquote></li></ul></li><li><p><u>Why we need pointer:</u> manipulate <strong>memory space</strong></p></li><li><p><u>Why we need reference</u>:</p><ul><li>Get an alias of a same variable</li><li>Let the pointer operation more convenient</li></ul></li><li><p><u>How to use pointer:</u></p><ul><li>Get a pointer: address-of operator</li><li>Abuse: null pointer and wild pointer</li><li>Pointer and constant: <code>const type*</code> <code>type* const</code> <code>const type* const</code></li></ul></li><li><p><u>How to use conference:</u></p><ul><li><p>Get a reference:</p><ul><li>Variable reference: <code>type&amp; reference_name = variable_name</code></li><li>Constant reference: <code>const type&amp; reference_name = literal_or_constant</code></li></ul></li><li><p>With function:</p><ul><li>As function <strong>argument</strong></li><li>As function <strong>return type</strong>: return a variable having static storage duration, as left value</li></ul></li></ul></li></ul><hr><h4 id="array" tabindex="-1"><a class="header-anchor" href="#array" aria-hidden="true">#</a> <em>Array:</em></h4><ul><li><p><u>What are features of array:</u></p><ul><li>Same type</li><li>Continuous memory space</li></ul></li><li><p><u>How to use array:</u></p><ul><li>Relationship with pointer</li></ul></li></ul><hr><h4 id="function" tabindex="-1"><a class="header-anchor" href="#function" aria-hidden="true">#</a> <em>Function:</em></h4><ul><li><p><u>What does function do:</u> encapsulate, modularize, reuse</p></li><li><p><u>How to define function:</u></p><ul><li><strong>Declare &amp; Define</strong>: return type, name, argument list, body <ul><li>Declare and define in <strong>different files</strong> with <code>#include</code></li><li><code>inline</code>: no stack frame</li><li>Declare in a function ???</li></ul></li><li><strong>Argument list</strong>: <ul><li><strong>Default</strong> arguments: <ul><li>The last ones</li><li>Either in declaration or definition</li></ul></li><li><strong>Placeholder</strong> arguments: compatibility of calling</li><li><strong>Variable</strong> arguments: <ul><li><code>, ...</code></li><li><code>va_list va_start va_arg va_end</code></li></ul></li></ul></li><li><strong>Overload</strong>: scope, name, argument list</li></ul></li><li><p><u>How to use function:</u></p><ul><li><p><strong>Parameters</strong> passing</p><ul><li><p>Pass by <strong>value</strong>: <strong>copy</strong> variable itself, no <strong>effect</strong> on variable itself</p><blockquote><p>Including the whole struct, object, ...</p></blockquote></li><li><p>Pass by <strong>pointer</strong>: just copy <strong>pointer</strong>, not variable itself, having an <strong>effect</strong> variable itself</p><blockquote><p><strong>Reference</strong> or pointer can be used to avoid copying structs or objects</p></blockquote></li></ul></li><li><p>Return value</p></li><li><p>Relationship with <strong>pointer</strong></p></li></ul></li></ul><h2 id="object-oriented-c" tabindex="-1"><a class="header-anchor" href="#object-oriented-c" aria-hidden="true">#</a> Object-oriented C++</h2><h3 id="object-model" tabindex="-1"><a class="header-anchor" href="#object-model" aria-hidden="true">#</a> Object Model</h3><h4 id="encapsulate" tabindex="-1"><a class="header-anchor" href="#encapsulate" aria-hidden="true">#</a> <em>Encapsulate:</em></h4><ul><li><p><u>What is encapsulating / Why to encapsulate:</u> take <strong>property</strong> and <strong>behavior</strong> as a whole with access control</p></li><li><p><u>How to encapsulate:</u></p><ul><li><p><code>class</code></p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>class class_name; // declare
class class_name { // (declare and) define
access:
    properties/variables;
    behaviors/functions;
access:
    properties/variables;
    behaviors/functions;
...
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><code>struct</code></p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>struct struct_tag {
access:
    properties/variables;
    behaviors/functions;
access:
    properties/variables;
    behaviors/functions;
...
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul></li><li><p><u>How’re members stored in class / object:</u></p><ul><li><p>Member variable:</p><ul><li>Non-static: Belong to <strong>each object</strong>, stored in ...</li><li><code>static</code>: Belong to the <strong>class</strong>, stored in ...</li></ul></li><li><p>Member function:</p><ul><li>Non-static: Belong to the <strong>each object</strong>, stored in ...</li><li><code>static</code>: Belong to the <strong>class</strong>, stored in ..., can only access <code>static</code> member</li></ul></li></ul></li></ul><h4 id="constructor-destructor" tabindex="-1"><a class="header-anchor" href="#constructor-destructor" aria-hidden="true">#</a> <em>Constructor &amp; Destructor:</em></h4><ul><li><p><u>What’re constructor and destructor:</u></p><ul><li><strong>Constructor</strong><ul><li>A function <strong>initializes</strong> object being created (allocate)</li><li><strong>Complier</strong> calls it <strong>automatically</strong> and provides <strong>default</strong> implementations</li></ul></li><li><strong>Destructor</strong>: <ul><li>A function <strong>recycles</strong> object being destroyed (deallocate)</li><li><strong>Complier</strong> calls it <strong>automatically</strong> and provides <strong>default</strong> implementations</li></ul></li></ul></li><li><p><u>How to use constructor:</u></p><ul><li><p><strong>Define</strong>: <code>class_name(arguments){...}</code></p><blockquote><p>Allow <strong>overload</strong></p></blockquote></li><li><p><strong>Types</strong>:</p><ul><li><p><strong>Simple</strong> constructor</p><blockquote><p>If defined, default <strong>no arguments</strong> constructor will be overwritten, but default <strong>shallow copy</strong> constructor will not</p></blockquote></li><li><p><strong>Copy</strong> constructor:</p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>class_name(const class_name&amp; obj_var) {...}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li><p>Shallow copy: copy value of variable itself</p><blockquote><p>Duplicate release</p></blockquote></li><li><p>Deep copy: allocate new <strong>heap</strong> memory and copy</p></li></ul><blockquote><p>If defined, both default constructors will be overwritten</p></blockquote></li><li><p><strong>Default no arguments</strong> constructor: do not initialize any built-in type member but call <strong>no arguments</strong> constructor for <strong>object member</strong></p><blockquote><p>Explicitly require to generate a default constructor:</p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>class_name()=default;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></blockquote></li><li><p><strong>Default shallow copy</strong> constructor</p></li></ul></li><li><p><strong>Call</strong>:</p><ul><li><p><strong>Bracketing</strong>:</p><p><code>class_name obj_var(parameters);</code></p></li><li><p><strong>Explicit</strong> way:</p><p><code>class_name obj_var = class_name(parameters);</code></p><blockquote><p>Anonymous object: <code>class_name(parameters);</code></p></blockquote></li><li><p><strong>Implicit</strong> way to call <strong>copy constructor</strong>:</p><ul><li><p>Pass <strong>parameter</strong> to function by <strong>value</strong></p><blockquote><p>If required to pass the same object, <strong>reference</strong> can be used as argument</p></blockquote></li><li><p>Return <strong>local</strong> object in function by <strong>value</strong></p><blockquote><p>If required to return the same object as <code>*this</code>, <strong>reference</strong> can be used as return type</p></blockquote></li></ul></li><li><p><code>const</code> object: Properties of <code>const</code> object can’t be written. <code>const</code> object can only call <code>const</code> function</p></li></ul></li><li><p><strong>Initializer list</strong>:</p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>class_name(args): field(value), field(value), ...
{
    ...
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>Equivalent to <code>field = value;</code></li></ul></li></ul></li><li><p><u>How to use destructor:</u></p><ul><li><p><strong>Define</strong>: <code>~class_name(){}</code></p><blockquote><p>No argument</p></blockquote></li><li><p><strong>Default implementation</strong>: Empty. If there is a object member, call destructor (after current destructor)</p></li></ul></li></ul><h4 id="access-scope" tabindex="-1"><a class="header-anchor" href="#access-scope" aria-hidden="true">#</a> <em>Access &amp; Scope:</em></h4><ul><li><p><u>What’re types of access control:</u></p><ul><li><p><code>public</code>: inside class and outside class</p><blockquote><p>Default access of <code>struct </code> is <code>public</code></p></blockquote></li><li><p><code>protected</code>: inside class and subclass</p></li><li><p><code>private</code>: only inside class</p><blockquote><p>Default access of <code>class </code> is <code>private</code></p></blockquote></li></ul></li><li><p><u>What’s <code>friend</code>:</u> Access <code>private</code> member <strong>out of the class</strong></p></li><li><p><u>How to access members:</u></p><ul><li><p>Member variable</p><ul><li><p>Non-static:</p><ul><li><code>obj_name.var_name</code></li><li><code>obj_ptr-&gt;var_name</code></li></ul></li><li><p><code>static</code>:</p><ul><li><p><code>class_name::var_name</code></p></li><li><p><code>obj_name.var_name</code></p></li><li><p><code>obj_ptr-&gt;var_name</code></p><blockquote><p><code>obj_name</code> can be <code>nullptr</code></p></blockquote></li></ul></li></ul></li><li><p>Member function</p><ul><li><p>Non-static:</p><ul><li><p><code>obj_name.fun(params);</code></p></li><li><p><code>obj_ptr-&gt;fun(params);</code></p><blockquote><p><code>obj_ptr</code> can be <code>nullptr</code></p></blockquote></li></ul></li><li><p><code>static</code>:</p><ul><li><p><code>class_name::fun(params);</code></p></li><li><p><code>obj_name.fun(params);</code></p></li><li><p><code>obj_ptr-&gt;fun(params);</code></p><blockquote><p><code>obj_ptr</code> can be <code>nullptr</code>, but can not access <strong>non-static member variable</strong></p></blockquote></li></ul></li></ul></li><li><p>Pointer <code>this</code>: A <strong>pointer constant</strong> pointing to current object in <strong>non-static</strong> member function</p><ul><li><p><code>this-&gt;member</code></p></li><li><p><code>return *this</code>: Return current object itself</p><blockquote><p>Used for <strong>chain</strong> programming</p></blockquote></li></ul></li></ul></li><li><p><u>How to initialize / define members:</u></p><ul><li><p>Member variable:</p><ul><li><p>Non-static:</p><ul><li>In Constructor</li><li>In-Place</li><li><code>.</code></li></ul></li><li><p><code>static</code>:</p><ul><li><p>Declare inside class, initialize out of class</p><blockquote><p>The same scope as the whole class</p></blockquote></li></ul></li></ul></li><li><p>Member function: (declare and define)</p><ul><li><p>Define in class</p></li><li><p>Declare inside class, define out of class:</p><blockquote><p>The same scope as the whole class</p></blockquote><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>return_type class_name::function_name(args) {
    ...
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>Constructor with <strong>initializer list</strong> can also be defined like this</p></blockquote></li><li><p><code>static</code> function:</p></li><li><p><code>const</code> function: Set <code>this</code> a <strong>constant pointer constant</strong>. Member variables can’t be written in such function.</p></li></ul></li></ul></li><li><p><u>How to use <code>friend</code>:</u> “<strong>Declared</strong>” inside class with <code>friend</code></p><ul><li><code>friend</code> global function</li><li><code>friend</code> class</li><li><code>friend</code> member function</li></ul></li></ul><h4 id="operator-overload" tabindex="-1"><a class="header-anchor" href="#operator-overload" aria-hidden="true">#</a> <em>Operator Overload:</em></h4><ul><li><p><u>What is operator overloading / Why to overload operator:</u> For adapting to different user-defined types, <strong>redefine operators</strong></p></li><li><p><u>How to overload operator:</u></p><ul><li><p><strong>Member</strong> function:</p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>ReturnType operator*(Type arg) {...}
ReturnType operator++() {...}
ReturnType operator()(ArgList) {...}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><strong>Global</strong> function:</p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>ReturnType operator*(UserDefinedType obj, Type arg) {...}
ReturnType operator*(Type arg, UserDefinedType obj) {...}
ReturnType operator++(UserDefinedType obj) {...}
ostream&amp; operator&lt;&lt;(ostream&amp;, UserDefinedType&amp; obj) {...}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>Combined with <code>friend</code></p></blockquote></li><li><p>Default <strong>assign</strong> operator overloading: shallow copy</p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>class_name obj_var = parameters_or_obj;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><blockquote><p><strong>Implicit</strong> conversion of constructor</p></blockquote></li></ul></li><li><p><u>How to call overload operator:</u></p><ul><li><p><strong>Member</strong> function:</p><ul><li><p><code>obj.operator*(param) &lt;=&gt; obj * param</code></p></li><li><p><code>obj.opeartor++() &lt;=&gt; ++obj / obj++</code></p><blockquote><p>Overload <strong>preposition</strong> increment operator:</p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>UserDefinedType&amp; operator++() {...}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>Overload <strong>postposition</strong> increment operator:</p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>UserDefinedType operator++(int) {...}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></blockquote></li><li><p><code>obj.operator()(Params) &lt;=&gt; obj(Params)</code></p></li></ul></li><li><p><strong>Global</strong> function:</p><ul><li><p><code>operator*(obj, param) &lt;=&gt; obj * param</code></p></li><li><p><code>operator*(param, obj) &lt;=&gt; param * obj</code></p><blockquote><p>Overload left shift operator:</p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>ostream&amp; operator&lt;&lt;(ostream&amp; cout, User_defined_type obj) {...}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></blockquote></li><li><p><code>operator++(obj) &lt;=&gt; ++obj / obj++</code></p><blockquote><p>Overload <strong>preposition</strong> increment operator:</p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>UserDefinedType&amp; operator++(UserDefinedType&amp; obj) {...}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>Overload <strong>postposition</strong> increment operator:</p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>UserDefinedType operator++(UserDSefinedType&amp; obj, int) {...}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></blockquote></li></ul></li></ul></li></ul><hr><h3 id="inheritance-polymorphism" tabindex="-1"><a class="header-anchor" href="#inheritance-polymorphism" aria-hidden="true">#</a> Inheritance &amp; Polymorphism</h3><h4 id="inheritance" tabindex="-1"><a class="header-anchor" href="#inheritance" aria-hidden="true">#</a> <em>Inheritance:</em></h4><ul><li><p><u>What’s / Why inheritance:</u></p><ul><li>Abstract common properties</li><li>Reuse codes</li></ul></li><li><p><u>What’s the inheritance model:</u></p><ul><li>Subclass object = non-static member of superclass + non-static member of subclass itself</li><li>Construct superclass object before subclass object. Destruct subclass object before superclass object</li></ul></li><li><p><u>How to <strong>inherit</strong>:</u></p><ul><li><p>Three basic ways of inheritance:</p><ul><li><p><code>public</code> inheritance:</p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>class Subclass: public Superclass {...}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li><li><p><code>protected</code> inheritance:</p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>class Subclass: protected Superclass
{
    ...
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><code>private</code> inheritance:</p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>class Subclass: private Superclass 
{
    ...
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul></li><li><p>Multi-inheritance:</p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>class Subclass: InheritWay1 Superclass1, InheritWay2 Superclass2, ... 
{
    ...
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>Diamond inheritance</li></ul><blockquote><p>Two problems:</p><ul><li>Members with the same name of superclass</li><li>Duplicate inheritance of super superclass member</li></ul></blockquote></li><li><p><code>virtual</code> inheritance:</p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>class Subclass: virtual InheritWay Superclass
{
    ...
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><code>vbptr</code></li></ul></li></ul></li><li><p><u>How to <strong>access</strong> members about inheritance:</u></p><ul><li>Members in subclass: <ul><li>Non-static: <code>obj.member</code></li><li><code>static</code>: <code>Subclass::member</code></li></ul></li><li>Members in superclass: <ul><li>Non-static: <ul><li><code>obj.Superclass::member</code></li><li><code>obj.member</code> if no same name in subclass</li></ul></li><li><code>static</code>: <ul><li><code>Superclass::member</code> <code>Subclass::Superclass::member</code></li><li><code>Subclass::member</code> if no same name in subclass</li></ul></li></ul></li></ul></li></ul><h4 id="polymorphism" tabindex="-1"><a class="header-anchor" href="#polymorphism" aria-hidden="true">#</a> <em>Polymorphism:</em></h4><ul><li><p><u>What’s polymorphism:</u></p><ul><li><p>Static polymorphism:</p><p>function overload and operator overload</p><ul><li>Address bound in <strong>compiling</strong> time</li></ul></li><li><p><strong>Dynamic polymorphism</strong>:</p><p>Runtime polymorphism by <strong>subclass</strong> and <strong>virtual function</strong></p><ul><li>Address bound in <strong>runtime</strong></li></ul></li></ul></li><li><p><u>What’s the principle of polymorphism:</u></p><ul><li><code>vfptr -&gt; vftable</code></li><li><code>vfptr</code> of subclass points to its <code>vftable</code> which overwrites <code>virtual</code> function of superclass</li></ul></li><li><p><u>What’s abstract class:</u> class containing pure virtual function</p></li><li><p><u>How to implement polymorphism:</u></p><ol><li><p>Inheritance</p></li><li><p>Overwrite <code>virtual</code> function:</p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>// virtual function
virtual ReturnType FunctionName(ArgList)
{
    ...
}
// Pure virtual function
virtual ReturnType FunctionName(ArgList) = 0;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>Overwrite: return type, name, argument list</li></ul></li><li><p><strong>Reference</strong> (or pointer) of <strong>superclass</strong> points to <strong>object</strong> of <strong>subclass</strong></p></li></ol></li><li><p><u>How to use abstract class:</u></p><ul><li>Abstract class can’t be used to <strong>initialize an object</strong></li><li>Subclass is also abstract if inheriting abstract class and not implementing pure virtual function</li></ul></li></ul><hr><h2 id="template-c" tabindex="-1"><a class="header-anchor" href="#template-c" aria-hidden="true">#</a> Template C++</h2><h3 id="conceptual-framework" tabindex="-1"><a class="header-anchor" href="#conceptual-framework" aria-hidden="true">#</a> Conceptual Framework</h3><ul><li><u>What’s template:</u> Construct universal template to enhance reusability</li><li><u>Why we need template:</u><ul><li>Enhance reusability</li><li>Generic programming</li></ul></li></ul><hr><h3 id="function-template" tabindex="-1"><a class="header-anchor" href="#function-template" aria-hidden="true">#</a> Function Template</h3><ul><li><p><u>What’s function template:</u> A universal function whose <strong>return type</strong> of <strong>argument types</strong> are represented by <strong>virtual type</strong></p></li><li><p><u>How to use function template:</u></p><ul><li><p><strong>Create</strong>:</p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>template&lt;typename T1, typename T2, ...&gt;
ReturnType fun(Arglist)
{
    ...
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><strong>Call</strong>:</p><ul><li><p><strong>Complier automatically</strong> confirm template types by <strong>parameters</strong>:</p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>fun(params);

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>Confirm template types <strong>explicitly</strong>:</p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>fun&lt;Type1, Type2, ...&gt;(params)

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div></li></ul></li><li><p><strong>Overload</strong>:</p><ul><li><p>Simple function first</p><blockquote><p>Even only declare not define</p></blockquote></li><li><p>Force to use template rather than simple function:</p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>// empty template parameter list
fun&lt;&gt;(params)

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul></li></ul></li></ul><hr><h3 id="class-template" tabindex="-1"><a class="header-anchor" href="#class-template" aria-hidden="true">#</a> Class Template</h3><ul><li><p><u>What’s class template:</u> A universal class whose <strong>member type</strong> are represented by <strong>virtual type</strong></p></li><li><p><u>How to use class template:</u></p><ul><li><p><strong>Define class</strong>:</p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>template&lt;typename T1, typename T2 = DefaultType, ...&gt;
class
{
    ...
};
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>Member functions are created when called</p></blockquote></li><li><p><strong>Initialize object</strong>: <code>ClassName&lt;RealTypeList&gt;</code></p><blockquote><p>No automated deduction</p></blockquote></li><li><p><strong>Member function defined out of class template</strong>:</p><ul><li><p>In the same file:</p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>// .hpp
template&lt;typename T, ...&gt;
ReturnType ClassTemplate&lt;T, ...&gt;::func(T arg, ...)
{
    ...
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>In <strong>different files</strong>:</p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>// .h
template&lt;typename T, ...&gt;
class ClassTemplate
{
    ReturnType func();
}
// .cpp
#include &quot;.h&quot;
template&lt;typename T, ...&gt;
ReturnType ClassTemplate&lt;T, ...&gt;::func(T arg, ...)
{
    ...
}
// main file
#include &quot;.cpp&quot;

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul></li><li><p><strong>Class template as function argument</strong>:</p><ul><li><p><strong>Confirm</strong> types:</p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>ReturnType func(ClassTemplate&lt;RealTypeList&gt; obj, ...)
{
    ...
}

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><strong>Keep</strong> template types:</p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>template&lt;typename T1, typename T2, ...&gt;
ReturnType func(ClassTemplate&lt;T1, T2, ...&gt; obj, ...)
{
    ...
}

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><strong>Whole class</strong> as template:</p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>template&lt;typename T, ...&gt;
ReturnType func(T obj, ...)
{
    ...
}

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul></li><li><p><strong>Inheritance</strong>: Subclass must <strong>confirm type</strong> of template superclass, or be also a <strong>template class</strong> with <code>template&lt;typename T, ...&gt;</code></p></li><li><p><code>friend</code>: ???</p></li></ul></li></ul><h2 id="c-standard-library" tabindex="-1"><a class="header-anchor" href="#c-standard-library" aria-hidden="true">#</a> C++ Standard Library</h2><h3 id="overview" tabindex="-1"><a class="header-anchor" href="#overview" aria-hidden="true">#</a> Overview</h3><ul><li><u>What’s C++ standard library:</u> built-in identifiers defined in namespace <code>std</code> of multiple files <ul><li>standard function library / standard c library: <ul><li>general tools: <code>&lt;cstdlib&gt;</code></li><li>I/O: <code>&lt;cstdio&gt;</code></li><li>string: <code>&lt;string&gt;</code></li><li>signal: <code>&lt;csignal&gt;</code></li><li>variable arguments: <code>&lt;cstdarg&gt;</code></li><li>math: <code>&lt;cmath&gt;</code></li><li>time &amp; locale: <code>&lt;ctime&gt;</code> &amp; <code>&lt;clocale&gt;</code></li><li>error number: <code>&lt;cerrno&gt;</code></li><li>type: <code>&lt;cctype&gt;</code> &amp; <code>&lt;cstddef&gt;</code></li><li>limit: <code>&lt;climits&gt;</code> &amp; <code>&lt;cfloat&gt;</code></li><li>jump: <code>&lt;csetjump&gt;</code></li><li>assert: <code>&lt;cassert&gt;</code></li></ul></li><li>Object oriented class library <ul><li>I/O &amp; general tools: <code>&lt;iosteam&gt;</code>, <code>&lt;fstream&gt;</code></li><li>string: <code>&lt;string&gt;</code></li><li>STL</li></ul></li></ul></li><li><code>iostream</code></li></ul><h3 id="file-stream" tabindex="-1"><a class="header-anchor" href="#file-stream" aria-hidden="true">#</a> File Stream</h3><h4 id="standard-input-output-stream" tabindex="-1"><a class="header-anchor" href="#standard-input-output-stream" aria-hidden="true">#</a> <em>Standard Input &amp; Output stream:</em></h4><ul><li><code>cin</code></li><li><code>cout</code></li></ul><h4 id="basic-r-w-file" tabindex="-1"><a class="header-anchor" href="#basic-r-w-file" aria-hidden="true">#</a> <em>Basic R/W File:</em></h4><ul><li><p><u>What libs do we need:</u></p><ul><li><code>&lt;fstream&gt;</code></li><li><code>&lt;ifstream&gt;</code></li><li><code>&lt;ofstream&gt;</code></li></ul></li><li><p><u>How to r/w file:</u></p><ol><li><p>Create:</p><ul><li><code>ifstream ifs;</code></li><li><code>ofstream ofs;</code></li></ul></li><li><p>Open:</p><p><code>ifs.open(&quot;filepath&quot; openmode); ifs.is_open();</code></p><p><code>ofs.open(&quot;filepath&quot;, openmode);</code></p><ul><li><code>ios::in</code> /<code>ios::out</code></li><li><code>ios::binary</code></li><li><code>ios::app</code> / <code>ios::trunc</code></li><li><code>ios::ate</code></li></ul></li><li><p>Read:</p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>ifs &gt;&gt; buf;
ifs.getline(buf, sizeof(buf));
buf = ifs.get();
ifs.read(charptr, sizeof(data))
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Write:</p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>ofs &lt;&lt; &quot;data&quot;;
ofs.write(charptr, sizeof(data));
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>Close:</p><ul><li><code>ifs.close()</code></li><li><code>ofs.close()</code></li></ul></li></ol></li></ul><h3 id="c-stl" tabindex="-1"><a class="header-anchor" href="#c-stl" aria-hidden="true">#</a> C++ STL</h3><h4 id="conceptual-framework-1" tabindex="-1"><a class="header-anchor" href="#conceptual-framework-1" aria-hidden="true">#</a> <em>Conceptual Framework:</em></h4><ul><li><p><u>What’s STL / Why STL:</u></p><ul><li>Standard Template Library</li><li>Set a standard of commonly-used data structure and algorithm in C++</li></ul></li><li><p><u>What’re components of STL</u></p><ul><li><p><strong>Container</strong>: Data structure</p></li><li><p><strong>Algorithm</strong></p><ul><li>Qualitative algorithm</li><li>Non-qualitative algorithm</li></ul></li><li><p><strong>Iterator</strong></p></li><li><p><code>Functor</code>:</p><ul><li><p>Object of class overloading <strong>function call</strong> operator</p><blockquote><p>Function object, Like function</p></blockquote></li><li><p><code>Predicate</code></p></li></ul></li><li><p>Adapter</p></li><li><p>Space configurator</p></li></ul></li></ul><hr><h4 id="container" tabindex="-1"><a class="header-anchor" href="#container" aria-hidden="true">#</a> <em>Container:</em></h4><hr><h4 id="function-object" tabindex="-1"><a class="header-anchor" href="#function-object" aria-hidden="true">#</a> <em>Function Object:</em></h4><hr><h4 id="algorithm" tabindex="-1"><a class="header-anchor" href="#algorithm" aria-hidden="true">#</a> <em>Algorithm:</em></h4><ul><li>Traverse <ul><li><code>accumulate</code></li><li><code>fill</code></li></ul></li><li>Search</li><li>Sort</li><li>Replace</li><li>Set</li></ul>`,74),d=[o,r,c];function u(p,m){return a(),t("div",null,d)}const b=n(s,[["render",u],["__file","Cpp.html.vue"]]);export{b as default};
