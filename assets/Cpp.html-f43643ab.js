import{_ as i,W as n,X as t,a2 as a,Y as e,Z as l}from"./framework-3800c176.js";const o={},r=a('<h1 id="c" tabindex="-1"><a class="header-anchor" href="#c" aria-hidden="true">#</a> C++</h1><h2 id="basic-c" tabindex="-1"><a class="header-anchor" href="#basic-c" aria-hidden="true">#</a> Basic C++</h2><h3 id="variable-type" tabindex="-1"><a class="header-anchor" href="#variable-type" aria-hidden="true">#</a> Variable &amp; Type</h3><h4 id="variable-constant" tabindex="-1"><a class="header-anchor" href="#variable-constant" aria-hidden="true">#</a> <em>Variable &amp; Constant:</em></h4><ul><li><p>Why we need / What is variable: <strong>Name a memory space</strong> to operate it conveniently</p></li><li><p>Why we need / What is constant: Name a memory space where there is <strong>unchangeable</strong> data. Or let the variable only a right value but <strong>not a left value</strong></p></li><li><p>How to use variable:</p><ul><li>Declare: <code>type variable_name;</code></li><li>Define: <code>variable_name = variable_value;</code><ul><li>Declare and define: <code>type variable_name = variable_value;</code></li></ul></li></ul></li><li><p>How to use constant:</p><ul><li><p>Declare and define: <code>const type constant_name = constant_value;</code></p><blockquote><p>Constant must be <strong>initialized</strong> when defined</p></blockquote></li><li><p>Modify</p></li></ul></li></ul><hr><h4 id="basic-type" tabindex="-1"><a class="header-anchor" href="#basic-type" aria-hidden="true">#</a> <em>Basic Type:</em></h4>',7),s=e("ul",null,[e("li",null,[e("p",null,[e("u",null,"Why we need type:")]),e("ul",null,[e("li",null,[l("store data with different properties and allocate "),e("strong",null,"memory space"),l(" reasonably")])])]),e("li",null,[e("p",null,[e("u",null,"What types does C++ have:")]),e("ul",null,[e("li",null,[e("p",null,"Integer type:"),e("table",null,[e("thead",null,[e("tr",null,[e("th",null,"Type"),e("th",null,"Memory Usage")])]),e("tbody",null,[e("tr",null,[e("td",null,"bool"),e("td",null,"1 byte")]),e("tr",null,[e("td",null,"char"),e("td",null,"1 byte")]),e("tr",null,[e("td",null,"short"),e("td",null,"2 bytes")]),e("tr",null,[e("td",null,"int"),e("td",null,"4 bytes")]),e("tr",null,[e("td",null,"long"),e("td",null,"4 bytes")]),e("tr",null,[e("td",null,"long long"),e("td",null,[l("If 32-bit Linux, 4 bytes,"),e("br"),l("If 64-bit Linux, 8 bytes,"),e("br"),l("If Windows, 4 byte")])])])])]),e("li",null,[e("p",null,"Floating-point type:"),e("table",null,[e("thead",null,[e("tr",null,[e("th",null,"Type"),e("th",null,"Memory Usage")])]),e("tbody",null,[e("tr",null,[e("td",null,"float"),e("td",null,"4 bytes")]),e("tr",null,[e("td",null,"double"),e("td",null,"8 bytes")])])])])])]),e("li",null,[e("p",null,[e("u",null,"How to handle with types:")]),e("ul",null,[e("li",null,[e("p",null,[l("Get "),e("strong",null,"memory usage"),l(" of a type:")]),e("ul",null,[e("li",null,[e("code",null,"sizeof(type_or_variable)")]),e("li",null,"Unit: byte")])]),e("li",null,[e("p",null,[l("Literal "),e("strong",null,"integer"),l(":")]),e("ul",null,[e("li",null,[l("Default type is "),e("code",null,"int")]),e("li",null,"Base")])]),e("li",null,[e("p",null,[l("Literal "),e("strong",null,"decimal"),l(":")]),e("ul",null,[e("li",null,[e("p",null,[l("Default type is "),e("code",null,"double")]),e("ul",null,[e("li",null,[e("p",null,[l("Append "),e("code",null,"f"),l(" at the end to make it "),e("code",null,"float")]),e("blockquote",null,[e("p",null,[l("Like "),e("code",null,"3.14f")])])])])]),e("li",null,[e("p",null,"Valid number: Default is 6 bits")]),e("li",null,[e("p",null,[l("Scientific notation: "),e("code",null,"e")]),e("blockquote",null,[e("p",null,[e("code",null,"3e2"),l(" means "),e("span",{class:"katex"},[e("span",{class:"katex-mathml"},[e("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[e("semantics",null,[e("mrow",null,[e("mn",null,"3"),e("mo",null,"×"),e("mn",null,"1"),e("msup",null,[e("mn",null,"0"),e("mn",null,"2")])]),e("annotation",{encoding:"application/x-tex"},"3\\times10^2")])])]),e("span",{class:"katex-html","aria-hidden":"true"},[e("span",{class:"base"},[e("span",{class:"strut",style:{height:"0.7278em","vertical-align":"-0.0833em"}}),e("span",{class:"mord"},"3"),e("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),e("span",{class:"mbin"},"×"),e("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),e("span",{class:"base"},[e("span",{class:"strut",style:{height:"0.8141em"}}),e("span",{class:"mord"},"1"),e("span",{class:"mord"},[e("span",{class:"mord"},"0"),e("span",{class:"msupsub"},[e("span",{class:"vlist-t"},[e("span",{class:"vlist-r"},[e("span",{class:"vlist",style:{height:"0.8141em"}},[e("span",{style:{top:"-3.063em","margin-right":"0.05em"}},[e("span",{class:"pstrut",style:{height:"2.7em"}}),e("span",{class:"sizing reset-size6 size3 mtight"},[e("span",{class:"mord mtight"},"2")])])])])])])])])])])]),e("p",null,[e("code",null,"3e-2"),l(" means "),e("span",{class:"katex"},[e("span",{class:"katex-mathml"},[e("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[e("semantics",null,[e("mrow",null,[e("mn",null,"3"),e("mo",null,"×"),e("mn",null,"1"),e("msup",null,[e("mn",null,"0"),e("mrow",null,[e("mo",null,"−"),e("mn",null,"2")])])]),e("annotation",{encoding:"application/x-tex"},"3\\times10^{-2}")])])]),e("span",{class:"katex-html","aria-hidden":"true"},[e("span",{class:"base"},[e("span",{class:"strut",style:{height:"0.7278em","vertical-align":"-0.0833em"}}),e("span",{class:"mord"},"3"),e("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),e("span",{class:"mbin"},"×"),e("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),e("span",{class:"base"},[e("span",{class:"strut",style:{height:"0.8141em"}}),e("span",{class:"mord"},"1"),e("span",{class:"mord"},[e("span",{class:"mord"},"0"),e("span",{class:"msupsub"},[e("span",{class:"vlist-t"},[e("span",{class:"vlist-r"},[e("span",{class:"vlist",style:{height:"0.8141em"}},[e("span",{style:{top:"-3.063em","margin-right":"0.05em"}},[e("span",{class:"pstrut",style:{height:"2.7em"}}),e("span",{class:"sizing reset-size6 size3 mtight"},[e("span",{class:"mord mtight"},[e("span",{class:"mord mtight"},"−"),e("span",{class:"mord mtight"},"2")])])])])])])])])])])])])])])])]),e("li",null,[e("p",null,"Character encoding"),e("ul",null,[e("li",null,"ASCII")])])])])],-1),c=a(`<hr><h4 id="struct-union" tabindex="-1"><a class="header-anchor" href="#struct-union" aria-hidden="true">#</a> <em>Struct &amp; Union:</em></h4><ul><li><p><u>What is / Why we need struct:</u> create user-defined data type <strong>by combining basic type</strong></p></li><li><p><u>What is / Why we need union:</u> store <strong>different types</strong> of data in the same <strong>memory space</strong></p></li><li><p><u>How to use struct:</u></p><ul><li><p>Define: <code>struct struct_name { member_list };</code></p></li><li><p>Declare:</p><ul><li><p><code>struct struct_name { member_list } struct_var_name;</code></p><blockquote><p>Declare when defining, not commonly-used</p></blockquote></li><li><p><code>struct struct_name struct_var_name;</code></p><blockquote><p><code>struct</code> can be omitted</p></blockquote></li></ul><blockquote><p>If <code>const</code>, the whole struct and all members are read-only</p></blockquote></li><li><p>Initialize:</p><ul><li><code>struct_var_name = { member_value_list };</code></li><li><code>struct_var_name.member_name = ...;</code></li></ul></li><li><p>Access:</p><ul><li><code>struct_var_name.member_name</code></li><li><code>struct_ptr-&gt;member_name</code></li></ul></li></ul></li><li><p><u>How to use union:</u></p><ul><li><p>Define: <code>union union_tag { member_list };</code></p></li><li><p>Declare:</p><ul><li><code>union union_tag { member_list } union_var_name;</code></li><li><code>union union_tag union_var_name;</code></li></ul></li><li><p>Initialize:</p><ul><li><code>union_var_name.member_name = ...</code></li></ul></li><li><p>Access: <code>union_var_name.member_name</code></p></li></ul></li></ul><hr><h4 id="scope-storage-duration" tabindex="-1"><a class="header-anchor" href="#scope-storage-duration" aria-hidden="true">#</a> <em>Scope &amp; Storage Duration:</em></h4><ul><li><p><u>What is scope:</u> program segment <strong>where</strong> variable, function and other user-defined elements works</p></li><li><p><u>What is storage duration:</u> time <strong>when</strong> variable works</p></li><li><p><u>What kinds of / How to set scope:</u></p><ul><li><p><strong>Local</strong> scope:</p><ul><li><p>Local variable</p></li><li><p>Other <strong>user-defined</strong> elements</p></li></ul></li><li><p><strong>Global</strong> scope:</p><ul><li>Global variable</li><li><strong>Function</strong></li></ul><blockquote><p><code>extern</code> external link</p></blockquote></li><li><p><strong>File</strong> scope:</p><ul><li><code>static</code> global variable or function</li><li>Anonymous <code>namespace</code></li><li>Other <strong>user-defined</strong> elements</li></ul></li><li><p><strong>Namespace</strong> scope</p></li><li><p><strong>Class</strong> scope</p></li></ul></li><li><p><u>What kinds of / How to set storage duration:</u></p><ul><li><strong>Automatic</strong> storage duration: local variable</li><li><strong>Static</strong> storage duration <ul><li>Global variable or function</li><li><code>static</code> local variable</li></ul></li><li><strong>Dynamic</strong> storage duration: heap</li><li><strong>Thread</strong> storage duration: <code>thread_local</code></li></ul></li></ul><h3 id="c-file-namespace" tabindex="-1"><a class="header-anchor" href="#c-file-namespace" aria-hidden="true">#</a> C++ File &amp; Namespace</h3><h4 id="namespace" tabindex="-1"><a class="header-anchor" href="#namespace" aria-hidden="true">#</a> <em>Namespace:</em></h4><ul><li><p><u>What is name space:</u> subset of file scope</p></li><li><p><u>Why to use name space:</u> prevent naming conflict</p></li><li><p><u>How to set namespace:</u></p><p><code>namespace np_name { definitions }</code></p><blockquote><p>Accumulation</p></blockquote></li><li><p><u>How to use namespace:</u> in the same scope, or <code>include</code> firstly</p><ul><li><p>Direct <strong>reference</strong>: <code>namespace_name::variable_name</code></p><blockquote><p>Omit <code>namespace_name</code></p></blockquote></li><li><p><strong>Alias</strong>: <code>namespace namespace_alias = np_origin_name;</code></p></li><li><p><strong>Import</strong>: valid in current scope</p><ul><li><code>using namespace_name::variable_name;</code></li><li><code>using namespace namespace_name;</code></li></ul></li><li><p>Nest</p></li></ul></li></ul><hr><p><code>include</code></p><hr><h4 id="standard-library" tabindex="-1"><a class="header-anchor" href="#standard-library" aria-hidden="true">#</a> <em>Standard Library:</em></h4><ul><li><u>What’re the standard library:</u><ul><li><code>iostream</code></li><li></li></ul></li></ul><h3 id="statements" tabindex="-1"><a class="header-anchor" href="#statements" aria-hidden="true">#</a> Statements</h3><h4 id="operators" tabindex="-1"><a class="header-anchor" href="#operators" aria-hidden="true">#</a> <em>Operators:</em></h4><ul><li>Arithmetic operators</li><li>Assignment operators</li><li>Comparison operators</li><li>Logical operators: <code>||</code> <code>&amp;&amp;</code> <code>!</code></li><li>Bitwise operators: <code>^</code> <code>|</code> <code>&amp;</code> <code>&lt;&lt;</code> <code>&gt;&gt;</code> <code>~</code></li></ul><hr><h4 id="flow-of-control" tabindex="-1"><a class="header-anchor" href="#flow-of-control" aria-hidden="true">#</a> <em>Flow of Control:</em></h4><ul><li>Sequential</li><li>Selective / Case</li><li>Loop</li></ul><h3 id="pointer-array-function" tabindex="-1"><a class="header-anchor" href="#pointer-array-function" aria-hidden="true">#</a> Pointer &amp; Array &amp; Function</h3><h4 id="pointer-reference" tabindex="-1"><a class="header-anchor" href="#pointer-reference" aria-hidden="true">#</a> <em>Pointer &amp; Reference:</em></h4><ul><li><p><u>What is pointer:</u></p><ul><li>Concept: memory space <strong>address</strong></li><li>Size: the size of pointer itself</li></ul></li><li><p><u>What is reference:</u></p><ul><li><p>Nature: <strong>pointer constant</strong> with convenient operations packaged</p><blockquote><p>Like automatic <strong>dereference</strong> when used</p></blockquote></li></ul></li><li><p><u>Why we need pointer:</u> manipulate <strong>memory space</strong></p></li><li><p><u>Why we need reference</u>:</p><ul><li>Get an alias of a same variable</li><li>Let the pointer operation more convenient</li></ul></li><li><p><u>How to use pointer:</u></p><ul><li>Get a pointer: address-of operator</li><li>Abuse: null pointer and wild pointer</li><li>Pointer and constant: <code>const type*</code> <code>type* const</code> <code>const type* const</code></li></ul></li><li><p><u>How to use conference:</u></p><ul><li><p>Get a reference:</p><ul><li>Variable reference: <code>type&amp; reference_name = variable_name</code></li><li>Constant reference: <code>const type&amp; reference_name = literal_or_constant</code></li></ul></li><li><p>With function:</p><ul><li>As function <strong>argument</strong></li><li>As function <strong>return type</strong>: return a variable having static storage duration, as left value</li></ul></li></ul></li></ul><hr><h4 id="array" tabindex="-1"><a class="header-anchor" href="#array" aria-hidden="true">#</a> <em>Array:</em></h4><ul><li><p><u>What are features of array:</u></p><ul><li>Same type</li><li>Continuous memory space</li></ul></li><li><p><u>How to use array:</u></p><ul><li>Relationship with pointer</li></ul></li></ul><hr><h4 id="function" tabindex="-1"><a class="header-anchor" href="#function" aria-hidden="true">#</a> <em>Function:</em></h4><ul><li><p><u>What does function do:</u> encapsulate, modularize, reuse</p></li><li><p><u>How to define function:</u></p><ul><li><strong>Declare &amp; Define</strong>: return type, name, argument list, body <ul><li>Declare and define in <strong>different files</strong> with <code>#include</code></li><li><code>inline</code>: no stack frame</li><li>Declare in a function ???</li></ul></li><li><strong>Argument list</strong>: <ul><li><strong>Default</strong> parameters: <ul><li>The last ones</li><li>Either in declaration or definition</li></ul></li><li><strong>Placeholder</strong> parameters: compatibility of calling</li></ul></li><li><strong>Overload</strong>: scope, name, argument list</li></ul></li><li><p><u>How to use function:</u></p><ul><li><p><strong>Parameters</strong> passing</p><ul><li><p>Pass by <strong>value</strong>: <strong>copy</strong> variable itself, no <strong>effect</strong> on variable itself</p><blockquote><p>Including the whole struct</p></blockquote></li><li><p>Pass by <strong>pointer</strong>: just copy <strong>pointer</strong>, not variable itself, having an <strong>effect</strong> variable itself</p></li></ul></li><li><p>Relationship with pointer</p></li></ul></li></ul><h2 id="object-oriented-c" tabindex="-1"><a class="header-anchor" href="#object-oriented-c" aria-hidden="true">#</a> Object-oriented C++</h2><h3 id="object-model" tabindex="-1"><a class="header-anchor" href="#object-model" aria-hidden="true">#</a> Object Model</h3><h4 id="encapsulate" tabindex="-1"><a class="header-anchor" href="#encapsulate" aria-hidden="true">#</a> <em>Encapsulate:</em></h4><ul><li><p><u>What is encapsulating / Why to encapsulate:</u> take <strong>property</strong> and <strong>behavior</strong> as a whole with access control</p></li><li><p><u>How to encapsulate:</u></p><ul><li><p><code>class</code></p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>class class_name; // declare
class class_name { // (declare and) define
access:
    properties/variables;
    behaviors/functions;
access:
    properties/variables;
    behaviors/functions;
...
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><code>struct</code></p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>struct struct_tag {
access:
    properties/variables;
    behaviors/functions;
access:
    properties/variables;
    behaviors/functions;
...
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul></li><li><p><u>How’re members stored in class / object:</u></p><ul><li><p>Member variable:</p><ul><li>Non-static: Belong to <strong>each object</strong>, stored in ...</li><li><code>static</code>: Belong to the <strong>class</strong>, stored in ...</li></ul></li><li><p>Member function:</p><ul><li>Non-static: Belong to the <strong>each object</strong>, stored in ...</li><li><code>static</code>: Belong to the <strong>class</strong>, stored in ..., can only access <code>static</code> member</li></ul></li></ul></li></ul><h4 id="constructor-destructor" tabindex="-1"><a class="header-anchor" href="#constructor-destructor" aria-hidden="true">#</a> <em>Constructor &amp; Destructor:</em></h4><ul><li><p><u>What’re constructor and destructor:</u></p><ul><li><strong>Constructor</strong><ul><li>A function <strong>initializes</strong> object being created (allocate)</li><li><strong>Complier</strong> calls it <strong>automatically</strong> and provides <strong>default</strong> implementations</li></ul></li><li><strong>Destructor</strong>: <ul><li>A function <strong>recycles</strong> object being destroyed (deallocate)</li><li><strong>Complier</strong> calls it <strong>automatically</strong> and provides <strong>default</strong> implementations</li></ul></li></ul></li><li><p><u>How to use constructor:</u></p><ul><li><p><strong>Define</strong>: <code>class_name(arguments){...}</code></p><blockquote><p>Allow <strong>overload</strong></p></blockquote></li><li><p><strong>Types</strong>:</p><ul><li><p><strong>Simple</strong> constructor</p><blockquote><p>If defined, default <strong>no arguments</strong> constructor will be overwritten, but default <strong>shallow copy</strong> constructor will not</p></blockquote></li><li><p><strong>Copy</strong> constructor:</p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>class_name(const class_name&amp; obj_var) {...}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li><p>Shallow copy: copy value of variable itself</p><blockquote><p>Duplicate release</p></blockquote></li><li><p>Deep copy: allocate new <strong>heap</strong> memory and copy</p></li></ul><blockquote><p>If defined, both default constructors will be overwritten</p></blockquote></li><li><p><strong>Default no arguments</strong> constructor: do not initialize any built-in type member but call <strong>no arguments</strong> constructor for <strong>object member</strong></p><blockquote><p>Explicitly require to generate a default constructor:</p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>class_name()=default;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></blockquote></li><li><p><strong>Default shallow copy</strong> constructor</p></li></ul></li><li><p><strong>Call</strong>:</p><ul><li><p><strong>Bracketing</strong>:</p><p><code>class_name obj_var(parameters);</code></p></li><li><p><strong>Explicit</strong> way:</p><p><code>class_name obj_var = class_name(parameters);</code></p><blockquote><p>Anonymous object: <code>class_name(parameters);</code></p></blockquote></li><li><p><strong>Implicit</strong> way to call <strong>copy constructor</strong>:</p><ul><li><p>Pass <strong>parameter</strong> to function by <strong>value</strong></p><blockquote><p>If required to pass the same object, <strong>reference</strong> can be used as argument</p></blockquote></li><li><p>Return <strong>local</strong> object in function by <strong>value</strong></p><blockquote><p>If required to return the same object as <code>*this</code>, <strong>reference</strong> can be used as return type</p></blockquote></li></ul></li><li><p><code>const</code> object: Properties of <code>const</code> object can’t be written. <code>const</code> object can only call <code>const</code> function</p></li></ul></li><li><p><strong>Initializer list</strong>:</p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>class_name(args): field(value), field(value), ...
{
    ...
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>Equivalent to <code>field = value;</code></li></ul></li></ul></li><li><p><u>How to use destructor:</u></p><ul><li><p><strong>Define</strong>: <code>~class_name(){}</code></p><blockquote><p>No argument</p></blockquote></li><li><p><strong>Default implementation</strong>: Empty. If there is a object member, call destructor (after current destructor)</p></li></ul></li></ul><h4 id="access-scope" tabindex="-1"><a class="header-anchor" href="#access-scope" aria-hidden="true">#</a> <em>Access &amp; Scope:</em></h4><ul><li><p><u>What’re types of access control:</u></p><ul><li><p><code>public</code>: inside class and outside class</p><blockquote><p>Default access of <code>struct </code> is <code>public</code></p></blockquote></li><li><p><code>protected</code>: inside class and subclass</p></li><li><p><code>private</code>: only inside class</p><blockquote><p>Default access of <code>class </code> is <code>private</code></p></blockquote></li></ul></li><li><p><u>What’s <code>friend</code>:</u> Access <code>private</code> member <strong>out of the class</strong></p></li><li><p><u>How to access members:</u></p><ul><li><p>Member variable</p><ul><li><p>Non-static:</p><ul><li><code>obj_name.var_name</code></li><li><code>obj_ptr-&gt;var_name</code></li></ul></li><li><p><code>static</code>:</p><ul><li><p><code>class_name::var_name</code></p></li><li><p><code>obj_name.var_name</code></p></li><li><p><code>obj_ptr-&gt;var_name</code></p><blockquote><p><code>obj_name</code> can be <code>nullptr</code></p></blockquote></li></ul></li></ul></li><li><p>Member function</p><ul><li><p>Non-static:</p><ul><li><p><code>obj_name.fun(params);</code></p></li><li><p><code>obj_ptr-&gt;fun(params);</code></p><blockquote><p><code>obj_ptr</code> can be <code>nullptr</code></p></blockquote></li></ul></li><li><p><code>static</code>:</p><ul><li><p><code>class_name::fun(params);</code></p></li><li><p><code>obj_name.fun(params);</code></p></li><li><p><code>obj_ptr-&gt;fun(params);</code></p><blockquote><p><code>obj_ptr</code> can be <code>nullptr</code>, but can not access <strong>non-static member variable</strong></p></blockquote></li></ul></li></ul></li><li><p>Pointer <code>this</code>: A <strong>pointer constant</strong> pointing to current object in <strong>non-static</strong> member function</p><ul><li><p><code>this-&gt;member</code></p></li><li><p><code>return *this</code>: Return current object itself</p><blockquote><p>Used for <strong>chain</strong> programming</p></blockquote></li></ul></li></ul></li><li><p><u>How to initialize / define members:</u></p><ul><li><p>Member variable:</p><ul><li><p>Non-static:</p><ul><li>In Constructor</li><li>In-Place</li><li><code>.</code></li></ul></li><li><p><code>static</code>:</p><ul><li><p>Declare inside class, initialize out of class</p><blockquote><p>The same scope as the whole class</p></blockquote></li></ul></li></ul></li><li><p>Member function: (declare and define)</p><ul><li><p>Define in class</p></li><li><p>Declare inside class, define out of class:</p><blockquote><p>The same scope as the whole class</p></blockquote><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>return_type class_name::function_name(args) {
    ...
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>Constructor with <strong>initializer list</strong> can also be defined like this</p></blockquote></li><li><p><code>static</code> function:</p></li><li><p><code>const</code> function: Set <code>this</code> a <strong>constant pointer constant</strong>. Member variables can’t be written in such function.</p></li></ul></li></ul></li><li><p><u>How to use <code>friend</code>:</u> “<strong>Declared</strong>” inside class with <code>friend</code></p><ul><li><code>friend</code> global function</li><li><code>friend</code> class</li><li><code>friend</code> member function</li></ul></li></ul><h4 id="operator-overload" tabindex="-1"><a class="header-anchor" href="#operator-overload" aria-hidden="true">#</a> <em>Operator Overload:</em></h4><ul><li><p><u>What is operator overloading / Why to overload operator:</u> For adapting to different user-defined types, <strong>redefine operators</strong></p></li><li><p><u>How to overload operator:</u></p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>// member function
ReturnType operator*(Type arg) {...}
ReturnType operator++() {...}
// global function
ReturnType operator*(UserDefinedType obj, Type arg) {...}
ReturnType operator*(Type arg, UserDefinedType obj) {...}
ReturnType operator++(Type obj) {...}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>Combined with <code>friend</code></p></blockquote><ul><li><p><strong>Member</strong> function:</p><ul><li><p><code>obj.operator*(param) &lt;=&gt; obj * param</code></p></li><li><p><code>obj.opeartor++() &lt;=&gt; obj++</code></p><blockquote><p>Overload <strong>preposition</strong> increment operator:</p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>UserDefinedType&amp; operator++() {...}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>Overload <strong>postposition</strong> increment operator:</p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>UserDefinedType operator++(int) {...}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></blockquote></li></ul></li><li><p><strong>Global</strong> function:</p><ul><li><p><code>operator*(obj, param) &lt;=&gt; obj * param</code></p></li><li><p><code>operator*(param, obj) &lt;=&gt; param * obj</code></p><blockquote><p>Overload left shift operator:</p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>ostream&amp; operator&lt;&lt;(ostream&amp; cout, User_defined_type obj) {...}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></blockquote></li></ul></li></ul></li><li><p>Default assign function</p></li><li><p><strong>Implicit</strong> conversion: <code>class_name obj_var = parameters_or_copy;</code></p></li></ul><h3 id="inheritance-polymorphism" tabindex="-1"><a class="header-anchor" href="#inheritance-polymorphism" aria-hidden="true">#</a> Inheritance &amp; Polymorphism</h3><h3 id="file-stream" tabindex="-1"><a class="header-anchor" href="#file-stream" aria-hidden="true">#</a> File Stream</h3><h4 id="basic-input-output" tabindex="-1"><a class="header-anchor" href="#basic-input-output" aria-hidden="true">#</a> <em>Basic Input &amp; Output:</em></h4><ul><li><code>cin</code></li><li><code>cout</code></li></ul><h2 id="c-memory-management" tabindex="-1"><a class="header-anchor" href="#c-memory-management" aria-hidden="true">#</a> C++ Memory Management</h2><h3 id="preprocess" tabindex="-1"><a class="header-anchor" href="#preprocess" aria-hidden="true">#</a> Preprocess</h3><h4 id="macro" tabindex="-1"><a class="header-anchor" href="#macro" aria-hidden="true">#</a> <em>Macro:</em></h4><ul><li><p>Why macro:</p><ul><li>...</li></ul></li><li><p>How to use macro:</p><ul><li><code>#define macro_name macro_value</code></li><li>...</li></ul></li></ul><hr><h3 id="primitives" tabindex="-1"><a class="header-anchor" href="#primitives" aria-hidden="true">#</a> Primitives</h3><p><code>new</code></p><hr><h3 id="allocators" tabindex="-1"><a class="header-anchor" href="#allocators" aria-hidden="true">#</a> Allocators</h3><hr><h2 id="template-c" tabindex="-1"><a class="header-anchor" href="#template-c" aria-hidden="true">#</a> Template C++</h2><h3 id="conceptual-framework" tabindex="-1"><a class="header-anchor" href="#conceptual-framework" aria-hidden="true">#</a> Conceptual Framework</h3><h3 id="function-template" tabindex="-1"><a class="header-anchor" href="#function-template" aria-hidden="true">#</a> Function Template</h3><h3 id="class-template" tabindex="-1"><a class="header-anchor" href="#class-template" aria-hidden="true">#</a> Class Template</h3><h2 id="_4-c-stl" tabindex="-1"><a class="header-anchor" href="#_4-c-stl" aria-hidden="true">#</a> 4 C++ STL</h2><h3 id="_4-1-conceptual-framework" tabindex="-1"><a class="header-anchor" href="#_4-1-conceptual-framework" aria-hidden="true">#</a> 4.1 Conceptual Framework</h3><h3 id="_4-2-container" tabindex="-1"><a class="header-anchor" href="#_4-2-container" aria-hidden="true">#</a> 4.2 Container</h3><h3 id="_4-3-function-object" tabindex="-1"><a class="header-anchor" href="#_4-3-function-object" aria-hidden="true">#</a> 4.3 Function Object</h3><h3 id="_4-3-algorithm" tabindex="-1"><a class="header-anchor" href="#_4-3-algorithm" aria-hidden="true">#</a> 4.3 Algorithm</h3>`,62),u=[r,s,c];function d(p,m){return n(),t("div",null,u)}const b=i(o,[["render",d],["__file","Cpp.html.vue"]]);export{b as default};
