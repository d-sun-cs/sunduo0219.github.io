import{_ as i,V as e,W as t,a1 as o,X as l,Y as n}from"./framework-1f74d948.js";const r={},s=o(`<h1 id="compiler-principle" tabindex="-1"><a class="header-anchor" href="#compiler-principle" aria-hidden="true">#</a> Compiler Principle</h1><h2 id="_1-绪论" tabindex="-1"><a class="header-anchor" href="#_1-绪论" aria-hidden="true">#</a> 1 绪论</h2><h3 id="_1-1-编译相关的概念" tabindex="-1"><a class="header-anchor" href="#_1-1-编译相关的概念" aria-hidden="true">#</a> 1.1 编译相关的概念</h3><ul><li><p>编译的概念</p><ul><li>编译就是将高级语言(<strong>源语言</strong>)翻译成汇编语言或机器语言(<strong>目标语言</strong>)的过程</li></ul></li><li><p>三种程序</p><ul><li><p><strong>翻译</strong>程序(<strong>Translator</strong>)： 将某一种语言描述的程序(Source Program)翻译成等价的另一种语言描述的程序(Object Program)的程序</p><ul><li><p>翻译程序-<strong>解释</strong>程序(<strong>Interpreter</strong>)：一边解释一边执行的<strong>翻译程序</strong></p><blockquote><p>类似生活中的“口译”</p></blockquote></li><li><p>翻译程序-<strong>编译</strong>程序(<strong>Compiler</strong>)：将源程序完整地转换成机器语言程序或汇编语言程序，然后再处理、执行的<strong>翻译程序</strong></p></li></ul></li></ul></li></ul><h3 id="_1-2-编译系统的结构" tabindex="-1"><a class="header-anchor" href="#_1-2-编译系统的结构" aria-hidden="true">#</a> 1.2 编译系统的结构</h3><ul><li><p>编译系统的构成</p><ul><li><strong>编译程序</strong><ul><li>预处理器</li><li>编译器</li><li>汇编器</li><li>链接器/加载器</li></ul></li><li>运行系统</li></ul></li><li><p>编译器的8个模块</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>                                        |
                                        |SourceProgram
                                        V
    ------------                ----------------                  ------------
    |          |&lt;--------------&gt;|LxicalAnalyzer|&lt;----------------&gt;|          |
    |          |                ----------------                  |          |
    |          |                        |                         |          |
    |          |                        |Tokens                   |          |
    |          |                        V                         |          |
    |          |                    --------                      |          |
    |          |&lt;------------------&gt;|Parser|&lt;--------------------&gt;|          |
    |          |                    --------                      |          |
    |          |                        |                         |          |
    |          |                        |GrammarticalUnit         |          |
    |          |                        V                         |          |
    |   Form   |   --------------------------------------------   |  Error   |
    |Management|&lt;-&gt;|SemanticAnalyzer IntermediateCodeGenerator|&lt;-&gt;|Management|
    |          |   --------------------------------------------   |          |  
    |          |                        |                         |          |
    |          |                        |IntermediateCode         |          |
    |          |                        V                         |          |
    |          |                 ---------------                  |          |
    |          |&lt;---------------&gt;|CodeOptimizer|&lt;----------------&gt;|          |
    |          |                 ---------------                  |          |
    |          |                        |                         |          |
    |          |                        |IntermediateCode         |          |
    |          |                        V                         |          |
    |          |              ---------------------               |          |
    |          |&lt;------------&gt;|ObjectCodeGenerator|&lt;-------------&gt;|          |
    ------------              ---------------------               ------------
                                        |
                                        |ObjectCode
                                        V
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>分析 <ol><li>词法分析（lexical analyzer/scanner）</li><li>语法分析（syntax analyzer/parser）</li><li>语义分析</li></ol></li><li>综合 <ol><li>中间代码生成</li><li>代码优化</li><li>目标代码生成</li></ol></li><li>辅助 <ol><li>表格管理/符号表管理</li><li>出错处理</li></ol></li></ul></li></ul><h3 id="_1-3-词法分析概述" tabindex="-1"><a class="header-anchor" href="#_1-3-词法分析概述" aria-hidden="true">#</a> 1.3 词法分析概述</h3><ul><li><p>功能</p><ul><li>生成token：词法分析器扫描源程序字符串，识别<strong>单词</strong>，确定类型，生成单词(<em><strong>token</strong></em>)串 <ul><li>token：**(种别码, 属性值)**序对</li></ul></li><li>表格管理：登记标识符</li><li>错误管理：查词法错误</li></ul></li><li><p>输入与输出</p><ul><li>输入：源程序字符串</li><li>输出：token序列</li></ul></li></ul><h3 id="_1-4-语法分析概述" tabindex="-1"><a class="header-anchor" href="#_1-4-语法分析概述" aria-hidden="true">#</a> 1.4 语法分析概述</h3><ul><li><p>功能</p><ul><li><p>token：从<strong>token序列</strong>中，识别<strong>语法成分/短语</strong>，构造<strong>语法分析树</strong>，指导<strong>翻译</strong>过程</p><ul><li><p>用token组成各类<strong>语法成分/短语</strong>：表达式、因子、项、语句、子程序…</p><blockquote><p>“组词成句”</p></blockquote></li></ul></li><li><p>错误管理：指出<strong>语法错误</strong></p></li></ul></li><li><p>输入与输出</p><ul><li>输入：token序列</li><li>输出：语法分析树（包括<strong>语法成分</strong>）</li></ul></li></ul><h3 id="_1-5-语义分析概述" tabindex="-1"><a class="header-anchor" href="#_1-5-语义分析概述" aria-hidden="true">#</a> 1.5 语义分析概述</h3><ul><li><p>功能</p><ul><li>语法分析树：根据语法分析树，分析由语法分析器识别出来的<strong>语法成分的语义</strong><ul><li>语义分析一般和语法分析同时进行，称为<strong>语法制导翻译(syntax-directed translation)</strong></li><li>高级语言程序中的语句大体分为两类，一类是<strong>声明语句</strong>，一类是<strong>可执行语句</strong>。对于声明语句来说，语义分析的主要任务是<strong>收集标识符的属性信息</strong></li></ul></li><li>表格管理：收集<strong>标识符</strong>属性信息，完善<strong>符号表</strong>；进行子程序和变量的<strong>静态绑定</strong><ul><li>属性信息：种别、类型、值、作用域、...</li><li>子程序：代码的相对地址</li><li>变量：数据的相对地址，大小</li></ul></li><li>错误管理：<strong>语义检查</strong><ul><li>变量或过程<strong>未经声明就使用</strong></li><li>变量或过程名<strong>重复声明</strong></li><li><strong>运算分量</strong>类型不匹配</li><li><strong>操作符</strong>与<strong>操作数</strong>之间的类型不匹配</li></ul></li></ul></li><li><p>输出与输出</p><ul><li>输入：语法分析树（包括<strong>语法成分</strong>）</li><li>输出：语法分析树（包括<strong>语法成分</strong>）</li></ul></li></ul><h3 id="_1-6-中间代码生成及编译" tabindex="-1"><a class="header-anchor" href="#_1-6-中间代码生成及编译" aria-hidden="true">#</a> 1.6 中间代码生成及编译</h3><ul><li><p>功能：</p><ul><li><p>生成与机器无关、易于优化与转化的中间表示形式（常用<strong>三地址码</strong>），以此<strong>实现语义</strong></p><blockquote><p>三地址码又有多种表示形式，其中<strong>四元式</strong>较为常用</p><p>中间代码的<strong>优点</strong>：</p><ul><li>方便通过中间表示形式进行<strong>代码优化</strong></li><li>方便源程序的跨平台<strong>移植</strong></li></ul></blockquote></li></ul></li><li><p>输入与输出</p><ul><li>输入：语法分析树（包括<strong>语法成分</strong>）</li><li>输出：中间表示形式（常用<strong>三地址码</strong>）</li></ul></li></ul><h3 id="_1-7-代码优化" tabindex="-1"><a class="header-anchor" href="#_1-7-代码优化" aria-hidden="true">#</a> 1.7 代码优化</h3><ul><li><p>功能</p><ul><li>通过<strong>等价</strong>程序变换对中间代码进行优化，使程序更有效利用机器资源，节省<strong>存储空间</strong>，提高<strong>运行速度</strong>和效率</li></ul></li><li><p>优化方式</p><ul><li>与机器无关的优化 <ul><li>局部优化 <ul><li>常数合并</li><li>公共子表达式提取</li></ul></li><li>循环优化 <ul><li>强度削减</li><li>代码外提</li></ul></li><li>全局优化</li></ul></li><li>与机器有关的优化 <ul><li>寄存器的利用</li><li>体系结构</li><li>存储策略</li><li>任务划分</li></ul></li></ul></li></ul><h3 id="_1-8-目标代码生成" tabindex="-1"><a class="header-anchor" href="#_1-8-目标代码生成" aria-hidden="true">#</a> 1.8 目标代码生成</h3><ul><li><p>功能：将<strong>中间代码</strong>转换成<strong>目标机</strong>上的机器指令代码或汇编代码</p><blockquote><p>目标代码的形式：</p><ul><li>具有<strong>绝对地址</strong>的机器指令</li><li>模块结构的机器指令（需要<strong>链接程序</strong>）</li><li>汇编语言</li></ul></blockquote></li><li><p>输入与输出</p><ul><li>输入：中间表示形式（常用<strong>三地址码</strong>）</li><li>输出：目标代码（一般为汇编语言）</li></ul></li></ul><h3 id="_1-8-表格管理" tabindex="-1"><a class="header-anchor" href="#_1-8-表格管理" aria-hidden="true">#</a> 1.8 表格管理</h3><p>管理各种<strong>符号</strong>和<strong>符号表</strong>，辅助语法检查、语义检查，完成静态绑定，为编译的各个阶段提供信息</p><h3 id="_1-9-错误管理" tabindex="-1"><a class="header-anchor" href="#_1-9-错误管理" aria-hidden="true">#</a> 1.9 错误管理</h3><p>进行各种错误的检查、报告、纠正，以及相应的<strong>续编译处理</strong></p><h3 id="_1-10-编译程序的组织与生成" tabindex="-1"><a class="header-anchor" href="#_1-10-编译程序的组织与生成" aria-hidden="true">#</a> 1.10 编译程序的组织与生成</h3><p><em>编译程序设计的目标：</em></p><ul><li><p>程序本身：</p><ul><li>规模小、速度快、诊断能力强、可移植性好，可扩充性好</li></ul></li><li><p>目标程序：</p><ul><li>规模小、速度快</li></ul></li></ul><hr><p><em>前端与后端：</em></p><ul><li><p>前端：</p><ul><li><p>与源语言有关、与目标机无关</p><blockquote><p>词法分析、语法分析、语义分析与中间代码生成、与机器无关的代码优化</p></blockquote></li></ul></li><li><p>后端：</p><ul><li><p>与目标机有关的部分</p><blockquote><p>与机器有关的代码优化、目标代码生成</p></blockquote></li></ul></li></ul><p><em>编译器的实现与T形图：</em></p><ul><li><p>编译器的实现思想：</p><ul><li>自展：先实现<strong>语言子集</strong>编译器，再用子集编译更大的集合，直至整个语言</li></ul></li><li><p>T形图：</p><ul><li><p>内容：描述了<strong>源语言</strong>经编译程序到<strong>目标语言</strong>的过程</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code> --------------------------------          
 |SourceLanguage  ObjectLanguage|            
 ---------                -------       
         |CompilingProgram|
         ------------------
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p><strong>编译程序(CompilingProgram)的实现语言</strong>可以是高级语言、汇编语言、机器语言，但终究只有<strong>用机器语言实现</strong>才能运行该程序</p></blockquote></li><li><p>作用：T形图可以直观描述语言<strong>移植</strong>、<strong>新语言编译</strong>等问题</p></li></ul></li></ul><h2 id="_2-程序设计语言及其文法" tabindex="-1"><a class="header-anchor" href="#_2-程序设计语言及其文法" aria-hidden="true">#</a> 2 程序设计语言及其文法</h2><h3 id="_2-1-字母表和串" tabindex="-1"><a class="header-anchor" href="#_2-1-字母表和串" aria-hidden="true">#</a> 2.1 字母表和串</h3><ul><li><strong>字母表</strong>及其乘积、幂、闭包等运算</li><li><strong>串</strong>及其连接、幂等运算</li></ul><h3 id="_2-2-文法" tabindex="-1"><a class="header-anchor" href="#_2-2-文法" aria-hidden="true">#</a> 2.2 文法</h3><p>文法是一个具有<strong>推导</strong>和<strong>归约</strong>功能的<strong>四元组</strong>：</p><ul><li><p><strong>终结符集</strong>（ V_T ）</p></li><li><p><strong>非终结符集</strong>（ V_N ）：与终结符集不相交</p></li><li><p><strong>产生式集</strong>（ P ）</p><ul><li><p>左部属于 (V_T\\cup V_N)^+</p></li><li><p>右部属于 (V_T\\cup V_N)^*</p><blockquote><p>所以只有<strong>产生式的右部</strong>可以出现 \\epsilon</p></blockquote></li></ul></li><li><p><strong>开始符号</strong>（ S ）：至少在产生式左侧出现一次</p><ul><li>S\\in V_N</li></ul></li></ul><p>文法主要包括<strong>语法和词法</strong>：</p><ul><li><strong>语法</strong>：语句的组成规则</li><li><strong>词法</strong>：单词的组成规则</li></ul><h3 id="_2-3-语言" tabindex="-1"><a class="header-anchor" href="#_2-3-语言" aria-hidden="true">#</a> 2.3 语言</h3><ul><li><p>语言的定义</p><ul><li>由文法<strong>开始符号</strong>推导出的所有<strong>句子</strong>构成的集合称为<strong>文法生成的语言</strong>。</li></ul></li><li><p>语言的表示/描述</p><ul><li>文法解决了<strong>无穷语言的有穷表示</strong>问题。</li></ul></li><li><p>语言的运算</p><ul><li>语言有并、连接、幂、闭包等运算。</li></ul></li></ul><h3 id="_2-4-文法的分类" tabindex="-1"><a class="header-anchor" href="#_2-4-文法的分类" aria-hidden="true">#</a> 2.4 文法的分类</h3><blockquote><p>从上至下，<strong>要求依次累加</strong></p></blockquote><ul><li><p>无限制文法/短语结构文法（0型文法、图灵机）</p><ul><li>新增的约束：产生式<strong>左部</strong>至少包含一个<strong>非终结符</strong></li></ul></li><li><p>上下文有关文法（1型文法、线性界限自动机）</p><ul><li><p>新增的约束：产生式<strong>左部长度小于右部</strong></p><blockquote><p>当然，也允许<strong>空产生式</strong>的出现，这是个特例</p></blockquote></li></ul></li><li><p>上下文无关文法（2型文法、下推自动机）</p><ul><li><p>新增的约束：产生式<strong>左部仅为非终结符</strong></p><blockquote><p>左部仅有一个非终结符，右部长度大于左部</p></blockquote></li><li><p>应用：识别<strong>语言</strong>（语法、语义分析）</p></li></ul></li><li><p>正则文法（3型文法、有穷自动机）</p><ul><li>新增的约束：仅允许<strong>左线性(非终结符</strong>只能出现在最左边)或<strong>右线性</strong>(<strong>非终结符</strong>只能出现在最右边) <ul><li>产生式右部中，非终结符要么不出现，要么只出现一个</li></ul></li><li>应用：识别<strong>单词</strong>（词法分析）</li></ul></li></ul><h3 id="_2-5-cfg的分析树" tabindex="-1"><a class="header-anchor" href="#_2-5-cfg的分析树" aria-hidden="true">#</a> 2.5 CFG的分析树</h3><ul><li><p>分析树是<strong>推导</strong>的图形化表示：</p><ul><li>根节点：文法<strong>开始符号</strong></li><li>内部结点：代表<strong>产生式</strong><ul><li><strong>左部</strong>：该节点</li><li><strong>右部</strong>：子结点从左到右</li></ul></li><li>叶结点：非终结符或终结符</li><li><strong>树的产出/边缘</strong>：从左到右排列叶节点</li></ul></li><li><p>（句型的）短语：分析树中每一棵<strong>子树的边缘</strong>（若干步推导）</p><ul><li><p>直接短语（简单短语）：高度为2的子树的边缘（一步推导）</p><blockquote><p>注意子树的定义，需要从一个节点<strong>延伸直到叶子节点</strong>才叫子树，而且高度要大于等于2</p></blockquote></li><li><p>句柄：句型的<strong>最左直接短语</strong>/最左边高为为2子树的边缘</p><blockquote><p>不同子树的边缘可以相同，但<strong>短语不必重复</strong>。不过，对于出现在树中不同位置的<strong>相同文法符号</strong>，在短语中应当<strong>区别</strong>对待，可以用<strong>下标</strong>来区分它们</p></blockquote></li></ul></li><li><p>二义性文法与消歧规则</p><ul><li>二义性文法：文法可以为某个句子生成多棵分析树</li><li>消歧规则：人为规定一些<strong>优先级</strong>关系</li></ul></li></ul><h3 id="_2-6-程序设计语言" tabindex="-1"><a class="header-anchor" href="#_2-6-程序设计语言" aria-hidden="true">#</a> 2.6 程序设计语言</h3><ul><li>概念 <ul><li>程序设计语言(ProgrammingLanguage)：组成程序的<strong>所有语句</strong>的集合</li><li>程序(Program)：满足<strong>语法</strong>规则的<strong>语句序列</strong></li><li>语句(Sentence) ：满足<strong>语法</strong>规则的<strong>单词序列</strong></li><li>单词(Token) ：满足<strong>词法</strong>规则的字符串</li></ul></li></ul><h2 id="_3-词法分析" tabindex="-1"><a class="header-anchor" href="#_3-词法分析" aria-hidden="true">#</a> 3 词法分析</h2><h3 id="_3-1-正则表达式" tabindex="-1"><a class="header-anchor" href="#_3-1-正则表达式" aria-hidden="true">#</a> 3.1 正则表达式</h3><ul><li><p>正则表达式是描述<strong>正则语言</strong>的<strong>更紧凑</strong>的表示方法，它可以<strong>递归构建</strong></p></li><li><p>与<strong>正则文法、有穷自动机</strong>等价</p><blockquote><p>正则表达式很<strong>简洁</strong>；</p><p>正则文法方便文法<strong>性质</strong>的证明；</p><p>有穷自动机没那么抽象，方便<strong>实现</strong>；</p></blockquote></li><li><p>有自己的<strong>代数定律</strong></p></li></ul><h3 id="_3-2-有穷自动机" tabindex="-1"><a class="header-anchor" href="#_3-2-有穷自动机" aria-hidden="true">#</a> 3.2 有穷自动机</h3><blockquote><p>核心就是：<code>状态 + 输入 + 转换</code></p></blockquote><ul><li><p>有穷自动机（FA）：</p><ul><li>一种处理系统的数学模型。这种处理系统由<strong>输入带、读头、有穷控制器</strong>构造，可以根据当前<strong>状态</strong>和<strong>输入</strong>转入下一状态。</li><li>FA有其定义/接收的<strong>语言</strong></li><li>FA遵循最长子串匹配</li></ul></li><li><p>DFA：一种代表FA模型的<strong>五元组</strong></p><ul><li><p><strong>有穷状态集</strong>（S）</p></li><li><p><strong>输入字母表</strong>（ \\Sigma ）</p><blockquote><p>\\epsilon\\notin\\Sigma</p></blockquote></li><li><p><strong>转换函数</strong>（ \\sigma ）： S\\times\\Sigma\\rarr S</p></li><li><p><strong>开始状态</strong>（ s_0 ）</p></li><li><p><strong>接收状态集合</strong>（ F ）</p></li></ul></li><li><p>NFA：一种代表FA模型的<strong>五元组</strong></p><ul><li><p><strong>有穷状态集</strong>（ S ）</p></li><li><p><strong>输入字母表</strong>（ \\Sigma ）</p></li><li><p><strong>转换函数</strong>（ \\sigma ）： S\\times\\Sigma\\rarr 2^S</p><blockquote><p>\\epsilon-NFA 与 NFA 的区别就在于转换函数： S\\times(\\Sigma\\cup{\\epsilon})\\rarr 2^S</p></blockquote></li><li><p><strong>开始状态</strong>（ s_0 ）</p></li><li><p><strong>接收状态集合</strong>（ F ）</p></li></ul></li></ul><h3 id="_3-3-re与fa的转换" tabindex="-1"><a class="header-anchor" href="#_3-3-re与fa的转换" aria-hidden="true">#</a> 3.3 RE与FA的转换</h3><ul><li><p>RE\\rarr NFA ：<strong>分解、递归</strong></p></li><li><p>RE与NFA的对应规则</p></li><li><p>NFA\\rarr DFA ：<strong>状态转换表</strong></p></li><li><p>子集构造法</p></li></ul><h3 id="_3-4-词法单元token" tabindex="-1"><a class="header-anchor" href="#_3-4-词法单元token" aria-hidden="true">#</a> 3.4 词法单元token</h3><ul><li><p>概念：</p><ul><li>词法单元token是源程序中<strong>单词的机内表示</strong>，由<strong>种别码和属性值</strong>构成</li></ul></li><li><p>种别码：</p><ul><li>记录单词<strong>类型</strong></li><li>一词一码：关键字、运算符、界限符</li><li>一型一码：常量、运算符</li><li>多词一码：标识符</li></ul></li><li><p>属性值：</p><ul><li>记录单词<strong>字面值</strong></li><li>一词一码：<strong>不需要属性值</strong></li><li>一型一码：用<strong>属性值区分</strong>同一类型的单词</li><li>多词一码：用属性值记录<strong>无法枚举</strong>的标识符字面值</li></ul></li></ul><h3 id="_3-5-词法分析器" tabindex="-1"><a class="header-anchor" href="#_3-5-词法分析器" aria-hidden="true">#</a> 3.5 词法分析器</h3><ul><li><p>词法分析器的功能</p><ul><li><p>词法分析器扫描源程序字符串，识别<strong>单词</strong>，确定类型，生成单词(<em><strong>token</strong></em>)串</p><ul><li><p>根据<strong>词法规则</strong>识别及组合单词，进行词法检查</p></li><li><p>对<strong>数字</strong>常数完成数字字符串到<strong>二进制数值</strong>的转换</p></li><li><p>预处理：删去<strong>空格</strong>字符和<strong>注释</strong></p><blockquote><p>给人看的，对<strong>机器</strong>无意义</p></blockquote></li></ul></li></ul></li><li><p>词法分析器的工作</p><ul><li>输入缓冲区（Look ahead）：设置一个单词开始指针和扫描指针，<strong>一前一后</strong>，中间的部分是要识别的单词</li><li>识别出关键字后需要登记符号表</li></ul></li></ul><h3 id="_3-6-词法分析阶段的错误处理" tabindex="-1"><a class="header-anchor" href="#_3-6-词法分析阶段的错误处理" aria-hidden="true">#</a> 3.6 词法分析阶段的错误处理</h3><ul><li><p>错误类型</p><ul><li><strong>单词拼写</strong>错误</li><li><strong>非法字符</strong></li><li>不封闭</li><li>重复声明</li></ul></li><li><p>错误恢复与续编译：错误处理程序</p><ul><li><p>调用时机：<strong>当前状态与当前输入信息为空</strong></p></li><li><p>处理方式：查找已扫描字符串的最后一个<strong>终态字符</strong></p><blockquote><p>终态指的是自动机终态</p></blockquote><ul><li>找到了：识别成一个<strong>单词</strong>，回到初态</li><li>没找到：错误恢复策略（<strong>恐慌模式</strong>）</li></ul></li><li><p>恐慌模式：从<strong>剩余输入中删除字符</strong>直到遇到正确字符</p></li></ul></li></ul><h2 id="_4-语法分析" tabindex="-1"><a class="header-anchor" href="#_4-语法分析" aria-hidden="true">#</a> 4 语法分析</h2><h3 id="_4-1-句法分析概述" tabindex="-1"><a class="header-anchor" href="#_4-1-句法分析概述" aria-hidden="true">#</a> 4.1 句法分析概述</h3><ul><li><p>主要任务:</p><ul><li>从<em><strong>token</strong></em>序列中，识别<strong>语法成分/短语</strong>，构造<strong>语法分析树</strong>，指导翻译过程</li></ul></li><li><p>基本方法:</p><ul><li>自顶向下: 自顶向下构造语法分析树, 根据<strong>输入符</strong>，选择合适的<strong>产生式</strong>推导<strong>最左非终结符</strong>, 直到推导出完整的输入串 <ul><li>递归下降分析法</li><li>预测分析法</li></ul></li><li>自底向上: 自底向上构造语法分析树, 根据<strong>输入符,</strong> 选择合适的<strong>句柄</strong>进行归约, 直至将输入符串归约为文法开始符号 <ul><li>算符优先分析法</li><li>LR分析法</li></ul></li></ul></li></ul><h3 id="_4-2-自顶向下分析概述" tabindex="-1"><a class="header-anchor" href="#_4-2-自顶向下分析概述" aria-hidden="true">#</a> 4.2 自顶向下分析概述</h3><p><em>自顶向下分析的基本思想与主要问题：</em></p><ul><li><p>基本思想</p><ul><li>自顶向下构造语法分析树, 根据<strong>输入符</strong>，选择合适的<strong>产生式</strong>推导<strong>最左非终结符</strong>, 直到推导出完整的输入串</li><li>最左非终结符也是当前语法分析树的<strong>最左非终结符节点</strong>, 代表<strong>最左推导</strong></li><li>替换后会在语法分析树上<strong>生成子节点</strong></li></ul></li><li><p>主要问题</p><blockquote><p>本质上是<strong>文法改造问题</strong>，都是基于<strong>上下文无关文法</strong>的改造</p></blockquote><ul><li><p>二义性问题</p><ul><li><p>问题描述：文法中存在句子有不只一棵<strong>语法分析树</strong></p><blockquote><p>注：不存在算法判断一个上下文无关文法是<strong>无二义性</strong>的，但可以给出一组<strong>充分条件</strong>，满足充分条件的文法是无二义性的</p><p>做题的时候尝试去寻找同一句型的多棵分析树即可</p></blockquote></li><li><p>解决方法：改造文法，引入<strong>细粒度的文法变量</strong>；或人为规定优先级</p><blockquote><p>例如：</p><ul><li>解决加法和乘法优先级问题：引入<strong>项</strong>和<strong>因子</strong>的文法符号</li><li>解决 <code>if</code>匹配问题：引入**“匹配”<strong>和</strong>“不匹配”**的文法符号 <ul><li><code>if-else</code>的就近原则</li></ul></li></ul></blockquote></li></ul></li><li><p>回溯问题</p><ul><li><p>问题描述：多个<strong>候选式</strong>存在<strong>公共前缀</strong></p></li><li><p>解决方法：改造文法；提取左公因子（本质是在推迟决定）</p><ul><li><p>通过<strong>FIRST集</strong>和<strong>FOLLOW集</strong>判断是否会出现回溯</p></li><li><p>提取左公因子的一般形式：<code>S-&gt;cA|cB ----&gt; S-&gt;cS&#39; S&#39;-&gt;A|B</code></p><blockquote><p>把相同的留着，不同的交给新的文法变量去推</p></blockquote></li></ul></li></ul></li><li><p>左递归问题</p><ul><li><p>问题描述：直接左递归、间接左递归</p></li><li><p>解决方法：消除左递归</p><ul><li><p>消除<strong>直接左递归</strong>的一般形式： A\\rarr A\\alpha_1|A\\alpha_2|...|A\\alpha_n|\\beta_1|\\beta_2|...|\\beta_m</p><ul><li><p>转化为：</p><ul><li>A\\rarr\\beta_1A&#39;|\\beta_2A&#39;|...|\\beta_mA&#39;</li><li>A&#39;\\rarr\\alpha_1A&#39;|\\alpha_2A&#39;|...|\\alpha_nA&#39;|\\epsilon</li></ul><blockquote><p>把不左递归的先推出来，原左递归的交给新的文法符号改成右递归，再加空</p><p>本质上是将左递归转换成了<strong>右递归</strong>，付出的代价是引入一新的<strong>非终结符</strong>和<strong>空产生式</strong>，注意最后的<strong>空产生式</strong></p></blockquote></li></ul></li><li><p>消除<strong>间接左递归</strong>：先代入到最大编号，再消除直接左递归</p><ul><li>给所有产生式<strong>左部编号</strong>，按编号<strong>从小到大遍历</strong></li><li>如果出现<strong>左部编号大于右部开头编号</strong>，则出现左递归</li><li>若出现左递归，将相关产生式<strong>代入到左部编号最大的产生式</strong>中，转换成<strong>直接左递归</strong>，然后消除直接左递归</li></ul></li></ul></li></ul></li></ul></li></ul><hr><p><em>预测分析法的基本思想：</em></p><ul><li><p>预测分析:</p><ul><li>一般的自顶向下分析往往会因为<strong>产生式选择的不确定性</strong>而需要<strong>回溯</strong>，但<strong>预测分析</strong>就不需要回溯，它依据<strong>预测分析表</strong>，是一种<strong>确定的自顶向下分析方法</strong></li></ul></li><li><p>文法改造与检查：</p><ul><li><p>并不是所有文法都直接适用于自顶向下的分析，文法转换就是要<strong>改造这些文法</strong>以使其适合<strong>自顶向下的分析</strong>。</p><ul><li>消除文法的二义性</li><li>消除文法的回溯</li><li>消除文法的左递归</li></ul></li><li><p>改造文法后，还要检查文法是否为LL(1)的</p></li></ul></li></ul><hr><p><em>递归下降分析法的基本思想：</em></p><ul><li>根据文法产生式，定义可以递归调用的函数</li></ul><h3 id="_4-3-预测分析法" tabindex="-1"><a class="header-anchor" href="#_4-3-预测分析法" aria-hidden="true">#</a> 4.3 预测分析法</h3><blockquote><p>总结</p><ol><li><p>构造与检查文法</p><ol><li>构造一般文法</li><li>改造文法：消除二义性、消除左递归、消除回溯</li><li>检查是否为LL(1)文法</li></ol></li><li><p>设计算法</p><ol><li>构造<strong>预测分析表</strong></li><li>非递归的预测分析：下推自动机</li></ol></li></ol></blockquote><p><em>重要集合的引入与计算：</em></p><ul><li><p>FIRST集</p><ul><li><p>定义：文法符号(串)经过<strong>若干步推导</strong>得到的所有符号(串)的<strong>首终结符</strong>的集合</p><ul><li><p>若干步：零步、一步、多步</p><blockquote><p>后面出现的所有“推导”，若无特殊说明，均指的是“经若干步推导”</p></blockquote></li><li><p>特例：若能推导出 \\epsilon ，则 \\epsilon 也加入FIRST集</p></li></ul></li><li><p>计算：不断包含右部“开头”符号的FIRST集</p><ul><li><p>终结符的FIRST集**：**只包含该终结符一个元素的集合</p></li><li><p><strong>非终结符FIRST集</strong>：<strong>不断包含右部“开头”符号的FIRST集</strong></p><ul><li>右部开头是<strong>终结符</strong>或右部为<strong>空</strong>：直接包含终结符或 \\epsilon</li><li>右部开头是<strong>非终结符</strong>： <ul><li>包含该非终结符的FIRST集（先不包括 \\epsilon ）</li><li>同时若该非终结符能推导出 \\epsilon ，则继续加入右边紧邻符号的FIRST集，直到不能推导出 \\epsilon</li><li>若都能推导出 \\epsilon ，再将 \\epsilon 加入FIRST集中</li></ul></li></ul><blockquote><p><strong>文法符号串的FIRST集：</strong></p><ul><li>从左向右看，加入<strong>第一个符号的FIRST集</strong></li><li>若第一个符号能推导出 \\epsilon ，就累加下一个<strong>符号的FIRST集</strong>，直到不能再推出 \\epsilon</li><li>如果都能推导出 \\epsilon 就再加入 \\epsilon</li></ul></blockquote></li></ul></li></ul></li><li><p>FOLLOW集</p><ul><li>定义：是<strong>非终结符</strong>相关的一种集合，即<strong>推导</strong>过程中可以<strong>紧跟在该非终结符右侧</strong>的<strong>终结符</strong>的集合</li><li>计算：不断包含<strong>右侧的FISRT集</strong>和作为右部结尾时<strong>左部的FOLLOW集</strong><ul><li>将<strong>结束标记</strong>加入开始符号的FOLLOW集中</li><li>加右边的FIRST集：单看<strong>产生式右部</strong>，跟在某一非终结符<strong>后面的符号串的FIRST集</strong>加入该非终结符的FOLLOW集中，但不能加入 \\epsilon</li><li>加左部的FOLLOW集：看<strong>整条产生式</strong>，<strong>右部结尾</strong>的非终结符，以及可能因右方非终结符推导出 \\epsilon 而<strong>变成右部结尾</strong>的非终结符，其FOLLOW集要<strong>包含</strong>左部非终结符的FOLLOW集</li></ul></li></ul></li><li><p>SELECT集</p><ul><li>定义：是产生式相关的一种集合，即推导过程中可以选择该产生式时的<strong>输入符号</strong>的集合</li><li>计算：产生式的SELECT集的计算 <ul><li>若是空产生式，则为<strong>左部</strong>非终结符的<strong>FOLLOW集</strong></li><li>若非空产生式，则为<strong>右部</strong>符号串的<strong>FIRST集</strong>，不过若这个FIRST集中包含 \\epsilon ，就要去掉 \\epsilon 再并上左部的FOLLOW集</li></ul></li></ul></li></ul><hr><p><em>适合预测分析的文法：</em></p><blockquote><p>目标：构造不需要回溯、可用于预测分析的文法（前提是要先适用于自顶向下分析）</p></blockquote><ul><li><p>S_文法</p><ul><li>产生式<strong>右部</strong>以<strong>终结符</strong>开始（不包含 \\epsilon 产生式）</li><li>同一非终结符各个候选式的<strong>首终结符</strong>都不相同</li></ul></li><li><p>q_文法</p><ul><li>产生式<strong>右部</strong>或为 \\epsilon ，或以<strong>终结符</strong>开始</li><li>具有相同左部的产生式有<strong>不相交的可选集</strong><ul><li>可选集：可以使用该产生式推导时的<strong>输入符号</strong>集合，称为这个产生式的可选集</li></ul></li></ul></li><li><p>LL(1)文法：同一非终结符各个<strong>产生式</strong>的<strong>SELECT集</strong>互不相交</p><blockquote><p>从<strong>左</strong>向右扫描，构造最<strong>左</strong>推导</p></blockquote><blockquote><p>下面这三条限制就是为了保证“同一非终结符各个产生式的<strong>SELECT集</strong>互不相交”，是<strong>所有非终结符</strong>都要满足的</p></blockquote><ul><li>同一非终结符的候选式的FISRT集互不相交</li><li>只能有一个候选式可以推出空，若存在这样的一个候选式，则还要求左部的FOLLOW集与所有候选式的FIRST集互不相交</li></ul></li></ul><hr><p><em>预测分析法的工作：</em></p><ul><li><p>预测分析的格局/表驱动的下推自动机</p><ul><li><p>控制程序：包含通用的控制<strong>算法</strong></p><blockquote><p>例如接下来要讲的表驱动的预测分析算法</p></blockquote></li><li><p>栈：分析栈，指导<strong>语法分析树</strong>的形成。初始时栈底符号为#，栈顶符号为文法开始符号</p><blockquote><p>预测分析中，栈中的内容就是<strong>句型</strong></p></blockquote></li><li><p>输入：<strong>输入</strong>缓冲区，#为输入串结束符</p></li><li><p>表：<strong>预测分析表M</strong></p><ul><li><p>内容：行是<strong>非终结符</strong>，列是<strong>输入符号和#</strong>，表项是以行非终结符为左部的产生式</p><blockquote><p>列输入符号要包含于表项产生式的SELECT集</p></blockquote></li><li><p>使用：栈顶非终结符作为行，当前输入作为列，找到表项中的产生式进行推导</p></li></ul></li></ul></li><li><p>预测分析表的构建</p><ul><li>对于任意产生式，只要输入符号在右部的FIRST集中，就可以选择</li><li>同时对于右部能推出空的产生式，输入符号在左部的FOLLOW集中时也可以选择</li></ul></li><li><p>**表驱动的预测分析法/**非递归的预测分析法：</p><ul><li><p>借助<strong>下推自动机和预测分析表</strong></p></li><li><p>对比输入符号与栈顶符号，直到<strong>栈顶和输入</strong>都为结束符</p></li><li><p>若栈顶符号为<strong>终结符</strong></p><ul><li>二者<strong>相等</strong>，则弹栈，消耗输入符号，读头后移</li><li>二者不相等，则报错</li></ul></li><li><p>若栈顶符号为<strong>非终结符</strong>：查询预测分析表得到<strong>产生式</strong>，左部弹栈，右部入栈（<strong>自右向左</strong>入栈）不消耗<strong>输入符号</strong></p></li></ul></li></ul><hr><p><em>预测分析法的错误处理：</em></p><ul><li><p>错误检测</p><ul><li>最左/栈顶<strong>终结符</strong>与当前<strong>输入符号不匹配</strong></li><li>最左/栈顶<strong>非终结符</strong>与当前输入符号在<strong>预测分析表</strong>中<strong>无可用产生式</strong></li></ul></li><li><p>错误恢复：恐慌模式</p><ul><li><p>最左/栈顶<strong>终结符</strong>与当前输入不匹配时：直接忽略输入符号（删除）</p></li><li><p>最左/栈顶<strong>非终结符</strong>与当前输入符号在<strong>预测分析表</strong>中无可用产生式：</p><ul><li><p>若输入符号不在该非终结符的<strong>FOLLOW集</strong>中，则忽略输入符号（删除）</p></li><li><p>若输入符号在该非终结符的<strong>FOLLOW集</strong>中（同步词法单元），则忽略/弹出该非终结符</p><blockquote><p>FOLLOW集本质就是非终结符<strong>推出空</strong>时的SELECT集</p></blockquote></li></ul></li></ul></li></ul><h3 id="_4-4-递归下降分析法" tabindex="-1"><a class="header-anchor" href="#_4-4-递归下降分析法" aria-hidden="true">#</a> 4.4 递归下降分析法</h3><ul><li><p>文法：要求文法是LL(1)的</p></li><li><p>分析：从文法<strong>开始符号的产生式</strong>开始，遍历右部符号（即<strong>调用文法开始符号的过程</strong>）</p><blockquote><p>遍历符号的过程中，每次取得一个输入，终结符消耗输入，非终结符根据输入选择产生式</p></blockquote><ul><li><p>若为终结符，则必须等于当前输入符号，否则报错</p></li><li><p>若为非终结符，则“递归”调用<strong>该非终结符对应的过程</strong></p><blockquote><p>非终结符对应的过程：</p><ul><li>若有<strong>多条产生式</strong>，先根据输入和SELECT集选择产生式</li><li>遍历产生式右部符号，若是终结符，则当前输入必须与之相等，否则报错；若是非终结符，则调用其过程</li></ul></blockquote></li><li><p>最后一个输入符号必须是终结符</p></li></ul></li></ul><h3 id="_4-5-自底向上分析概述" tabindex="-1"><a class="header-anchor" href="#_4-5-自底向上分析概述" aria-hidden="true">#</a> 4.5 自底向上分析概述</h3><p><em>自底向上分析的基本思想与主要问题：</em></p><ul><li><p>基本思想</p><ul><li><p>自底向上构造语法分析树, 根据<strong>输入符,</strong> 选择合适的<strong>句柄</strong>进行归约, 直至将输入符串归约为文法开始符号</p><ul><li>句柄：当前句型的<strong>最左直接短语</strong></li><li>归约句柄：<strong>最左归约</strong></li></ul></li><li><p>移入-归约的思想</p><ul><li><p>自底向上分析也叫<strong>移入-归约分析</strong></p><blockquote><p>借助<strong>栈</strong>来理解</p></blockquote></li><li><p>移入：将<strong>输入符号</strong>压入栈</p></li><li><p>归约：从栈中依次<strong>弹出</strong>能构成<strong>产生式右部</strong>的若干个符号，然后将<strong>左部压入栈</strong>（最左归约）</p><blockquote><p>最左归约称为规范归约、最右推导称为规范推导，每次用于归约的符号串称之为<strong>句柄</strong>，也就是<strong>产生式右部</strong></p></blockquote></li></ul></li></ul></li><li><p>主要问题</p><ul><li>何时移入、何时归约、归约时用什么归约</li><li>移入-归约分析中的关键问题是<strong>正确识别句柄</strong></li></ul></li><li><p>系统框架</p><ul><li><p>控制程序</p></li><li><p>栈：分析栈</p><blockquote><p>自底向上分析中，<strong>栈和输入</strong>中的内容组合起来是(规范)句型，栈中的内容只是句型的<strong>前缀</strong></p></blockquote></li><li><p>输入：输入缓冲区</p></li><li><p>表：指导<strong>语法分析树</strong>的形成，确定<strong>移进和归约</strong>的时机</p></li></ul></li></ul><hr><p><em>优先法的基本思想：</em></p><ul><li><p>优先级的概念：优先级指的是<strong>归约的优先级</strong></p></li><li><p>优先级的作用：确定何时移进何时规约</p><ul><li><strong>栈顶</strong>最近的终结符优先级<strong>小于或等于输入</strong>符号：移入</li><li><strong>栈顶</strong>最近的终结符优先级<strong>大于输入</strong>符号：归约 <ul><li>归约的句柄是从栈顶到第一次优先级<strong>小于</strong>输入的位置（不包括）</li></ul></li></ul></li><li><p>核心问题：优先级的确定</p></li></ul><hr><p><em>状态法/LR分析的基本思想：</em></p><blockquote><p>从<strong>左</strong>到右扫描，反向构造最<strong>右</strong>推导</p></blockquote><ul><li><p><strong>状态</strong>：</p><ul><li><p>用<strong>状态</strong>表示<strong>句柄识别的进展程度</strong></p><blockquote><p>状态的可视化表示就是在产生式右部插入一个圆点，代表<strong>离可以使用该产生式归约</strong>还差什么符号，<strong>圆点右边的符号</strong>就是需要的符号</p></blockquote></li><li><p>移进状态：圆点后面是终结符</p></li><li><p>待约状态：圆点后面是非终结符</p></li><li><p>归约状态：圆点后面没有符号</p></li></ul></li><li><p><strong>栈</strong>：</p><ul><li>有两个栈，<strong>状态栈与符号栈</strong>，它们是平行的（栈中<strong>元素个数保持相等</strong>）</li></ul></li><li><p><strong>分析表</strong>：</p><ul><li><p>只要构造出正确的<strong>分析表</strong>就可以直观且快速地识别了，分析表的概述如下：</p></li><li><p>内容：</p><ul><li><p><strong>一行</strong>对应一个<strong>状态</strong>，一个状态的<strong>一条边</strong>对应于该行的<strong>一个表项</strong></p><blockquote><p>这里的<strong>边</strong>指的是自动机中的边</p></blockquote></li><li><p><strong>一列</strong>对应一个<strong>文法符号</strong>，终结符和结束符在<strong>ACTION列组</strong>，非终结符在<strong>GOTO列组</strong></p></li></ul></li><li><p>应用：</p><ul><li><p>从状态栈只有初始状态0、符号栈只有结束符 开始，根据**当前状态(行)和输入符号(列)**找到表项，执行对应的操作，直到读取输入后找到的表项为acc或err</p><blockquote><p>acc时，栈中为S，输入缓冲中为#</p></blockquote></li><li><p>表项中， s_n 代表将<strong>所在列对应符号和状态n</strong>同时压入栈符号栈和状态栈； r_n 代表使用第n个产生式归约，同时弹出<strong>产生式右部</strong>符号(串)和与其<strong>平行的状态</strong>，并压入<strong>左部非终结符</strong>，再根据<strong>当前栈顶状态</strong>和<strong>该非终结符</strong>找到GOTO列组的项k，这代表着再<strong>将状态k压入栈</strong>；acc代表成功识别，err代表出错</p><blockquote><p>所以，<strong>构造出文法的分析表</strong>是LR分析的关键</p></blockquote></li></ul></li></ul></li></ul><h3 id="_4-4-算符优先分析法" tabindex="-1"><a class="header-anchor" href="#_4-4-算符优先分析法" aria-hidden="true">#</a> 4.4 算符优先分析法</h3><p><em>适合算符优先分析的文法：</em></p><ul><li><p>算符文法：</p><ul><li>文法中不存在具有<strong>相邻非终结符</strong>的产生式</li></ul></li><li><p>算符优先文法：</p><ul><li><p>定义：可以根据产生式推断出<strong>不矛盾优先级</strong>关系的<strong>算符文法</strong></p></li><li><p>终结符优先级的确定：</p><ul><li><p><strong>相邻或只间隔一个非终结符</strong>，则优先级相等</p></li><li><p>经由非终结符<strong>推导</strong>至少一步后<strong>相邻或只间隔一个非终结符</strong>，则被推导出的优先级更高，且应当认为<strong>左边</strong>的处于<strong>栈</strong>中，<strong>右边</strong>的处于<strong>输入缓冲</strong>中</p><blockquote><p>对于不能通过产生式判断优先级的算符文法，也可以<strong>人为规定优先级</strong></p></blockquote></li></ul></li></ul></li></ul><hr><p><em>算符优先矩阵：</em></p><ul><li><p>FIRSTOP与LASTOP</p><ul><li>非终结符的FIRSTOP集：该非终结符经过至少一步推导得到的<strong>串首终结符或</strong>去掉串首的<strong>一个非终结符</strong>后成为串首终结符的集合</li><li>非终结符的LASTOP集：该非终结符经过至少一步推导得到的<strong>串尾终结符或</strong>去掉串尾的<strong>一个非终结符</strong>后成为串首终结符的集合</li></ul></li><li><p>算符优先矩阵</p><ul><li><p>内容：</p><ul><li><p>行：栈内符号</p></li><li><p>列：输入符号</p><blockquote><p>注意行列不要颠倒；也可以包括#，栈中的#对应于FIRSTOP，输入中的#对应于LASTOP</p></blockquote></li></ul></li><li><p>填写：</p><ul><li>遍历所有产生式右部的所有相邻符号，确定优先级</li><li>应当认为左边的处于栈中，右边的处于输入缓冲中</li></ul></li></ul></li><li><p>优先函数</p><ul><li><p>构造方法：</p><ul><li>通过算符优先矩阵规定的偏序关系，构造DAG，计算拓扑排序，基于拓扑排序构造优先函数</li></ul></li><li><p>优点：节省存储空间</p></li><li><p>缺点：错误检测能力降低</p><blockquote><p>详见笔记仓库</p></blockquote></li></ul></li></ul><hr><p><em>算符优先法的素短语：</em></p><ul><li>素短语：<strong>含终结符</strong>且不含有更小<strong>含终结符短语</strong>的短语</li><li>算符优先法归约的是<strong>最左素短语</strong>，并非<strong>最左直接短语</strong></li></ul><h3 id="_4-5-lr分析法" tabindex="-1"><a class="header-anchor" href="#_4-5-lr分析法" aria-hidden="true">#</a> 4.5 LR分析法</h3><blockquote><p>⭐️LR系列的相关概念较多，暂不探讨定义这些概念的内在原因，只要能将其<strong>应用到问题中</strong>即可</p></blockquote><p><em>LR(0)分析：</em></p><ul><li><p>LR(0)相关概念</p><ul><li><p><strong>增广文法</strong>：新增开始符号，它能推导出原开始符号（ S&#39;\\rarr S ）</p><blockquote><p>增广文法让文法<strong>开始符号</strong>仅出现在一个产生式的<strong>左边</strong>，这样分析器<strong>只有一个接受状态</strong></p></blockquote></li><li><p><strong>项目</strong>：项目描述了<strong>句柄识别的状态</strong></p><ul><li><p>移进项目</p></li><li><p>待约项目</p><blockquote><p>开始符号对应的待约项目称为初始项目（ S&#39;\\rarr\\cdot S ）</p></blockquote></li><li><p>归约项目</p><blockquote><p>开始符号对应的归约项目称为接收项目（ S&#39;\\rarr S\\cdot ）</p><p>产生式 A\\rarr\\epsilon 只生成一个项目 A\\rarr\\cdot</p></blockquote></li></ul></li><li><p><strong>后继项目</strong>：同属一个产生式但圆点只差一个符号，圆点在后的是后继项目</p></li><li><p><strong>等价的项目/项目集闭包</strong>：对于一个<strong>待约</strong>项目，它的等价项目就是，以该待约项目<strong>圆点后面的符号</strong>为<strong>左部</strong>的所有产生式将圆点放在<strong>右部第一个符号前</strong>得到的项目；被等价推出的<strong>待约</strong>项目可以继续等价推出，直到不能再推出新的待约项目。这样推出的所有项目都放在一个集合中，这个集合就是<strong>项目集闭包</strong>。</p><blockquote><p>对于移进项目和归约项目，它们可以被待约项目等价推出，但不能等价推出别的项目。如果它们不能由某个待约项目等价推出，则它们没有等价项目</p></blockquote></li><li><p>项目集对应于<strong>文法符号X</strong>(包括终结符和非终结符)的<strong>后继项目集闭包</strong>（<code>GOTO(I, X)</code>函数）：项目集中<strong>圆点右紧邻符号为X</strong>的每一个项目的<strong>后继</strong>项目集闭包的并</p></li></ul></li><li><p>LR(0)自动机与分析表</p><ul><li><p>自动机的构造</p><ul><li>初始项目（ S&#39;\\rarr\\cdot S ）的<strong>项目集闭包</strong>构成<strong>状态0</strong></li><li>对于<strong>每一个现有状态</strong>，求其对于<strong>每一个文法符号(包括终结符和非终结符)<strong>的后继项目集闭包（<code>GOTO(I, X)</code>），若 <code>GOTO(I, X)</code>不为空，则将其作为一个新的状态（如果是已经存在的状态就不必当成新状态了），并生成一条当前状态指向 <code>GOTO(T, X)</code>对应状态的</strong>有向边</strong>，边上的符号为当前文法符号</li><li>循环执行2<strong>直到不再增加有向边</strong></li></ul></li><li><p>分析表的构造</p><ul><li><p>行：所有**状态；**列：ACTION列（所有终结符+结束符）和GOTO列（除了增广的非终结符）</p></li><li><p><strong>接收项目</strong>是单独在一个状态里，对应<strong>接收状态</strong>，在表中与结束符 形成表项acc</p></li><li><p>对于一个状态i（一行）</p><blockquote><p>一个状态中若既有<strong>归约项目</strong>又有其他类型的项目，则会出现冲突，这里暂不考虑</p></blockquote><ul><li>出边上是<strong>非终结符</strong>的，对应该行的<strong>GOTO表项</strong>，为有向边指向的状态编号j</li><li>出边上是<strong>终结符</strong>的，对应该行的<strong>ACTION表项</strong>，为有向边指向的状态 s_j</li><li>若<strong>没有出边</strong>，或者说状态中<strong>只有一个归约项目</strong>，则该行的ACTION表项全为 r_k （k为该归约项目对应的<strong>产生式编号</strong>）</li></ul></li></ul></li></ul></li><li><p>LR(0)会有<strong>移进/归约</strong>冲突和<strong>归约/归约</strong>冲突</p><blockquote><p>总得来说，就是该不该归约的问题</p></blockquote><ul><li>对应到自动机中，就是一个状态中<strong>同时存在归约项目和其他类型项目</strong>，或者同时存在<strong>多个归约项目</strong>，导致遇到下一个输入时无法判断执行什么动作</li><li>对应到分析表中，就是ACTION列组的<strong>一个表项</strong>会有<strong>两个可选值</strong></li><li>出现问题的本质原因是，LR(0)分析没有<strong>向前查看符号</strong>，没考虑<strong>上下文环境</strong></li></ul></li></ul><hr><p><em>SLR分析：</em></p><ul><li><p>SLR分析基本思想</p><blockquote><p>S：Simple，仅通过FOLLOW集化解冲突</p></blockquote><ul><li><p>是对LR(0)分析的改进，<strong>在LR(0)分析的基础上</strong>，不是<strong>子成分</strong>都全了就能归约的，因为归约后左部符号的<strong>FOLLOW集</strong>中可能没有该输入符，也就是归约后的符号可能不是<strong>待分析句子中的一个成分</strong></p></li><li><p>当遇到LR(0)中所述冲突时，要考察两种集合(是两种，不是两个。第一种里只有一个，第二种里可以有多个)：</p><ul><li>第一种是状态中<strong>所有移进/待约项目</strong>圆点右侧符号构成的集合，</li><li>第二种是状态中所有<strong>归约项目</strong>对应产生式左部非终结符的<strong>所有FOLLOW集</strong>。</li></ul></li><li><p>当这些集合两两不相交时：</p><blockquote><p>若不能做到两两不相交，则说明SLR无法解决这种冲突</p></blockquote><ul><li>若<strong>输入符号</strong>在圆点右侧符号构成的集合中，则执行对应的移进ACTION；</li><li>若<strong>输入符号</strong>在某个归约项目左部的FOLLOW集中，则执行对应的归约ACTION。</li><li>其他情况报错</li></ul></li></ul></li><li><p>SLR自动机与分析表</p><ul><li><p>自动机的构造：与LR(0)一样的</p></li><li><p>分析表的构造：在LR(0)构造的分析表基础上，只有<strong>ACTION列的终结符(输入符号)<strong>在对应状态中归约项目左部符号的</strong>FOLLOW集</strong>中时，才进行归约，否则的话，要么是<strong>移进</strong>，要么<strong>表项为空</strong></p><blockquote><p>若这样做之后一个表项中还是会留下多个动作，则说明SLR无法解决这种冲突</p></blockquote></li></ul></li><li><p>SLR分析中的冲突</p><ul><li>上述的两种集合不能做到<strong>两两不相交</strong></li><li>本质原因是，对于归约项目，输入符号在其左部<strong>FOLLOW集</strong>中，只是能归约一个<strong>必要条件</strong>，并非充分条件</li></ul></li></ul><hr><p><em>LR(1)分析：</em></p><ul><li><p>基本思想与概念</p><ul><li><p>在LR分析的<strong>特定位置</strong>，对于非终结符A，并非FOLLOW(A)中的所有符号都可以接在A后面，所以并不是输入符在FOLLOW(A)中了就可以使用以A为左部的这条产生式进行归约，我们需要找到<strong>非终结符A在特定位置的后继符</strong></p><blockquote><p>也就是说，需要考虑程序<strong>上下文</strong>，而LR(1)就是在考虑<strong>下文的第1个符号</strong></p></blockquote></li><li><p>规范LR(1)项目： A\\rarr\\alpha\\cdot\\beta, a （第一分量,第二分量）</p><ul><li><p>第一分量：右部带圆点的产生式（就是之前对于项目的定义）</p></li><li><p>第二分量：展望符，代表当前状态下A后面可以紧跟的终结符。对于归约项目（ A\\rarr\\alpha\\cdot,a ），代表输入符号为a时才能使用该产生式归约</p><blockquote><p>对于移入项目和待约项目（ A\\rarr\\alpha\\cdot\\beta, a且\\beta\\ne\\epsilon ），<strong>展望符与之无关</strong>，但为了定义的完整，把它写出来了</p></blockquote></li></ul></li><li><p><strong>等价</strong>LR(1)项目/<strong>展望符</strong>的计算：</p><ul><li><p>第一分量：就是之前定义过的<strong>等价项目</strong></p></li><li><p>第二分量/展望符：要看等价项目产生式的<strong>左部</strong>在原项目中<strong>右边的符号(串)</strong> \\beta 。若 \\beta 能推出空（或者 \\beta 本身就是空的），则直接继承相同的展望符构成项目, 同时，对于 FIRST(\\beta) 中的每个终结符，都可以再作为<strong>展望符</strong>与相同的<strong>第一分量</strong>构成一个等价的项目</p><blockquote><p>从计算展望符的角度讲，就要从初始项目 S&#39;\\rarr\\cdot S,\\ 出发按照自动机的构造方法去计算了，移进的时候展望符不变；第一分量相同的项目，可以合并到一起写，<strong>展望符用/隔开</strong>，但要知道这是多个项目</p></blockquote></li></ul></li></ul></li><li><p>LR(1)的自动机和分析表</p><blockquote><p>相比于LR(0)，LR(1)对于CLOSURE、GOTO、项集族、自动机、分析表构造算法都做了适合于<strong>展望符与归约项目</strong>的修改</p></blockquote><ul><li><p>自动机的构造：从初始项目 S&#39;\\rarr\\cdot S,\\ 开始，与LR(0)的生成规则类似，只是在计算项目等价的时候要考虑<strong>展望符</strong></p></li><li><p>分析表的构造：</p><ul><li><p>对于不涉及归约项目的状态，处理方法与LR(0)相同</p></li><li><p>对于涉及<strong>归约项目</strong>的状态，只有ACTION列(输入符号)是状态中归约项目的<strong>展望符</strong>时才能规约(且必须归约)</p><blockquote><p>之前构造SLR的时候，是遇到左部FOLLOW集中的符号都能规约</p></blockquote></li></ul></li></ul></li></ul><hr><p><em>LALR分析：</em></p><ul><li><p>LALR基本思想与概念</p><ul><li>LR(1)的状态过多，其中有些状态是可以合并的</li><li><strong>同心项目集</strong>（同心状态）：只保留第一分量时(重复的只留一个)，完全相同的项目集</li><li>同心项目集是可以合并成一个状态的，其实是在对<strong>展望符</strong>进行合并</li></ul></li><li><p>LALR的自动机与状态表</p><ul><li>自动机：在构造出的LR(1)自动机基础上，合并同心项目并修改边</li><li>分析表：与LR(1)的构造方法相同</li></ul></li><li><p>LALR的问题</p><ul><li><p>归约-归约冲突：同一个输入符，不知道该用状态中的哪个产生式归约了，因为它们的<strong>展望符</strong>都相同</p></li><li><p>推迟错误发现：合并同心项集后，虽然不产生冲突，但可能会<strong>推迟错误的发现</strong></p><blockquote><p>LALR分析法可能会作多余的<strong>归约动作</strong>，但绝不会作错误的<strong>移进操作</strong>。因为LALR其实是在合并展望符集合，而展望符与归约有关，与移进无关</p></blockquote></li></ul></li><li><p>LALR的特点</p><ul><li>形式上与LR(1)相同，都有<strong>展望符</strong></li><li>大小上与LR(0)/SLR相当，因为<strong>合并了状态</strong></li><li>分析能力上，SLR&lt;LALR&lt;LR。相比于SLR，LALR细化了状态；相比于LR(1)，LALR会延迟错误的发现。</li></ul></li></ul><hr><p><em>错误处理：</em></p><ul><li><p>当没有可选动作时，在符号栈中寻找上一个<strong>归约出来的非终结符</strong>，然后丢弃输入符号直至当前输入在该非终结符的FOLLOW集中，然后移进该输入，再压入一个与该非终结符平等的状态，继续分析</p><blockquote><p>本质上是找到上一次正确归约的语法分成，跳过当前出错的语法成分，继续分析下一个语法成分</p></blockquote></li></ul><h2 id="_5-语法制导翻译" tabindex="-1"><a class="header-anchor" href="#_5-语法制导翻译" aria-hidden="true">#</a> 5 语法制导翻译</h2><blockquote><p>对产生式的理解：在编译原理中，产生式往往有着具体到代码层面<strong>实际意义</strong>，产生式的<strong>结构/应用场景</strong>决定了其在翻译过程中的实际意义</p><p>对语义分析的理解：语法分析中用产生式进行推导/规约，其实就是在<strong>分析语法结构</strong>，找到结构后就要做<strong>翻译动作</strong>，进行一些<strong>静态语义检查</strong>和<strong>中间代码生成</strong></p></blockquote><h3 id="_5-1-相关概念与基本思想" tabindex="-1"><a class="header-anchor" href="#_5-1-相关概念与基本思想" aria-hidden="true">#</a> 5.1 相关概念与基本思想</h3><ul><li><p>概念：将<strong>静态语义检查</strong>和<strong>中间代码生成</strong>结合到语法分析中进行的技术称为<strong>语法制导翻译</strong></p></li><li><p>基本思想：语法制导翻译的基本思想是，用<strong>产生式</strong>代表<strong>语法规则</strong>，再为产生式关联<strong>语义规则</strong>，在<strong>构造语法分析树</strong>时通过语义规则<strong>计算语义属性值或执行某些动作</strong></p></li><li><p>语法制导定义SDD：</p><blockquote><p>对上下文无关文法的推广</p></blockquote><ul><li><p><strong>语义属性</strong>：为每个文法符号设置若干<strong>语义属性</strong></p><ul><li><p><strong>语义属性的作用</strong>：在推导/规约过程中<strong>传递信息</strong></p><blockquote><p>不传递的话之后要用就找不到了</p></blockquote></li></ul></li><li><p><strong>语义规则</strong>：为每条产生式关联若干<strong>语义规则</strong>，语义规则用于<strong>计算语义属性值</strong></p></li></ul></li><li><p>语法制导翻译方案SDT：</p><ul><li><p><strong>语义动作</strong>：在SDD的基础上，直接<strong>将语义规则嵌入产生式右部</strong>，称为<strong>语义动作</strong></p><blockquote><p>将<strong>属性值计算</strong>的工作解耦给<strong>语义动作</strong></p></blockquote><ul><li><strong>语义动作的执行：<strong>在产生式中的</strong>位置</strong>决定了其<strong>执行时间</strong></li></ul></li><li><p><strong>SDT与SDD的关系</strong>：SDT可以看作是SDD的<strong>具体实施方案</strong>，有SDT就能按照一定的<strong>工作流程</strong>计算所有语义属性值</p><blockquote><p>SDT通用的实现方法：首先建立一棵<strong>语法分析树</strong>，然后按照<strong>从左到右的深度优先顺序</strong>来执行这些动作</p></blockquote></li></ul></li></ul><h3 id="_5-2-语法制导定义" tabindex="-1"><a class="header-anchor" href="#_5-2-语法制导定义" aria-hidden="true">#</a> 5.2 语法制导定义</h3><ul><li><p>文法符号的属性：</p><ul><li><strong>综合属性</strong>： <ul><li>非终结符的综合属性：只能通过<strong>子结点</strong>或其本身的属性值定义</li><li>终结符的综合属性/<strong>固有属性</strong>：由词法分析器提供的词法值（<strong>token属性值</strong>）</li></ul></li><li><strong>继承属性</strong>： <ul><li>非终结符的综合属性：只能通过<strong>父结点、兄弟结点</strong>或其本身的属性值定义</li><li>终结符没有继承属性</li></ul></li></ul></li><li><p>副作用与属性文法：</p><ul><li><p><strong>副作用</strong>：有的语义规则目的是产生<strong>副作用</strong>，用到其他结点的属性值，但不计算新的属性值，可以理解成在计算<strong>虚属性</strong></p><blockquote><p>比如打印、在符号表中创建记录并设置类型等等</p></blockquote></li><li><p><strong>属性文法</strong>：没有副作用的SDD称为<strong>属性文法</strong>，仅通过其他属性值和常量定义属性值</p></li></ul></li><li><p>属性求值方法：</p><ul><li>属性求值遵循的顺序：<strong>依赖图的拓扑排序</strong></li><li>依赖图：依赖图是描述分析树<strong>结点属性的依赖关系</strong>的有向图，以语法分析树为基础图，若结点X有属性a，则将a也作为依赖图中的结点（画在X旁边）；若属性X.a的值计算依赖于Y.b，则添加一条Y.b指向X.a的有向边；如果有“虚属性”，也可以画在结点旁边。</li><li>求值的可行性：一个SDD不一定存在可行的求值顺序，有可能发生<strong>循环依赖</strong></li></ul></li><li><p>属性定义：</p><ul><li><p>SDD的有用子类，一定存在一个<strong>求值顺序</strong></p></li><li><p><strong>S-属性定义/S-属性文法/S属性的SDD</strong>：只具有<strong>综合属性</strong>的SDD</p><ul><li>属性求值方法：S-SDD可以按照语法分析树<strong>自底向上</strong>的顺序计算各属性值</li><li>在语法分析中的实现：S-SDD可以<strong>在自底向上的语法分析</strong>中实现</li></ul></li><li><p><strong>L-属性定义/L-属性文法/L属性的SDD</strong>：每个属性要么是<strong>综合属性</strong>，要么是只依赖 <strong>父结点继承</strong>属性、<strong>左兄弟</strong>结点属性、<strong>本身</strong>属性 的<strong>继承属性</strong>（但本身的属性不能形成<strong>环路</strong>）</p><blockquote><p>语法分析均为<strong>最左推导或最左归约</strong>，所以要求<strong>左兄弟</strong></p></blockquote><ul><li>属性求值方法：从左到右遍历子结点，在遍历到符号前，计算其<strong>继承属性</strong>，遍历结束后计算父节点<strong>综合属性</strong></li></ul></li></ul></li></ul><h3 id="_5-3-语法制导翻译方案" tabindex="-1"><a class="header-anchor" href="#_5-3-语法制导翻译方案" aria-hidden="true">#</a> 5.3 语法制导翻译方案</h3><ul><li><p>基本思想</p><ul><li>语法制导翻译方案也叫<strong>翻译模式</strong>，给出了使用语义规则进行计算的<strong>顺序</strong></li></ul></li><li><p>SDD向SDT的转换</p><ul><li>S-SDD转换为SDT： <ul><li>将每个语义动作都放在<strong>产生式右部的最右端</strong>，代表在<strong>规约</strong>时计算属性值</li><li>如果S-SDD的<strong>基本文法</strong>可以使用LR分析技术，那它的SDT就可以在LR分析过程中实现</li></ul></li><li>L-SDD转换为SDT： <ul><li>计算产生式左部符号<strong>综合属性</strong>的语义动作放在<strong>产生式右部的最右端</strong></li><li>计算产生式右部非终结符<strong>继承属性</strong>的语义动作插入<strong>非终结符紧邻左边</strong></li></ul></li></ul></li><li><p>S-SDD的自底向上翻译</p><ul><li>扩展LR语法<strong>分析栈</strong>：在分析栈中附加一个域存储<strong>综合属性</strong>（值或指针），与文法符号平行（语义栈）</li><li>分析栈的工作：在<strong>规约</strong>时执行语义动作，找到栈中对应位置的依赖，计算属性值，存入附加域</li></ul></li><li><p>S-SDD的预测分析翻译</p><ul><li><p>文法改造</p><ul><li><p>消除左递归</p><ul><li><p>先消除左递归，再添加语义规则</p></li><li><p>先添加语义规则，再消除左递归，并<strong>添加新的语义规则</strong></p><blockquote><p>这就需要引入<strong>继承属性</strong>并插入<strong>语义动作</strong>，传递信息</p></blockquote></li></ul></li></ul></li><li><p>其他部分与L-SDD的翻译一致</p></li></ul></li><li><p>L-SDD的预测分析翻译</p><ul><li><p>文法改造</p></li><li><p>扩展预测分析栈</p><ul><li>继承属性在即将出现时计算，存放在**与非终结符平行的记录 <code>A</code>**中（横向扩展、语义栈）</li><li>综合属性在子结点分析完后计算，**新增一条综合记录 <code>Asyn</code>**存放（纵向扩展）</li><li>增加一种<strong>动作记录 <code>action</code></strong>，指向要执行的动作（纵向扩展）</li></ul></li><li><p>分析栈的工作</p><ul><li><p>依然按照右部<strong>从右向左</strong>的顺序入栈，<strong>综合记录 <code>syn</code>先</strong>于本身记录入栈，动作记录 <code>action</code>同样按照所处位置入栈</p><blockquote><p>往往会给语义动作对应的动作记录取一个简洁的<strong>别名</strong></p></blockquote></li><li><p>栈内元素的出栈行为：</p><ul><li><p>栈顶为<strong>动作记录</strong>时，直接出栈并执行对应动作；</p></li><li><p>栈顶为<strong>综合记录</strong>时，直接出栈并将<strong>综合属性值传递</strong>给栈内的特定语义动作；</p></li><li><p><strong>变量本身记录</strong>出栈时，若有继承属性，则要将<strong>继承属性值传递</strong>给入栈的特定语义动作；</p></li><li><p><strong>终结符</strong>出栈时要将<strong>综合属性值</strong>传递给栈中的特定语义动作</p><blockquote><p>这里的“传递”具体到程序上就是 <code>stack[top+-n].xxx=stack[top].xxx, top=top+-n</code>，其中 <code>top+-n</code>对应了语义动作出现的位置</p></blockquote></li></ul></li><li><p><strong>综合属性</strong>的计算：综合属性在对应产生式右部<strong>最右端语义动作出栈</strong>时计算</p></li><li><p><strong>继承属性</strong>的计算：变量本身记录的继承属性在对应产生式<strong>紧邻左边动作出栈</strong>时计算</p><blockquote><p>这里的“计算”具体到程序上，也是给 <code>stk[top+-n]</code>赋值，涉及到一些计算，其中 <code>top+-n</code>对应了综合记录或变量本身记录出现的位置</p></blockquote></li></ul></li></ul></li><li><p>L-SDD的递归下降分析翻译</p><ul><li><p>文法改造</p></li><li><p>在<strong>递归下降分析</strong>基础上，将非终结符的过程扩展为<strong>函数</strong>，参数为左部的<strong>继承属性</strong>，返回值为左部的<strong>综合属性</strong></p><blockquote><p>递归的预测分析中过程调用的框架在这里要沿用</p></blockquote></li><li><p>对右部符号的每个属性都设置<strong>局部变量</strong></p><blockquote><p>函数返回值由综合属性的局部变量接收</p></blockquote></li><li><p>将每个<strong>语义动作</strong>的代码依次加入函数体，使用对应的变量书写其动作逻辑</p><ul><li><p>继承属性局部变量的计算：按照<strong>语义动作</strong>计算并赋值给对应局部变量</p></li><li><p>综合属性局部变量的计算：调用非终结符对应的函数</p><blockquote><p>终结符的话直接从token中取值</p></blockquote></li></ul></li></ul></li><li><p>L-SDD的自底向上翻译</p><ul><li><p><strong>修改文法</strong>以适应自底向上</p><ul><li><p>用各个“<strong>标记非终结符</strong>”替换<strong>内嵌</strong>的各个<strong>语义动作</strong>，每个标记非终结符都对应一条空产生式</p></li><li><p>标记非终结符的空产生式最右端添加新语义动作</p><ul><li><p>将原动作依赖的属性作为<strong>标记非终结符的继承属性</strong></p></li><li><p>将原动作要计算的属性作为<strong>标记非终结符的综合属性</strong>来计算</p><blockquote><p>可以证明，如果一个文法是LL的，那么标记非终结符可以插入到产生式的任何位置，并且得到的文法是LR文法</p></blockquote></li></ul></li></ul></li><li><p>分析栈的工作</p><ul><li>与S-SDD基本一致，原继承属性的计算变成了<strong>对标记非终结符综合属性的计算</strong></li><li>计算标记非终结符时，要结合原产生式和继承属性的实际情况确定依赖位置和计算方式</li></ul></li></ul></li></ul><h2 id="_6-语义分析与中间代码生成" tabindex="-1"><a class="header-anchor" href="#_6-语义分析与中间代码生成" aria-hidden="true">#</a> 6 语义分析与中间代码生成</h2><blockquote><p>这一小节十分需要用具体的例子辅助理解，详见编译原理随堂笔记仓库</p></blockquote><h3 id="_6-0-中间代码的表示形式" tabindex="-1"><a class="header-anchor" href="#_6-0-中间代码的表示形式" aria-hidden="true">#</a> 6.0 中间代码的表示形式</h3><ul><li><p>逆波兰表示</p></li><li><p>三地址码</p><ul><li><p>定义： 每条指令最多只能包含<strong>三个地址</strong>， 两个操作数地址和一个结果地址</p></li><li><p>指令类型</p><ul><li><p>算术与赋值：<code>x := y op z</code>、<code>x[i] := y[j]</code>、<code>*x := &amp;y</code></p><blockquote><p><strong>多维数组</strong>需要计算出<strong>一维下标</strong></p></blockquote></li><li><p>跳转</p><ul><li>无条件跳转：<code>goto L</code></li><li>条件跳转：<code>if x relop y goto L</code>、<code>if x goto L</code></li></ul></li><li><p>过程调用与返回</p><ul><li>指明参数：<code>param x</code></li><li>过程调用：<code>y = call p, n</code></li><li>返回：<code>return y</code></li></ul></li></ul></li><li><p>表示形式：四元式</p></li></ul></li></ul><h3 id="_6-1-声明语句的翻译" tabindex="-1"><a class="header-anchor" href="#_6-1-声明语句的翻译" aria-hidden="true">#</a> 6.1 声明语句的翻译</h3><p><em>主要任务/语义动作的主要内容：</em></p><ul><li><p>类型：通过<strong>类型表达式</strong>，收集<strong>标识符类型</strong>等属性信息</p><ul><li>类型检查</li><li>辅助翻译</li></ul></li><li><p>宽度和相对地址：由类型表达式计算<strong>宽度</strong>，从而为每个标识符分配一个<strong>相对地址</strong></p></li><li><p>符号表：将标识符类型和相对地址等信息保存至对应<strong>符号表</strong>。如果是嵌套声明，还要正确构建内层与外层符号表的访问链。</p></li></ul><hr><p><em>类型表达式(Type Expreessions)：</em></p><ul><li><p><strong>基本类型</strong>是一种类型表达式，常见基本类型有：</p><ul><li><code>integer real char boolean type_error void</code></li></ul></li><li><p>可以给类型表达式命名，<strong>类型名</strong>也是一种类型表达式</p></li><li><p><strong>类型构造符</strong>作用于类型表达式可以构成新的类型表达式</p><ul><li><p>数组构造符 <code>array(elem_num, type)</code></p><blockquote><p>举例：<code>int[2][3]</code>对应于 <code>array(2, array(3, int))</code></p></blockquote></li><li><p>指针构造符 <code>pointer(type)</code></p></li><li><p>笛卡尔乘积构造符 \\times ：<code>T1 × T2</code></p></li><li><p>函数构造符 \\rarr ：<code>T1 × T2 × ... × Tn → R</code></p><ul><li><code>Ti</code>是类型表达式，相当于参数</li><li><code>R</code>也是类型表达式，相当于返回值</li></ul></li><li><p>记录构造符 <code>record((N1×T1), (N2×T2), ..., (Nn×Tn))</code></p><ul><li><code>Ni</code>是标识符</li><li><code>Ti</code>是类型表达式</li></ul></li></ul></li><li><p>类型的<strong>结构等价</strong></p><ul><li><em>T</em>(1)和<em>T</em>(2)是相同的基本类型</li><li><em>T</em>(1)和<em>T</em>(2)是将同一类型构造符应用于结构等价的类型上形成的</li><li><em>T</em>(1)是表示<em>T</em>(2)的类型名</li></ul></li></ul><hr><p><em>声明语句的SDT：</em></p><ul><li><p>文法符号与综合属性</p><ul><li><p><code>P</code>：开始符号</p></li><li><p><code>D</code>：声明语句</p></li><li><p><code>T</code>：标识符类型</p><ul><li><code>T.type</code>：类型表达式</li><li><code>T.width</code>：类型宽度</li></ul></li><li><p><code>B</code>：基本类型</p><ul><li><code>B.type</code>：基本类型</li><li><code>B.width</code>：基本类型宽度</li></ul></li><li><p><code>C</code>：数组标志</p><ul><li><code>C.type</code>：数组类型</li><li><code>C.width</code>：数组类型宽度</li></ul></li><li><p><code>id</code>：标识符</p><ul><li><p><code>id.lexeme</code>：构成标识符的字符序列</p><blockquote><p>是词法分析器提供的词法值</p></blockquote></li></ul></li><li><p><code>num</code>：整数的正则定义</p><ul><li><code>num.val</code>：整数值</li></ul></li><li><p><code>int</code>：整型</p></li><li><p><code>real</code>：实型</p></li><li><p><code>↑</code>：指针标志</p></li></ul></li><li><p>特殊变量</p><ul><li><p><code>offset</code>：下一个可用的<strong>相对地址</strong>，有初始值，可设为0</p></li><li><p><code>t</code>和 <code>w</code>：将<strong>类型和宽度信息</strong>从语法分析树的B结点传递到产生式</p><p>C\\rarr\\epsilon</p><p>对应的结点</p><blockquote><p>这里把类型看成由<strong>基本类型+数组标志组成</strong>，所以这两部分之间需要传递信息。如果把类型看成<strong>基本类型或数组类型两类</strong>，就不需要这样传递了</p></blockquote></li></ul></li></ul><p>​</p>`,146),u=l("ul",null,[l("li",null,[l("p",null,"副作用"),l("ul",null,[l("li",null,[l("code",null,"enter(name, type, offset)"),n("：在符号表中为标识符 "),l("code",null,"name"),n("创建记录，将 "),l("code",null,"name"),n("的类型设置为 "),l("code",null,"type"),n("，相对地址设置为 "),l("code",null,"offset")])])]),l("li",null,[l("p",null,"语法规则和语义动作(推导角度)"),l("ul",null,[l("li",null,[l("p",null,"开始： P\\rarr{a_1}D"),l("p",{"align*":""},"\\begin{align*} &a_1:{\\ &~~~~offset=0\\ &} \\end"),l("blockquote",null,[l("p",null,[n("程序形成前要将 "),l("code",null,"offset"),n("置为初始值")])])]),l("li",null,[l("p",null,[l("strong",null,"声明语句"),n("的生成：")]),l("ul",null,[l("li",null,"D\\rarr T~id;{a_1}D")]),l("p",{"align*":""},[n("\\begin{align*} &a_1:{\\ &~~~~enter(id.lexem,"),l("sub",null,"T.type,"),n("offset);\\ &~~~~offset=offset+T.width;\\ &} \\end")]),l("blockquote",null,[l("p",null,[n("声明语句形成后在"),l("strong",null,"符号表"),n("创建记录，并后移 "),l("code",null,"offset")])]),l("ul",null,[l("li",null,"D\\rarr\\epsilon")])]),l("li",null,[l("p",null,[l("strong",null,"标识符类型"),n("的形成：")]),l("ul",null,[l("li",null,"T\\rarr B{a_1}C{a_2}")]),l("p",{"align*":""},"\\begin{align*} &a_1:{\\ &~~~~t=B.type;\\ &~~~~w=B.width;\\ &}\\ &a_2:{\\ &~~~~T.type=C.type;\\ &~~~~T.width=C.width;\\ &} \\end"),l("blockquote",null,[l("p",null,[l("strong",null,"基本类型"),n("形成后用 "),l("code",null,"t"),n("和 "),l("code",null,"w"),n("记录"),l("strong",null,"类型和宽度"),n("，以便向后传递；")]),l("p",null,[l("strong",null,"标识符类型"),n("形成后要设置"),l("strong",null,"类型表达式和宽度")])]),l("blockquote",null,[l("p",null,"另一种方案(归约角度)："),l("ul",null,[l("li",null,[l("code",null,"T -> int {T.type = int, T.width = 4}")]),l("li",null,[l("code",null,"T -> real {T.type = real, T.width = 8}")]),l("li",null,[l("code",null,"T -> array[num] of T1 {T.type = array(num.val, T1.type); T.width = num.val * T1.width}")])])]),l("ul",null,[l("li",null,[l("p",null,"T\\rarr\\uarr T_1{a_1}"),l("p",{"align*":""},"\\begin{align*} &a_1:{\\ &~~~~T.type=pointer(T_1.type);\\ &~~~~T.width=4;\\ &} \\end"),l("blockquote",null,[l("p",null,[n("形成指针后要设置其"),l("strong",null,"类型和宽度")])])])]),l("blockquote")]),l("li",null,[l("p",null,[l("strong",null,"基本类型"),n("的形成：")]),l("ul",null,[l("li",null,"B\\rarr int{a_1}")]),l("p",{"align*":""},"\\begin{align*} &a_1:{\\ &~~~~B.type=int;\\ &~~~~B.width=4;\\ &} \\end"),l("blockquote",null,[l("p",null,"形成整型后要记录其类型和宽度")]),l("ul",null,[l("li",null,[l("p",null,"B\\rarr real{a_1}"),l("p",{"align*":""},"\\begin{align*} &a_1:{\\ &~~~~B.type=real;\\ &~~~~B.width=8;\\ &} \\end"),l("blockquote",null,[l("p",null,"形成实型后要设置其类型和宽度")])])]),l("blockquote")]),l("li",null,[l("p",null,[l("strong",null,"数组标志"),n("的形成：")]),l("ul",null,[l("li",null,"C\\rarr\\epsilon{a_1}")]),l("p",{"align*":""},"\\begin{align*} &a_1:{\\ &~~~~C.type=t;\\ &~~~~C.width=w;\\ &} \\end"),l("blockquote",null,[l("p",null,[n("数组标志结束后要从 "),l("code",null,"t"),n("和 "),l("code",null,"w"),n("中读取信息，以便后续"),l("strong",null,"数组类型和宽度"),n("的计算")])]),l("ul",null,[l("li",null,[l("p",null,"C\\rarr[num]C_1{a_1}"),l("p",null,[n("\\begin{align*} &a_1:{\\ &~~~~C.type=array(num.val,C_1.type);\\ &~~~~C.width=num.val"),l("em",null,"C_1.width;\\ &} \\end{align"),n("}")]),l("blockquote",null,[l("p",null,[n("形成数组标志时要用"),l("strong",null,"数组构造符"),n("其设置类型并"),l("strong",null,"计算宽度")])])])]),l("blockquote")])])])],-1),g=o(`<hr><p><em>嵌套过程声明语句的SDT：</em></p><ul><li><p>特殊变量</p><ul><li><code>tbptr</code>：保存嵌套声明的<strong>外层符号表</strong>的栈</li><li><code>offset</code>：保存嵌套声明的<strong>外层偏移量</strong>的栈</li></ul></li><li><p>副作用</p><ul><li><code>maketable(previous)</code>：创建一个<strong>新的符号表，访问链</strong>指向 <code>previous</code></li><li><code>enter(table, name, type, offset)</code>：向指定符号表中添加变量记录</li><li><code>addwidth(table, width)</code>：将<strong>符号表大小</strong>记录在表头上</li><li><code>enterproc(table, name, newtable)</code>：在 <code>table</code>中为 <code>name</code>建立表项，指向 <code>newtable</code></li></ul></li><li><p>语法规则和语义动作</p><ul><li><p>开始/程序声明：<code>P -&gt; prog id (input,output) M D; S {a}</code></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>M: {
    t := mktable(nil);
    push(t, tbptl);
    push(0, offset);
}
a: {
    addwidth(top(tblptr), top(offset));
    pop(tblptr);
    pop(offset);
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>program形成前，创建根符号表；program形成后，记录宽度于表头，出栈</p></blockquote></li><li><p>声明语句</p><ul><li><p><code>D -&gt; D; D</code></p></li><li><p><code>D -&gt; proc id N D; S {a}</code></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>N: {
    t = mktbl(top(tbptr));
    push(t, tbptl);
    push(0, offset);
}
a: {
    t := top(tblptr);
    addwidth(t, top(offset));
    pop(tblptr);pop(offset);
    enterproc(top(tblptr), id.name, t);
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>procedure形成前，创建子符号表，指向父表；procedure形成后，记录宽度于表头，出栈，父表添加指向子表的记录</p></blockquote></li><li><p><code>D -&gt; id : T {a}</code></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>a: {
    enter(top(tbptr), id.name, T.type, top(offset));
    top(offset) += T.width
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul></li></ul></li></ul><hr><p><em>结构体声明语句的SDT：</em></p><blockquote><p>为记录类型单独构造一个符号表，也可以类似过程那样嵌套</p></blockquote><ul><li><p><code>T -&gt; record M D end {a}</code></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>M: {
    t = mktbl(nil);
    push(t, tblptr);
    push(0, offset);
}
a: {
    T.type = record(top(tblptr)):
    T.width = top(offset);
    pop(tblptr);
    pop(offset);
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><h3 id="_6-2-简单赋值和运算语句的翻译" tabindex="-1"><a class="header-anchor" href="#_6-2-简单赋值和运算语句的翻译" aria-hidden="true">#</a> 6.2 简单赋值和运算语句的翻译</h3><p><em>主要任务：</em></p><ul><li><p>生成<strong>对表达式求值</strong>的三地址码</p><blockquote><p>三地址码中地址不直接参与运算，而是<strong>存放在所指向地址的值参与运算</strong></p><p>例如下文中经常出现的 <code>E.addr</code>，如果放到运算表达式中，其实代表的是存放在所指向地址的值</p></blockquote></li><li><p>正确处理<strong>数组元素</strong>等复杂表达式，将多维数组形式转换成<strong>一维下标索引</strong></p><blockquote><p>对于<strong>数组元素</strong>要计算其<strong>地址索引</strong>：</p><ul><li>addr(a[i_1][i_2]...[i_k])=base+i_1\\times w_1+i_2\\times w_2+...+i_k\\times w_k</li><li><code>a[i1, i2, i3, i4, ...]</code>相当于 <code>a[w*(...(i1*n2+i2)*n3+i3)*n4+i4)...)]</code></li></ul></blockquote></li><li><p>符号表：检查变量是否已经<strong>声明</strong></p></li></ul><hr><p><em>简单赋值和运算语句的SDT：</em></p>`,12),a=l("ul",null,[l("li",null,[l("p",null,"文法符号与综合属性"),l("ul",null,[l("li",null,[l("code",null,"S"),l("strong",null,"：开始"),n("符号，代表一个"),l("strong",null,"代码块"),l("ul",null,[l("li",null,[l("code",null,"S.code"),n("：存放代码块的所有"),l("strong",null,"三地址码")])])]),l("li",null,[l("code",null,"E"),n("：表达式 "),l("ul",null,[l("li",null,[l("code",null,"E.code"),n("：存放"),l("strong",null,"表达式之间赋值"),n("的三地址码")]),l("li",null,[l("code",null,"E.addr"),n("：表达式"),l("strong",null,"值的存放地址")])])]),l("li",null,[l("code",null,"id"),n("：标识符 "),l("ul",null,[l("li",null,[l("code",null,"id.lexeme"),n("：构成标识符的字符序列")])])]),l("li",null,[l("code",null,"L"),n("："),l("strong",null,"数组元素"),l("ul",null,[l("li",null,[l("code",null,"L.type"),n("：数组元素的"),l("strong",null,"类型")]),l("li",null,[l("code",null,"L.offset"),n("：数组元素的"),l("strong",null,"地址偏移量")]),l("li",null,[l("code",null,"L.array"),n("：数组"),l("strong",null,"入口地址"),n("，也是数组标识符在符号表中记录的地址")])])])])]),l("li",null,[l("p",null,"副作用"),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"lookup(lexeme)"),n("：查询符号表中"),l("strong",null,"标识符"),n("指向的"),l("strong",null,"地址")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"lookup(id.lexeme).type.elem"),n("：（如果 "),l("code",null,"id"),n("是数组标识符）数组元素"),l("strong",null,"类型")])]),l("li",null,[l("p",null,[l("code",null,"lookup(id.lexeme).type.elem.width"),n("：数组元素"),l("strong",null,"类型的宽度")]),l("blockquote",null,[l("p",null,[n("数组相关信息会提前存放至"),l("strong",null,"内情向量表"),n("中")])])])])]),l("li",null,[l("p",null,[l("code",null,"newtemp()"),n("：生成"),l("strong",null,"临时变量"),n("并返回其地址")]),l("blockquote",null,[l("p",null,[n("这里虽然叫做“临时变量”，但这个变量依然会被写进"),l("strong",null,"三地址码"),n("中，只是在逻辑上起"),l("strong",null,"临时记录值"),n("的作用。")]),l("p",null,"临时变量对优化有利，但过多的临时变量会增加符号表负担和运行时存储空间。"),l("p",null,[n("可以基于临时变量的生存期"),l("strong",null,"动态申请并释放临时变量")])])]),l("li",null,[l("p",null,[l("code",null,"gen(code)"),n("：生成新的"),l("strong",null,"三地址码"),n("（并拼接已生成的三地址码，赋值给综合属性）")]),l("blockquote",null,[l("p",null,[n("⭐️增量翻译：在语义动作中简化类似 "),l("code",null,"E.code=E1.code||E2.code||gen(xxx)"),n("的代码，直接写成 "),l("code",null,"gen(xxx)"),n("，这样代表了"),l("strong",null,"生成三地址码"),n("后自动将子结点的 "),l("code",null,"code"),n("属性与之"),l("strong",null,"顺序拼接"),n("并赋值给父节点的 "),l("code",null,"code"),n("属性")])])])])]),l("li",null,[l("p",null,"语法规则和语义动作（归约角度理解）"),l("ul",null,[l("li",null,[l("p",null,[n("文法开始/"),l("strong",null,"完整赋值语句"),n("的形成：")]),l("ul",null,[l("li",null,"S\\rarr id=E;{a_1}")]),l("p",{"align*":""},[n("\\begin{align*} &a_1:{\\ &~~~~p=lookup(id.lexeme);\\ &~~~~if"),l("sub",null,"p==nil"),n("then~error;\\ &~~~~gen(p=E.addr);\\ &} \\end")]),l("blockquote",null,[l("p",null,[n("形成"),l("strong",null,"单一标识符"),n("赋值语句时，检查是否已经声明，并生成"),l("strong",null,"标识符赋值"),n("的三地址码")])]),l("ul",null,[l("li",null,[l("p",null,"S\\rarr L=E;{a_1}"),l("p",{"align*":""},"\\begin{align*} &a_1:{\\ &~~~~gen(L.array[L.offset]=E.addr);\\ &} \\end"),l("blockquote",null,[l("p",null,[n("形成"),l("strong",null,"数组元素"),n("赋值语句时生成"),l("strong",null,"元素地址索引并给其赋值"),n("的三地址码")])])])]),l("blockquote")]),l("li",null,[l("p",null,[l("strong",null,"算术表达式"),n("的形成")]),l("ul",null,[l("li",null,"E\\rarr E_1+E_2{a_1}")]),l("p",{"align*":""},"\\begin{align*} &a_1:{\\ &~~~~E.addr=newtemp();\\ &~~~~gen(E.addr=E_1.addr+E_2.addr);\\ &} \\end"),l("blockquote",null,[l("p",null,[n("形成加法运算表达式时生成用"),l("strong",null,"临时变量存放运算结果"),n("的三地址码")])]),l("ul",null,[l("li",null,"E\\rarr E_1*E_2{a_1}")]),l("p",null,[n("\\begin{align*} &a_1:{\\ &~~~~E.addr=newtemp();\\ &~~~~gen(E.addr=E_1.addr"),l("em",null,"E_2.addr);\\ &} \\end{align"),n("}")]),l("blockquote",null,[l("p",null,[n("形成乘法运算表达式时生成用"),l("strong",null,"临时变量存放运算结果"),n("的三地址码")])]),l("ul",null,[l("li",null,"E\\rarr-E_1{a_1}")]),l("p",{"align*":""},"\\begin{align*} &a_1:{\\ &~~~~E.addr=newtemp();\\ &~~~~gen(E.addr=uminus~E_1.addrr);\\ &} \\end"),l("blockquote",null,[l("p",null,[n("形成取相反数运算表达式时生成用"),l("strong",null,"临时变量存放运算结果"),n("的三地址码")])]),l("ul",null,[l("li",null,"E\\rarr(E_1){a_1}")]),l("p",{"align*":""},"\\begin{align*} &a_1:{\\ &~~~~E.addr=E_1.addr;\\ &} \\end"),l("blockquote",null,[l("p",null,"形成括号运算表达式时传递变量地址")]),l("ul",null,[l("li",null,"E\\rarr id{a_1}")]),l("p",{"align*":""},[n("\\begin{align*} &a_1:{\\ &~~~~E.addr=lookup(id.lexeme);\\ &~~~~if"),l("sub",null,"E.addr==nil"),n("then~error;\\ &} \\end")]),l("blockquote",null,[l("p",null,[n("由标识符形成表达式时要检查是否"),l("strong",null,"声明"),n("并"),l("strong",null,"记录标识符地址")])])]),l("li",null,[l("p",null,[l("strong",null,"数组元素表达式"),n("的形成")]),l("ul",null,[l("li",null,"E\\rarr L{a_1}")]),l("p",{"align*":""},"\\begin{align*} &a_1:{\\ &~~~~E.addr=newtemp();\\ &~~~~gen(E.addr=L.array[L.offset]);\\ &} \\end"),l("blockquote",null,[l("p",null,[n("形成"),l("strong",null,"完整数组元素表达式"),n("时生成用"),l("strong",null,"临时变量存放数组元素地址索引"),n("的三地址码")])]),l("ul",null,[l("li",null,"L\\rarr id[E]{a_1}")]),l("p",null,[n("\\begin{align*} &a_1:{\\ &~~~~L.array=lookup(id.lexeme);\\ &~~~~if"),l("sub",null,"L.array==nil"),n("then~error;\\ &~~~~L.type=L.array.type.elem;\\ &~~~~L.offset=newtemp();\\ &~~~~gen(L.offset=E.addr"),l("em",null,"L.type.width);\\ } \\end{align"),n("}")]),l("blockquote",null,[l("p",null,[n("确定数组"),l("strong",null,"标识符"),n("后，传递"),l("strong",null,"数组名"),n("、数组元素"),l("strong",null,"类型"),n("，计算数组元素"),l("strong",null,"偏移量"),n("，并生成 用类型"),l("strong",null,"宽度"),n("和表达式值计算"),l("strong",null,"偏移量"),n(" 的三地址码")])]),l("ul",null,[l("li",null,"L\\rarr L_1[E]{a_1}")]),l("p",null,[n("\\begin{align*} &a_1:{\\ &~~~~L.array=L_1.array;\\ &~~~~L.type=L_1.type.elem;\\ &~~~~t=newtemp();\\ &~~~~gen(t=E.addr"),l("em",null,"L.type.width);\\ &~~~~L.offset=newtemp();\\ &~~~~gen(L.offset=L_1.offset+t);\\ } \\end{align"),n("}")]),l("blockquote",null,[l("p",null,[n("更高维数组元素形成时，传递"),l("strong",null,"数组名"),n("、数组"),l("strong",null,"类型"),n("，计算数组元素偏移量，生成 借助"),l("strong",null,"临时变量"),n("计算"),l("strong",null,"更深维度偏移量"),n(" 的三地址码")])])])])])],-1),p=o(`<hr><p><em>数组元素的另一种SDT：</em></p><ul><li><p>文法符号与综合属性</p><ul><li><code>L.addr</code>：数组<strong>基址</strong></li><li><code>L.offset</code>：数组元素<strong>偏移量</strong></li><li><code>Elist.array</code>： 指向符号表中<strong>数组名表项</strong></li><li><code>Elist.ndim</code>： Elist中下标表达式的个数， 即<strong>数组当前维数</strong></li><li><code>Elist.addr</code>： 存放下标表达式计算出来的值</li></ul></li><li><p>副作用</p><ul><li><p><code>limit(array, j)</code>：返回 <code>nj</code></p><blockquote><p>代表第 <code>j</code>维的宽度，可以从数组的<strong>内情向量表</strong>中获取</p></blockquote></li></ul></li><li><p>语法规则和语义动作（归约的角度）</p><ul><li><p><code>L -&gt; id {a}</code></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>a: {
    L.addr = id.addr;
    L.offset = null;
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><code>Elist -&gt; id[E {a}</code></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>a: {
    Elist.addr = E.addr;
    Elist.ndim = 1;
    Elist.array = id.addr;
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>数组元素刚开始形成时，记录<strong>下标值、维度、标识符</strong></p></blockquote></li><li><p><code>Elist -&gt; Elist1, E {a}</code></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>a: {
    t = newtmp;
    m = Elist1.ndim + 1;
    gencode(t = Elist1.addr * limit(Elist1.array, m));
    gencode(t = t + E.addr);
    Elist.array = Elist1.array;
    Elist.addr = t;
    Elist.ndim = m;
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>生成临时变量计算<strong>深一维度的偏移量</strong>，传递<strong>下标值</strong>、<strong>维度</strong>、<strong>标识符</strong></p><p><code>a[i1, i2, i3, i4, ...]</code></p><p><code>a[w*(...(i1*n2+i2)*n3+i3)*n4+i4)...)]</code></p></blockquote></li><li><p><code>L -&gt; Elist] {a}</code></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>a: {
    L.addr = newtmp;
    L.offset = newtmp;
    gencode(L.addr = base(Elist.array)-invariant(Elist.array));
    gencode(L.offset = Elist.addr * w)
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>数组元素标志形成结束后，计算最终的<strong>数组基址</strong>和<strong>偏移量</strong></p></blockquote></li></ul></li></ul><h3 id="_6-3-布尔表达式的翻译" tabindex="-1"><a class="header-anchor" href="#_6-3-布尔表达式的翻译" aria-hidden="true">#</a> 6.3 布尔表达式的翻译</h3><p><em>主要任务：</em></p><ul><li>对布尔表达式进行求值（数值表示法）</li><li>处理布尔表达式在不同逻辑值下的<strong>跳转</strong>（真假出口表示法）</li></ul><hr><p><em>布尔表达式的SDT：</em></p>`,8),d=l("ul",{"align*":""},[l("li",null,[l("p",null,"文法符号与属性"),l("ul",null,[l("li",null,[l("code",null,"B"),n("：布尔表达式 "),l("ul",null,[l("li",null,[l("code",null,"B.true"),n("：布尔表达式的“真”出口，也就是表达式为真时，下一条要执行的语句")]),l("li",null,[l("code",null,"B.false"),n("：布尔表达式的“假”出口，也就是表达式为假时，下一条要执行的语句")]),l("li",null,[l("code",null,"B.code"),n("：布尔表达式翻译出的三地址码")]),l("li",null,[l("code",null,"B.addr"),n("：布尔表达式的值")])])]),l("li",null,[l("code",null,"E"),n("：表达式 "),l("ul",null,[l("li",null,[n("与"),l("strong",null,"赋值语句"),n("中的一致")])])]),l("li",null,[l("code",null,"relop"),n("：关系运算符的正则定义，包括 "),l("code",null,"<, <=, >, >=, ==, !=")]),l("li",null,[l("code",null,"or、and、not")]),l("li",null,[n("优先级："),l("code",null,"not > and > or")]),l("li",null,[n("在语法规则中，可以通过人为地限制"),l("strong",null,"使用产生式归约的条件"),n("来实现不同的优先级")]),l("li",null,[l("code",null,"true、false")])])]),l("li",null,[l("p",null,"副作用"),l("ul",null,[l("li",null,[l("code",null,"newlabel()")]),l("li",null,[l("code",null,"label(L)")]),l("li",null,[l("code",null,"gen(code)")]),l("li",null,[l("code",null,"nextquad"),n("：下一条三地址指令的序号")])])]),l("li",null,[l("p",null,"语法规则和语义动作（数值表示法、从归约的角度理解）"),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"B -> E1 relop E2")]),l("div",{class:"language-text line-numbers-mode","data-ext":"text"},[l("pre",{class:"language-text"},[l("code",null,`a : {
    gen(if E1.addr relop E2.addr goto nextquad+3);
    gen(B.addr = 0);
    gen(goto nextquad+2);
    gen(B.addr = 1);
}
`)]),l("div",{class:"line-numbers","aria-hidden":"true"},[l("div",{class:"line-number"}),l("div",{class:"line-number"}),l("div",{class:"line-number"}),l("div",{class:"line-number"}),l("div",{class:"line-number"}),l("div",{class:"line-number"})])])]),l("li",null,[l("p",null,[l("code",null,"B -> true")]),l("div",{class:"language-text line-numbers-mode","data-ext":"text"},[l("pre",{class:"language-text"},[l("code",null,`a : {
    B.addr = newtmp;
    gen(B.addr = 1);
}
`)]),l("div",{class:"line-numbers","aria-hidden":"true"},[l("div",{class:"line-number"}),l("div",{class:"line-number"}),l("div",{class:"line-number"}),l("div",{class:"line-number"})])])]),l("li",null,[l("p",null,[l("code",null,"B -> false")]),l("div",{class:"language-text line-numbers-mode","data-ext":"text"},[l("pre",{class:"language-text"},[l("code",null,`a : {
    B.addr = newtmp;
    gen(B.addr = 0);
}
`)]),l("div",{class:"line-numbers","aria-hidden":"true"},[l("div",{class:"line-number"}),l("div",{class:"line-number"}),l("div",{class:"line-number"}),l("div",{class:"line-number"})])])]),l("li",null,[l("p",null,[l("code",null,"B -> B1 or B2")]),l("div",{class:"language-text line-numbers-mode","data-ext":"text"},[l("pre",{class:"language-text"},[l("code",null,`a : {
    B.addr = newtmp;
    gen(B.addr = B1.addr or B2.addr);
}
`)]),l("div",{class:"line-numbers","aria-hidden":"true"},[l("div",{class:"line-number"}),l("div",{class:"line-number"}),l("div",{class:"line-number"}),l("div",{class:"line-number"})])])]),l("li",null,[l("p",null,[l("code",null,"B -> B1 and B2")]),l("div",{class:"language-text line-numbers-mode","data-ext":"text"},[l("pre",{class:"language-text"},[l("code",null,`a : {
    B.addr = newtmp;
    gen(B.addr = B1.addr and B2.addr);
}
`)]),l("div",{class:"line-numbers","aria-hidden":"true"},[l("div",{class:"line-number"}),l("div",{class:"line-number"}),l("div",{class:"line-number"}),l("div",{class:"line-number"})])])]),l("li",null,[l("p",null,[l("code",null,"B -> not B1")]),l("div",{class:"language-text line-numbers-mode","data-ext":"text"},[l("pre",{class:"language-text"},[l("code",null,`a : {
    B.addr = newtmp;
    gen(B.addr = not B1.addr);
}
`)]),l("div",{class:"line-numbers","aria-hidden":"true"},[l("div",{class:"line-number"}),l("div",{class:"line-number"}),l("div",{class:"line-number"}),l("div",{class:"line-number"})])])]),l("li",null,[l("p",null,[l("code",null,"B -> (B1)")]),l("div",{class:"language-text line-numbers-mode","data-ext":"text"},[l("pre",{class:"language-text"},[l("code",null,`a : {
    B.addr = B1.addr;
}
`)]),l("div",{class:"line-numbers","aria-hidden":"true"},[l("div",{class:"line-number"}),l("div",{class:"line-number"}),l("div",{class:"line-number"})])])])])]),l("li",null,[l("p",null,"语法规则和语义动作（真假出口表示法、从推导的角度理解）"),l("ul",{"align*":""},[l("li",null,[l("p",null,[n("由"),l("strong",null,"关系运算符"),n("形成布尔表达式")]),l("ul",null,[l("li",null,[n("B\\rarr E_1"),l("sub",null,"relop"),n("E_2{a_1}")])]),l("p",{"align*":""},[n("\\begin{align*} &a_1:{\\ &~~~~gen(if"),l("sub",null,"E_1.addr"),n("relop"),l("sub",null,"E_2.addr"),n("goto~B.ture);\\ &~~~~gen(goto~B.false);\\ &}\\ \\end")]),l("blockquote",null,[l("p",null,[n("生成关系运算符的"),l("strong",null,"跳转"),n("三地址码")])])]),l("li",null,[l("p",null,[n("由"),l("strong",null,"逻辑值"),n("形成布尔表达式")])]),l("li",null,[l("p",null,"B\\rarr true{a_1}"),l("p",null,"\\begin{align*} &a_1:{\\ &~~~~gen(goto~B.true);\\ &}\\ \\end")])]),l("blockquote",null,[l("p",null,[n("直接生成跳转到"),l("strong",null,"真出口"),n("的三地址码")]),l("p",null,[n("这里所说的“"),l("strong",null,"出口"),n("”指的就是要跳转到的"),l("strong",null,"指令标号")])]),l("ul",null,[l("li",null,"B\\rarr false{a_1}")]),l("p",{"align*":""},"\\begin{align*} &a_1:{\\ &~~~~gen(goto~B.false);\\ &}\\ \\end"),l("blockquote",null,[l("p",null,[n("直接生成跳转到"),l("strong",null,"假出口"),n("的三地址码")])])]),l("li",null,[l("p",null,[n("通过"),l("strong",null,"逻辑运算符"),n("连接布尔表达式")]),l("ul",null,[l("li",null,"B\\rarr({a_1}B_1)")]),l("p",{"align*":""},"\\begin{align*} &a_1:{\\ &~~~~B_1.true=B.true;\\ &~~~~B_1.false=B.false;\\ &}\\ \\end"),l("blockquote",null,[l("p",null,[n("计算继承属性，让其"),l("strong",null,"真、假出口"),n("与父表达式保持相等")])]),l("ul",null,[l("li",null,"B\\rarr not{a_1}B_1")]),l("p",{"align*":""},"\\begin{align*} &a_1:{\\ &~~~~B_1.true=B.false;\\ &~~~~B_1.false=B.true;\\ &}\\ \\end"),l("pre",null,[l("code",null,`> 让其**真、假出口**与父表达式保持相反
`)]),l("blockquote"),l("ul",null,[l("li",null,[n("B\\rarr{a_1}B_1"),l("sub",null,"or"),n("{a_2}B_2")])]),l("p",null,"\\begin{align*} &a_1:{\\ &~~~~B_1.false=newlabel();\\ &~~~~B_1.true=B.true;\\ &}\\ &a_2:{\\ &~~~~label(B_1.false);\\ &~~~~B_2.true=B.true;\\ &~~~~B_2.false=B.false;\\ &}\\ \\end")])],-1),c=o(`<p>​</p><blockquote><p>计算B1继承属性时，真出口可以确定是父B的真出口，但假出口的代码是B2，还没生成，所以newlabel</p><p>计算B2继承属性时，马上要生成B2的代码了，所以B1的假出口可以确定了，B2的真假出口也可以由父B确定</p></blockquote><pre><code>-  B\\rarr\\{a_1\\}B_1~and~\\{a_2\\}B_2 


  \\begin{align*} &amp;a_1:\\{\\\\ &amp;~~~~B_1.true=newlabel();\\\\ &amp;~~~~B_1.false=B.false;\\\\ &amp;\\}\\\\ &amp;a_2:\\{\\\\ &amp;~~~~label(B_1.true);\\\\ &amp;~~~~B_2.true=B.true;\\\\ &amp;~~~~B_2.false=B.false;\\\\ &amp;\\}\\\\ \\end{align*}
</code></pre><p>​<br> ​<br> &gt; 与 <code>or</code>类似</p><blockquote></blockquote><ul><li><p>语法规则和语义动作（真假出口表示法、仅为L-SDD）</p><ul><li><p><code>B -&gt; E1 relop E2</code></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>a : {
    B.code = gen(if E1.addr relop E2.addr goto B.ture)
        ||gen(goto B.false);
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><code>B -&gt; true</code></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>a : {
    B.code = gen(goto B.true);
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><code>B -&gt; false</code></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>a : {
    B.code = gen(goto B.false);
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><code>B -&gt; B1 or B2</code></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>a : {
    B1.true = B.true;
    B1.false = newlabel;
    B2.true = B.true;
    B2.false = B.false;
    B.code = B1.code||gen(B1.false:)||B2.code
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><code>B -&gt; B1 and B2</code></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>a : {
    B1.true = newlabel;
    B1.false = B.false;
    B2.true = B.true;
    B2.false = B.false;
    B.code = B1.code||gen(B1.true:)||B2.code
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><code>B -&gt; not B1</code></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>a : {
    B1.true = B.flase;
    B1.false = B.true;
    B.code = B1.code
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><code>B -&gt; (B1)</code></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>a : {
    B1.true = B.true;
    B1.false = B.false;
    B.code = B1.code
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul></li></ul><h3 id="_6-4-控制流语句的翻译" tabindex="-1"><a class="header-anchor" href="#_6-4-控制流语句的翻译" aria-hidden="true">#</a> 6.4 控制流语句的翻译</h3><p><em>主要任务：</em></p><ul><li>结合布尔表达式的翻译，生成具有<strong>控制流结构</strong>的三地址码</li><li>正确处理<strong>指令标号</strong>的记录和<strong>跳转</strong>三地址码的生成</li></ul><hr><p><em>控制流语句的代码结构：</em></p><ul><li><p>跳转的逻辑结构很简单，重点是在合适的地方插入 <code>goto</code>语句</p><blockquote><p>详见编译原理随堂笔记仓库</p></blockquote></li></ul><hr><p><em>控制流语句的SDT：</em></p>`,14),b=l("ul",null,[l("li",null,[l("p",null,"文法符号与属性"),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"P"),n("：开始符号")])]),l("li",null,[l("p",null,[l("code",null,"S"),n("：控制流代码块")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"S.code"),n("：综合属性，存放完整的三地址码")])]),l("li",null,[l("p",null,[l("code",null,"S.next"),n("：继承属性，是一个地址，地址中存放了紧跟在 "),l("code",null,"S.code"),n("之后的指令标号，即 "),l("code",null,"S"),l("strong",null,"后继指令的标号")]),l("ul",null,[l("li",null,[l("blockquote",null,[l("p",null,[l("strong",null,"指令标号"),n("可以标识一条"),l("strong",null,"三地址指令")])])])])]),l("li",null,[l("p",null,[l("code",null,"S.first"),n("：继承属性，是一个地址，地址中存放了在 "),l("code",null,"S.code"),n("的"),l("strong",null,"第一条指令的标号")])])])]),l("li",null,[l("p",null,[l("code",null,"B"),n("：布尔表达式")]),l("ul",null,[l("li",null,[l("code",null,"B.ture"),n("：继承属性，是一个地址，地址中存放了当 "),l("code",null,"B"),n("为真时控制流转向的指令标号")]),l("li",null,[l("code",null,"B.false"),n("：继承属性，是一个地址，地址中存放了当 "),l("code",null,"B"),n("为假时控制流转向的指令标号")])])]),l("li",null,[l("p",null,[l("code",null,"E"),n("：表达式")]),l("ul",null,[l("li",null,[l("blockquote",null,[l("p",null,"与赋值语句中的一致")])])])]),l("li",null,[l("p",null,[l("code",null,"L"),n("：数组元素")]),l("ul",null,[l("li",null,[l("blockquote",null,[l("p",null,"与赋值语句中的一致")])])])])])]),l("li",null,[l("p",null,"副作用"),l("ul",null,[l("li",null,[l("code",null,"newlabel()"),n("：生成一个用于"),l("strong",null,"存放标号"),n("的临时变量，返回其"),l("strong",null,"地址")]),l("li",null,[l("code",null,"label(L)"),n("：将"),l("strong",null,"下一条"),n("三地址指令的"),l("strong",null,"标号"),n("赋值给 "),l("code",null,"L"),n("（指向的地址）")]),l("li",null,[l("code",null,"gen(code)")])])]),l("li",null,[l("p",null,"语法规则和语义动作（真假出口表示法、从推导的角度理解）"),l("ul",null,[l("li",null,[l("p",null,"文法开始/完整控流代码块形成："),l("ul",null,[l("li",null,"P\\rarr{a_1}S{a_2}")]),l("p",{"align*":""},"\\begin{align*} &a_1:{\\ &~~~~S.next=newlabel();\\ &}\\ &a_2:{\\ &~~~~label(S.next);\\ &} \\end"),l("blockquote",null,[l("p",null,[n("形成代码块前，先生成存放其后继指令的"),l("strong",null,"地址空间"),n("（因为这是继承属性，规定要这么算，而且"),l("strong",null,"代码块内"),n("可能会用到）；")]),l("p",null,[n("形成代码块后，将"),l("strong",null,"下一条"),n("三地址指令标号赋值给其"),l("strong",null,"后继指令")])]),l("ul",null,[l("li",null,[l("p",null,"S\\rarr{a_1}S_1{a_2}S_2"),l("p",{"align*":""},"\\begin{align*} &a_1:{\\ &~~~~S_1.next=newlabel();\\ &}\\ &a_2:{\\ &~~~~label(S_1.next);\\ &~~~~S_2.next=S.next\\ &} \\end"),l("blockquote",null,[l("p",null,"next继承属性肯定是要在符号出现前计算的，能用父S确定的就直接给父S的next，确定不了的（相应代码结构还没出现）就newlabel")])])]),l("blockquote")]),l("li",null,[l("p",null,[l("strong",null,"完整赋值语句"),n("的形成： S\\rarr id=E;{a}|L=E;{a}")]),l("blockquote",null,[l("p",null,"上一小节已经讲过，这里省略")])]),l("li",null,[l("p",null,"控制流结构的形成"),l("ul",null,[l("li",null,[n("S\\rarr if"),l("sub",null,"{a_1}B"),n("then~{a_2}S_1")])]),l("p",{"align*":""},"\\begin{align*} &a_1:{\\ &~~~~B.true=newlabel();\\ &~~~~B.false=S.next;\\ &}\\ &a_2:{\\ &~~~~label(B.ture);\\ &~~~~S_1.next=S.next;\\ &} \\end"),l("blockquote",null,[l("p",null,"形成布尔表达式前计算继承属性，false能用父S确定的，true还没生成，所以要等到S1之前用label赋值，然后S1的next继承属性用父S确定即可")]),l("ul",null,[l("li",null,[n("S\\rarr if"),l("sub",null,"{a_1}B"),n("then"),l("sub",null,"{a_2}S_1"),n("{a_3}else~{a_4}S_2")])]),l("p",{"align*":""},"\\begin{align*} &a_1:{\\ &~~~~B.true=newlabel();\\ &~~~~B.false=newlabel();\\ &}\\ &a_2:{\\ &~~~~label(B.ture);\\ &~~~~S_1.next=S.next;\\ &}\\ &a_3:{\\ &~~~~gen(goto~S.next);\\ &}\\ &a_4:{\\ &~~~~label(B.false);\\ &~~~~S_2.next=S.next;\\ &} \\end"),l("blockquote",null,[l("p",null,[n("与 "),l("code",null,"if-then"),n("类似，要么能用父S.next确定，要么还没生成，先newlabel，到对应的位置再label；必须要注意的是，记得"),l("strong",null,"生成S1之后的goto")])]),l("ul",null,[l("li",null,[n("S\\rarr while"),l("sub",null,"{a_1}B"),n("do~{a_2}S_1{a_3}")])]),l("p",{"align*":""},"\\begin{align*} &a_1:{\\ &~~~~S.begin=newlabel();\\ &~~~~label(S.begin);\\ &~~~~B.true=newlabel();\\ &~~~~B.false=S.next;\\ &}\\ &a_2:{\\ &~~~~label(B.true);\\ &~~~~S_1.next=S.begin;\\ &}\\ &a_3:{\\ &~~~~gen(goto~S.begin);\\ &}\\ \\end"),l("blockquote",null,[l("p",null,[n("与前面 "),l("code",null,"if"),n("的类似，这里单独注意一下 "),l("code",null,"S.begin"),n("和 "),l("code",null,"goto"),n("，因为 "),l("code",null,"while"),n("的特点就是会跳回前面")])])])])]),l("li",null,[l("p",null,"语法规则和语义动作（真假出口表示法、仅为L-SDD）"),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"S -> if B then S1")]),l("div",{class:"language-text line-numbers-mode","data-ext":"text"},[l("pre",{class:"language-text"},[l("code",null,`a: {
    B.true = newtmp;
    B.false = S.next;
    S1.next = S.next;
    S.code = B.code||gen(B.true:)||S1.code
}
`)]),l("div",{class:"line-numbers","aria-hidden":"true"},[l("div",{class:"line-number"}),l("div",{class:"line-number"}),l("div",{class:"line-number"}),l("div",{class:"line-number"}),l("div",{class:"line-number"}),l("div",{class:"line-number"})])])]),l("li",null,[l("p",null,[l("code",null,"S -> if B then S1 else S2")]),l("div",{class:"language-text line-numbers-mode","data-ext":"text"},[l("pre",{class:"language-text"},[l("code",null,`a: {
    B.true = newtmp;
    B.false = newtmp;
    S1.next = S.next;
    S2.next = S.next;
    S.code = B.code||gen(B.true:)||S1.code
        ||gen(goto S.next)
        ||gen(B.false:)||S2.code
}
`)]),l("div",{class:"line-numbers","aria-hidden":"true"},[l("div",{class:"line-number"}),l("div",{class:"line-number"}),l("div",{class:"line-number"}),l("div",{class:"line-number"}),l("div",{class:"line-number"}),l("div",{class:"line-number"}),l("div",{class:"line-number"}),l("div",{class:"line-number"}),l("div",{class:"line-number"})])])]),l("li",null,[l("p",null,[l("code",null,"S -> while B do S1")]),l("div",{class:"language-text line-numbers-mode","data-ext":"text"},[l("pre",{class:"language-text"},[l("code",null,`a: {
    S.begin = newtmp;
    B.true = newtmp;
    B.false = S.next;
    S1.next = S.begin;
    S.code = gen(S.begin:)||B.code
        ||gen(B.true:)||S1.code
        ||gen(goto S.begin)
}
`)]),l("div",{class:"line-numbers","aria-hidden":"true"},[l("div",{class:"line-number"}),l("div",{class:"line-number"}),l("div",{class:"line-number"}),l("div",{class:"line-number"}),l("div",{class:"line-number"}),l("div",{class:"line-number"}),l("div",{class:"line-number"}),l("div",{class:"line-number"}),l("div",{class:"line-number"})])])]),l("li",null,[l("p",null,[l("code",null,"S -> S1; S2")]),l("div",{class:"language-text line-numbers-mode","data-ext":"text"},[l("pre",{class:"language-text"},[l("code",null,`a: {
    S1.next = newtmp;
    S2.next = S.next;
    S.code = S1.code||gen(S1.next)||S2.code
}
`)]),l("div",{class:"line-numbers","aria-hidden":"true"},[l("div",{class:"line-number"}),l("div",{class:"line-number"}),l("div",{class:"line-number"}),l("div",{class:"line-number"}),l("div",{class:"line-number"})])])])])])],-1),m=l("p",null,[l("em",null,[l("code",null,"switch-case"),n("语句的翻译：")])],-1),h=l("ul",null,[l("li",null,[l("p",null,[l("code",null,"switch-case"),n("的直观翻译方式：")]),l("p",null,"switch~E{a_1}\\ case~V_1:{a_2}S_1{a_3}\\ case~V_2:{a_4}S_2{a_5}\\ ...\\ case~V_{n-1}:{a_{2n-2}}S_{n-1}{a_{2n-1}}\\ default~:{a_{2n}}S_n{a_{2n+1}}"),l("ul",null,[l("li",{"align*":""},[l("p",null,"新增特殊变量"),l("ul",null,[l("li",null,[l("code",null,"Vk"),n("：第 "),l("code",null,"k"),n("个分支的"),l("strong",null,"入口值")]),l("li",null,[l("code",null,"Lk"),n("：存放第 "),l("code",null,"k+1"),n("个分支"),l("strong",null,"第一条指令标号"),n("的地址空间")]),l("li",null,[l("code",null,"t"),n("：存放分支依据"),l("strong",null,"表达式的值")]),l("li",null,[l("code",null,"next"),n("：存放整体代码块"),l("strong",null,"下一条指令标号"),n("的地址空间")])]),l("p",null,[n("\\begin{align*} &a_1:{\\ &~~~~t=newtemp();\\ &~~~~gen(t=E.addr);\\ &~~~~next=newlabel();\\ &}\\ &a_{2k-2}:{\\ &~~~~label(L_{k-1});\\ &~~~~L_k=newlabel();\\ &~~~~gen(if"),l("sub",null,"t"),n("!=V_k"),l("sub",null,"goto"),n("L_k);\\ &}\\ &a_{2k-1}:{\\ &~~~~gen(goto~next);\\ &}\\ &a_{2n}:{\\ &~~~~label(L_{n-1});\\ &}\\ &a_{2n+1}:{\\ &~~~~label(next);\\ &}\\ \\end")])]),l("li",null,[l("p",null,[l("code",null,"switch-case"),n("语句开始分支测试前，生成将依据"),l("strong",null,"表达式值"),n("保存至临时变量的三地址码，并为存放"),l("strong",null,"整体代码块下一条指令的标号"),n("开辟内存空间")]),l("blockquote",null,[l("p",null,[n("那个 "),l("code",null,"next=newlabel()"),n("放在第一次使用 "),l("code",null,"next"),n("前也可以")])])]),l("li",null,[l("p",null,[n("每个测试分支中，形成代码块前，先给该"),l("strong",null,"分支对应标号赋值"),n("，再生成"),l("strong",null,"不满足条件跳转"),n("至下一个分支标号的三地址码；形成代码块后，生成跳转至整体代码块下一条指令的三地址码")]),l("blockquote",null,[l("p",null,"第一个测试分支不需要给自己的标号赋值，只需要生成不满足条件的跳转三地址码")])]),l("li",null,[l("p",null,[n("默认分支中，形成代码块前，给该"),l("strong",null,"分支对应标号赋值"),n("；形成代码块后，给"),l("strong",null,"整体代码块下一条指令对应"),n("的标号赋值")])])])]),l("li",null,[l("p",null,[l("code",null,"switch-case"),n("的"),l("strong",null,"分支测试代码集中"),n("翻译方式：")]),l("p",null,"switch~E{a_1}\\ case~V_1:{a_2}S_1{a_3}\\ case~V_2:{a_4}S_2{a_5}\\ ...\\ case~V_{n-1}:{a_{2n-2}}S_{n-1}{a_{2n-1}}\\ default~:{a_{2n}}S_n{a_{2n+1}}")]),l("li",{"align**":""},[l("p",null,"新增特殊变量"),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"test"),n("：分支集中测试块的第一条指令标号地址")])]),l("li",null,[l("p",null,"新增副作用")]),l("li",null,[l("p",null,[l("code",null,"map"),n("：记录分支测试"),l("strong",null,"入口值"),n("与分支测试"),l("strong",null,"标号"),n("的映射关系，方便批量生成"),l("strong",null,"分支测试代码")]),l("p",null,[n("\\begin{align**} &a_1:{\\ &~~~~t=newtemp();\\ &~~~~gen(t=E.addr);\\ &~~~~test=newlabel();\\ &~~~~gen(goto~test);\\ &~~~~next=newlabel();\\ &}\\ &a_{2k-2}:{\\ &~~~~L_k=newlabel();\\ &~~~~label(L_{k});\\ &~~~~map(V_k,L_k);\\ &}\\ &a_{2k-1}:{\\ &~~~~gen(goto~next);\\ &}\\ &a_{2n}:{\\ &~~~~L_n=newlabel();\\ &~~~~label(L_{n});\\ &}\\ &a_{2n+1}:{\\ &~~~~gen(goto~next);\\ &~~~~label(test);\\ &~~~~gen(if"),l("sub",null,"t=V_k"),n("goto~L_k);\\ &}\\ \\end")])])])]),l("li",null,[l("p",null,[l("code",null,"switch-case"),n("语句开始分支测试前，生成将依据"),l("strong",null,"表达式值"),n("保存至临时变量的三地址码，生成"),l("strong",null,"跳转至集中分支测试"),n("的三地址码，并为存放"),l("strong",null,"整体代码块下一条指令的标号"),n("开辟内存空间")]),l("ul",null,[l("li",null,[l("p",null,[n("每个测试分支中，形成代码块前，开辟该分支对应的标号，并给"),l("strong",null,"标号赋值"),n("为下一条指令，再将该分支测试"),l("strong",null,"入口值"),n("与"),l("strong",null,"标号"),n("的添加至映射表；形成代码块后，生成跳转至整体代码块下一条指令的三地址码")])]),l("li",null,[l("p",null,[n("默认分支中，形成代码块前，开辟该分支对应的标号，并给"),l("strong",null,"标号赋值"),n("为下一条指令；形成代码块后，生成跳转至整体代码块下一条指令的三地址码，再给"),l("strong",null,"集中分支测试的标号"),n("赋值，然后根据"),l("strong",null,"映射表"),n("批量生成分支"),l("strong",null,"入口值对比并跳转至对应标号"),n("的三地址码")]),l("blockquote",null,[l("p",null,[n("可以增加一种 "),l("code",null,"case"),n("指令，"),l("code",null,"case t V L"),n("等同于 "),l("code",null,"if t==V goto L"),n("，但 "),l("code",null,"case"),n("指令更容易被最终的代码生成器"),l("strong",null,"探测"),n("到，从而对这些指令进行"),l("strong",null,"特殊处理")])])])]),l("blockquote")])],-1),_=o(`<hr><p><em><code>for-to-step-do</code>语句的翻译：</em></p><ul><li>再说 吧</li></ul><hr><p><em><code>repeat-until</code>语句的翻译：</em></p><ul><li>再说 吧</li></ul><h3 id="_6-5-过程调用语句的翻译" tabindex="-1"><a class="header-anchor" href="#_6-5-过程调用语句的翻译" aria-hidden="true">#</a> 6.5 过程调用语句的翻译</h3><p><em>主要任务：</em></p><ul><li>解析过程调用的参数，生成<strong>设置实参和调用过程</strong>的三地址码</li></ul><hr><p><em>过程调用语句的代码结构：</em></p><ul><li><p>语句模式：<code>id(E1, E2, ..., En)</code></p></li><li><p>代码流程</p><ul><li><p>运算各表达式的三地址码，计算参数值：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>id(
	E1.code,
	E2.code,
	...
	En.code
)
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>通过 <code>param</code>指令将各表达式的值作为函数的实参：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>param E1.addr
param E2.addr
...
param En.addr
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>这种是 <code>param</code>指令集中的形式。也可以让 <code>param Ek.addr</code>指令紧跟在 <code>Ek.code</code>后面，就是分散形式。</p><p>分散形式下，需要使用一种数据结构（通常是队列 <code>q</code>）来存放 <code>Ek.addr</code>，以便集中生成 <code>param</code>指令</p></blockquote></li><li><p>调用函数：<code>call id.addr n</code></p><blockquote><p><code>n</code>代表参数个数</p></blockquote></li></ul></li></ul><hr><p><em>过程调用语句的SDT：</em></p>`,14),v=l("ul",null,[l("li",null,[l("p",null,"文法符号与属性"),l("ul",null,[l("li",null,[l("code",null,"S"),n("：文法开始符号/过程调用代码结构")]),l("li",null,[l("code",null,"Elist"),n("：参数列表")]),l("li",null,[l("code",null,"E"),n("：参数表达式 "),l("ul",null,[l("li",null,[l("code",null,"E.addr"),n("：表达式"),l("strong",null,"值的存放地址")])])])])]),l("li",null,[l("p",null,"副作用"),l("ul",null,[l("li",null,[l("code",null,"gen(code)")])])]),l("li",null,[l("p",null,"语法规则和语义动作"),l("ul",null,[l("li",null,[l("p",null,[n("文法开始/形成"),l("strong",null,"过程调用"),n("框架：S\\rarr call~id(Elist){a_1}")]),l("p",{"align*":""},[n("\\begin{align*} &a_1:{\\ &~~~~n=0;\\ &~~~~for"),l("sub",null,"q中的每个t"),n("do\\ &~~~~~~~~gen(param~t);\\ &~~~~~~~~n=n+1;\\ &~~~~gen(call~id.addr,n);\\ &}\\ \\end")]),l("blockquote",null,[l("p",null,[n("过程调用框架形成后，根据队列 "),l("code",null,"q"),n("集中生成所有"),l("strong",null,"设置实参"),n("的 "),l("code",null,"param"),n("三地址指令，最后再生成一条"),l("strong",null,"过程调用"),n("的三地址指令")])])]),l("li",null,[l("p",null,[n("形成"),l("strong",null,"参数列表")]),l("ul",null,[l("li",null,"Elist\\rarr E{a_1}")]),l("p",{"align*":""},"\\begin{align*} &a_1:{\\ &~~~~将q初始化为只包含E.addr的队列;\\ &}\\ \\end"),l("blockquote",null,[l("p",null,[n("参数列表开始形成时初始化队列 "),l("code",null,"q")])]),l("ul",null,[l("li",null,[l("p",null,"Elist\\rarr Elist_1,E{a_1}"),l("p",{"align*":""},"\\begin{align*} &a_1:{\\ &~~~~将E.addr添加到q的队尾;\\ &}\\ \\end"),l("blockquote",null,[l("p",null,[n("参数列表中每增加一个参数就添加一个参数地址至队列 "),l("code",null,"q"),n("中")])])])]),l("blockquote")])])])],-1),k=o('<h3 id="_6-6-回填" tabindex="-1"><a class="header-anchor" href="#_6-6-回填" aria-hidden="true">#</a> 6.6 回填</h3><p><em>基本思想：</em></p><ul><li>生成<strong>跳转</strong>三地址码时，暂不指定跳转的<strong>目标标号</strong>，并将这样的指令放入<strong>列表</strong>中，同一个列表中所有跳转指令的<strong>目标相同</strong>，待能确定目标时，再<strong>填充</strong>列表中指令的目标标号</li><li>待填充跳转指令组成的<strong>列表</strong>会通过文法符号<strong>综合属性</strong>进行传递，不再需要使用 <code>next true false</code>这类<strong>继承属性</strong>了，更符合<strong>归约</strong>的思想</li></ul><blockquote><p>如果不使用回填，可以两遍扫描，先把<strong>语法分析树</strong>建好，再遍历树，确定标号。但这样效率较低</p></blockquote><hr><p><em>布尔表达式的回填：</em></p>',6),q=l("ul",null,[l("li",null,[l("p",null,"有改动或新增的文法符号及其综合属性"),l("ul",null,[l("li",null,[l("code",null,"B"),n("：布尔表达式 "),l("ul",null,[l("li",null,[l("code",null,"B.truelist"),n("：指向包含待填充跳转指令的"),l("strong",null,"列表"),n("，列表中的跳转指令"),l("strong",null,[n("目标均为 "),l("code",null,"B"),n("的真出口")])]),l("li",null,[l("code",null,"B.falselist"),n("：指向包含待填充跳转指令的"),l("strong",null,"列表"),n("，列表中的跳转指令"),l("strong",null,[n("目标均为 "),l("code",null,"B"),n("的假出口")])])])]),l("li",null,[l("code",null,"M"),n("：辅助记录的符号 "),l("ul",null,[l("li",null,[l("code",null,"M.quad"),n("：会将下一条指令的标号暂存至该综合属性，之后会用到")])])])])]),l("li",null,[l("p",null,"新增的特殊变量"),l("ul",null,[l("li",null,[l("code",null,"nextquad"),n("：即将生成的下一条三地址码的标号")])])]),l("li",null,[l("p",null,"新增的副作用"),l("ul",null,[l("li",null,[l("code",null,"makelist(i)"),n("：创建一个只包含跳转指令 "),l("code",null,"i"),n("的列表，返回列表"),l("strong",null,"指针")]),l("li",null,[l("blockquote",null,[l("p",null,[n("这里的 "),l("code",null,"i"),n("是这条跳转指令本身的标号，不是目标标号")])])]),l("li",null,[l("code",null,"merge(p1, p2)"),n("：将 "),l("code",null,"p1"),n("和 "),l("code",null,"p2"),n("指向的两个列表合并，返回合并后列表"),l("strong",null,"指针")]),l("li",null,[l("code",null,"backpatch(p, i)"),n("：将 "),l("code",null,"i"),n("作为"),l("strong",null,"目标标号"),n("填充 "),l("code",null,"p"),n("指向的列表中的所有"),l("strong",null,"跳转指令")])])]),l("li",null,[l("p",null,"有改动的语法规则和语义动作"),l("ul",null,[l("li",null,[l("p",null,[n("由"),l("strong",null,"关系运算符"),n("形成布尔表达式： B\\rarr E_1"),l("sub",null,"relop"),n("E_2{a_1}")]),l("p",{"align*":""},[n("\\begin{align*} &a_1:{\\ &~~~~B.truelist=makelist(nextquad);\\ &~~~~B.falselist=makelist(nextquad+1);\\ &~~~~gen(if"),l("sub",null,"E_1.addr"),n("relop"),l("sub",null,"E_2.addr"),n("goto~_);\\ &~~~~gen(goto~_);\\ &}\\ \\end")]),l("blockquote",null,[l("p",null,[n("先设置待"),l("strong",null,"填充跳转指令列表"),n("，把"),l("strong",null,"即将生成的两条指令"),n("分别加入真假出口对应的两个列表，再生成关系运算符的"),l("strong",null,"待填充跳转三地址码")])])]),l("li",null,[l("p",null,[n("由"),l("strong",null,"逻辑值"),n("形成布尔表达式")]),l("ul",null,[l("li",null,"B\\rarr true{a_1}")]),l("p",{"align*":""},"\\begin{align*} &a_1:{\\ &~~~~B.truelist=makelist(nextquad);\\ &~~~~gen(goto~_);\\ &}\\ \\end"),l("blockquote",null,[l("p",null,[n("先设置待"),l("strong",null,"填充跳转指令列表"),n("，把"),l("strong",null,"即将生成的指令"),n("加入真出口对应的列表，再生成"),l("strong",null,"待填充的跳转三地址码")])]),l("ul",null,[l("li",null,[l("p",null,"B\\rarr false{a_1}"),l("p",{"align*":""},"\\begin{align*} &a_1:{\\ &~~~~B.falselist=makelist(nextquad);\\ &~~~~gen(goto~_);\\ &}\\ \\end"),l("blockquote",null,[l("p",null,[n("先设置待"),l("strong",null,"填充跳转指令列表"),n("，把"),l("strong",null,"即将生成的指令"),n("加入假出口对应的列表，再生成"),l("strong",null,"待填充的跳转三地址码")])])])]),l("blockquote")]),l("li",null,[l("p",null,[n("通过"),l("strong",null,"逻辑运算符"),n("连接布尔表达式")]),l("ul",null,[l("li",null,"B\\rarr(B_1){a_1}")]),l("p",{"align*":""},"\\begin{align*} &a_1:{\\ &~~~~B_1.truelist=B.truelist;\\ &~~~~B_1.falselist=B.falselist;\\ &}\\ \\end"),l("blockquote",null,[l("p",null,[n("子表达式形成后，让其"),l("strong",null,"真、假出口列表"),n("与父表达式保持相等")])]),l("ul",null,[l("li",null,"B\\rarr not~B_1{a_1}")]),l("p",{"align*":""},"\\begin{align*} &a_1:{\\ &~~~~B_1.truelist=B.falselist;\\ &~~~~B_1.falselist=B.truelist;\\ &}\\ \\end"),l("blockquote",null,[l("p",null,[n("相反子表达式形成后，让其"),l("strong",null,"真、假出口列表"),n("与父表达式保持相反")])]),l("ul",null,[l("li",null,[l("p",null,[n("B\\rarr B_1"),l("sub",null,"or"),n("M~B_2{a_1}")]),l("p",null,"M\\rarr\\epsilon{a_2}")])]),l("p",{"align*":""},"\\begin{align*} &a_1:{\\ &~~~~backpatch(B_1.falselist,M.quad);\\ &~~~~B.truelist=merge(B_1.truelist,B_2.truelist);\\ &~~~~B.falselist=B_2.falselist;\\ &}\\ &a_2:{\\ &~~~~M.quad=nextquad;\\ &}\\ \\end"),l("blockquote",null,[l("p",null,"子表达式形成并连接后："),l("ul",null,[l("li",null,[l("p",null,[n("处理不短路的跳转位置：用记录下的第二个布尔表达式的"),l("strong",null,"第一条指令标号"),n("回填第一个子表达式的"),l("strong",null,"假出口列表")])]),l("li",null,[l("p",null,"处理B的出口列表"),l("ul",null,[l("li",null,[n("真出口合并：将两个子表达式的"),l("strong",null,"真出口列表合并"),n("至父表达式的真出口列表")]),l("li",null,[n("假出口：将第二个子表达式的"),l("strong",null,"假出口列表"),n("赋值给父表达式的假出口列表")])])])]),l("p",null,[n("父表达式的真假出口列表待"),l("strong",null,"控制流语句"),n("形成后回填")])]),l("ul",null,[l("li",null,[l("p",null,[n("B\\rarr B_1"),l("sub",null,"and"),n("M~B_2{a_1}")]),l("p",null,"M\\rarr\\epsilon{a_2}")])]),l("p",{"align*":""},"\\begin{align*} &a_1:{\\ &~~~~backpatch(B_1.truelist,M.quad);\\ &~~~~B.falselist=merge(B_1.falselist,B_2.falselist);\\ &~~~~B.truelist=B_2.truelist;\\ &}\\ &a_2:{\\ &~~~~M.quad=nextquad;\\ &}\\ \\end"),l("blockquote",null,[l("p",null,"子表达式形成并连接后："),l("ul",null,[l("li",null,[n("处理不短路的跳转位置：用记录下的第二个布尔表达式的"),l("strong",null,"第一条指令标号"),n("回填第一个子表达式的"),l("strong",null,"真出口列表")]),l("li",null,[n("处理B的出口列表 "),l("ul",null,[l("li",null,[n("假出口合并：将两个子表达式的"),l("strong",null,"假出口列表合并"),n("至父表达式的真出口列表")]),l("li",null,[n("真出口：将第二个子表达式的"),l("strong",null,"真出口列表"),n("赋值给父表达式的假出口列表")])])])]),l("p",null,[n("父表达式的真假出口列表待"),l("strong",null,"控制流语句"),n("形成后回填")])])])])])],-1),x=l("hr",null,null,-1),S=l("p",null,[l("em",null,"控制流语句的回填：")],-1),B=l("ul",null,[l("li",null,[l("p",null,"有改动或新增的文法符号及其综合属性"),l("ul",null,[l("li",null,[l("code",null,"S"),n("：控制流代码块 "),l("ul",null,[l("li",null,[l("code",null,"S.nextlist"),n("：指向包含待填充跳转指令的"),l("strong",null,"列表"),n("，列表中的跳转指令"),l("strong",null,[n("目标均为 "),l("code",null,"S"),n("的下一条指令")])])])]),l("li",null,[l("code",null,"M"),n("：辅助记录的符号 "),l("ul",null,[l("li",null,[l("code",null,"M.quad"),n("：会将下一条指令的标号暂存至该综合属性，之后会用到")])])]),l("li",null,[l("code",null,"N"),n("：辅助记录的符号 "),l("ul",null,[l("li",null,[l("code",null,"N.nextlist"),n("：会将包含"),l("strong",null,"下一条跳转指令"),n("的列表指针标号暂存至该综合属性，之后会用到")])])])])]),l("li",null,[l("p",null,"新增的特殊变量"),l("ul",null,[l("li",null,[l("code",null,"nextquad")])])]),l("li",null,[l("p",null,"新增的副作用"),l("ul",null,[l("li",null,[l("code",null,"makelist(i)")]),l("li",null,[l("code",null,"merge(p1, p2)")]),l("li",null,[l("code",null,"backpatch(p, i)")])])]),l("li",null,[l("p",null,"有改动的语法规则和语义动作"),l("ul",{"align*":""},[l("li",null,[l("p",null,"文法开始/完整控流代码块形成："),l("ul",null,[l("li",null,"P\\rarr S{a_1}")]),l("p",{"align*":""},"\\begin{align*} &a_1:{\\ &~~~~backpatch(S.nextlist,nextquad);\\ &}\\ \\end"),l("blockquote",null,[l("p",null,[n("形成代码块后，用"),l("strong",null,"下一条"),n("三地址指令标号回填整体代码块的"),l("strong",null,"后继列表"),n("；")]),l("p",null,"这条回填产生式是我自己猜的，我希望是对的")]),l("ul",null,[l("li",null,[l("p",null,[n("S\\rarr S_1"),l("sub",null,"M"),n("S_2{a_1}")]),l("p",null,"\\begin{align*} &a_1:{\\ &~~~~backpatch(S_1.nextlist, M.quad)\\ &~~~~S.nextlist=S_2.nextlist\\ &}\\ \\end")])])])]),l("blockquote",null,[l("p",null,[n("两个代码块拼接完成后，先用记录下的第二个代码块的"),l("strong",null,"第一条指令标号"),n("回填第一个代码块的"),l("strong",null,"后继列表"),n("，再将第二个代码块的后继列表赋值给整体代码块的后继列表")])]),l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"完整赋值语句"),n("的形成： S\\rarr id=E;{a}|L=E;{a}")]),l("p",{"align*":""},"\\begin{align*} &a:{\\ &~~~~S.nextlist=null;\\ &}\\ \\end"),l("blockquote",null,[l("p",null,[n("完整赋值语句形成后，直接让代码块"),l("strong",null,"后继列表为空"),n("即可；")]),l("p",null,"因为赋值语句只是顺序执行，不需要特殊的跳转")])]),l("li",null,[l("p",null,"控制流结构的形成"),l("ul",null,[l("li",null,[n("S\\rarr if"),l("sub",null,"B"),n("then"),l("sub",null,"M"),n("S_1{a_1}")])]),l("p",{"align*":""},"\\begin{align*} &a_1:{\\ &~~~~backpatch(B.truelist, M.quad);\\ &~~~~S.nextlist=merge(B.falselist,S_1.nextlist);\\ &}\\ \\end"),l("blockquote",null,[l("p",null,"单分支控制流形成后："),l("ul",null,[l("li",null,[n("真出口：回填子代码块"),l("strong",null,"第一条指令")]),l("li",null,[n("假出口：与子代码块的 "),l("code",null,"nextlist"),n("合并，给到父代码块。因为 "),l("code",null,"S.next"),n("完全没出现在这条产生式中")])])]),l("ul",null,[l("li",null,[l("p",null,[n("S\\rarr if"),l("sub",null,"B"),n("then"),l("sub",null,"M_1"),n("S_1"),l("sub",null,"N"),n("else"),l("sub",null,"M_2"),n("S_2{a_1}")]),l("p",null,"N\\rarr\\epsilon{a_3}")])]),l("p",{"align*":""},"\\begin{align*} &a_1:{\\ &~~~~backpatch(B.truelist,M1.quad);\\ &~~~~backpatch(B.falselist,M2.quad);\\ &~~~~S.nextlist=merge(merge(S_1.nextlist,N.nextlist),S_2.nextlist);\\ &}\\ &a_3:{\\ &~~~~N.nextlist=makelist(nextquad);\\ &~~~~gen(goto~_);\\ &}\\ \\end"),l("blockquote",null,[l("p",null,"双分支控制流形成后："),l("ul",null,[l("li",null,[n("真出口：回填第一个子代码块"),l("strong",null,"第一条指令")]),l("li",null,[n("假出口：回填第二个子代码块"),l("strong",null,"第一条指令")]),l("li",null,[n("中途跳转出口：与两个"),l("strong",null,"子代码块"),n("的 "),l("code",null,"nextlist"),n("合并然后给到父代码块")])])]),l("ul",null,[l("li",null,[n("S\\rarr while"),l("sub",null,"M_1"),n("B"),l("sub",null,"do"),n("M_2~S_1{a_1}")])]),l("p",{"align*":""},"\\begin{align*} &a_1:{\\ &~~~~backpatch(S_1.nextlist,M_1.quad);\\ &~~~~backpatch(B.truelist,M_2.quad);\\ &~~~~S.nextlist=B.falselist;\\ &~~~~gen(goto~M_1.quad);\\ &}\\ \\end"),l("blockquote",null,[l("p",null,"循环控制流形成后："),l("ul",null,[l("li",null,[n("真出口：回填子代码块"),l("strong",null,"第一条指令")]),l("li",null,"假出口：产生式中没出现，给到父代码块，待之后回填"),l("li",null,[n("子代码块 "),l("code",null,"nextlist"),n("：回填布尔代码块"),l("strong",null,"第一条指令")]),l("li",null,"中途跳转：跳回布尔表达式")])])])])])],-1),L=o('<h2 id="_7-运行存储分配" tabindex="-1"><a class="header-anchor" href="#_7-运行存储分配" aria-hidden="true">#</a> 7 运行存储分配</h2><h3 id="_7-1-运行存储分配概述" tabindex="-1"><a class="header-anchor" href="#_7-1-运行存储分配概述" aria-hidden="true">#</a> 7.1 运行存储分配概述</h3><p><em>运行存储分配策略：</em></p><ul><li><p>编译器要为源程序中出现的一些<strong>数据对象</strong>分配<strong>运行时的存储空间</strong></p></li><li><p>静态存储分配策略：对于在编译时可以确定大小的<strong>数据对象</strong>，可以在<strong>编译时</strong>就静态地分配存储空间</p><blockquote><p><strong>静态</strong>指的是<strong>编译时、空间上</strong></p></blockquote></li><li><p>动态存储分配策略：对于不能在编译时完全确定大小的<strong>数据对象</strong>，仅在编译时产生必要信息，而在<strong>运行时</strong>动态地分配存储空间</p><blockquote><p><strong>动态</strong>指的是<strong>运行时、时间上</strong></p></blockquote><ul><li>栈式存储分配</li><li>堆式存储分配</li></ul></li></ul><hr><p><em>名字与变量：</em></p><ul><li><p>概念问题：</p><ul><li>名字：编译时的名字</li><li>变量/左值：运行时的内存位置</li><li>标识符：名字的一种，指示数据对象的入口</li><li>右值：运行时某一时刻变量的值</li></ul></li><li><p>名字到值的映射</p><ul><li><code>名字 --环境--&gt; 左值/变量 --状态--&gt; 值/右值</code></li><li>绑定：<strong>环境</strong>将<strong>名字</strong>绑定到<strong>左值/变量</strong>上</li></ul></li></ul><hr><p><em>作用域：</em></p><ul><li><p>静态作用域</p><ul><li><p>定义：编译时即可确定声明的作用域，即<strong>编译</strong>时就可以确定每个变量<strong>来自于哪个声明</strong></p></li><li><p>寻找变量规则：</p><ul><li><p>声明语句在一个程序块内，则作用域就是这个<strong>程序块</strong></p></li><li><p>如果允许嵌套，那么在寻找变量时首先找本层，然后找<strong>最近的外层</strong>，即<strong>最近作用域规则</strong></p><blockquote><p><strong>空间</strong>上最近</p></blockquote></li></ul></li></ul></li><li><p>动态作用域</p><ul><li><p>定义：不是静态作用域，即有些变量只能在<strong>运行时</strong>确定其<strong>来自于哪个声明</strong></p></li><li><p>寻找变量规则：找到最近被调用的过程中的声明</p><blockquote><p><strong>时间</strong>上最近</p></blockquote></li></ul></li></ul><hr><p><em>内存划分与过程活动：</em></p><ul><li><p>运行时内存划分：</p><ul><li><strong>静态代码</strong>区</li><li><strong>静态数据</strong>区</li><li><strong>动态数据</strong>区域 <ul><li><strong>栈区</strong></li><li>空闲内存</li><li>堆区</li></ul></li></ul></li><li><p>活动记录：</p><ul><li><p>概念：</p><ul><li><p>活动(activation)：过程体的<strong>每次执行</strong>称为该过程的一个活动</p></li><li><p>活动记录(activation record)：编译器以<strong>过程</strong>为单位、为<strong>活动</strong>分配的、用来管理<strong>一次执行所需信息</strong>的连续<strong>存储空间</strong></p><blockquote><p>活动记录的体积在编译时是可以确定的</p></blockquote></li></ul></li><li><p>一般形式/构成</p><ul><li>实参</li><li>返回值</li><li>控制链/动态链：指向<strong>调用者</strong>的活动记录</li><li>访问链/静态链：用于访问<strong>非局部数据</strong></li><li>保存的<strong>机器状态</strong>/机器状态字段：各种<strong>寄存器</strong>值和其他<strong>状态信息</strong></li><li>局部数据</li><li>临时变量：中间代码生成时需要的临时变量</li></ul></li></ul></li><li><p>参数传递方式</p><ul><li>传值：新开变量，传右值</li><li>传地址：如果实参是左值，则传左值；如果实参不是左值，则创建<strong>临时变量</strong>充当左值，设置其右值，然后传左值</li><li>传值结果：同时传左值和右值，在主体中<strong>只使用右值</strong>，在<strong>结束</strong>前修改<strong>左值状态</strong></li><li>传名：过程体中用到形参的地方直接替换成一模一样的实参左值（包括运算符）</li></ul></li></ul><h3 id="_7-2-静态存储分配" tabindex="-1"><a class="header-anchor" href="#_7-2-静态存储分配" aria-hidden="true">#</a> 7.2 静态存储分配</h3><blockquote><p>静态数据和静态代码无疑是静态存储分配的，所以该小节主要讲<strong>活动记录的静态存储分配</strong></p></blockquote><p><em>静态存储分配的规则与条件：</em></p><ul><li><p>规则：</p><ul><li><strong>编译器</strong>为每个<strong>活动记录</strong>直接指定<strong>存储位置</strong></li><li>因此，过程中<strong>标识符的存储位置</strong>可以确定，每次都绑定到同样的存储单元，可以将这些地址编译到目标代码中</li></ul></li><li><p>条件：</p><ul><li><p><strong>数组上下界</strong>必须是常数</p></li><li><p>不允许<strong>递归调用</strong></p></li><li><p>不允许<strong>动态建立</strong>数据实体</p><blockquote><p>满足这些条件的语言有BASIC、FORTRAN等</p></blockquote></li></ul></li></ul><hr><p><em>顺序分配法：</em></p><ul><li><p>特点：</p><ul><li>按照过程出现的先后顺序<strong>逐段分配</strong>存储空间</li><li>各过程的活动记录占用<strong>互不相交</strong>的存储空间</li></ul></li><li><p>优点：处理简单</p></li><li><p>缺点：对内存空间的使用不够经济合理</p></li></ul><hr><p><em>层次分配法：</em></p><ul><li><p>层次分配的特点：</p><ul><li>构建<strong>过程调用图</strong>，确保图中不出现<strong>环</strong></li><li>无相互调用关系的<strong>并列过程</strong>尽量使其局部数据<strong>共享存储空间</strong></li></ul></li><li><p>层次分配的算法：</p><ul><li><p>依据过程调用图，<strong>从下至上</strong>分配</p></li><li><p><strong>同层</strong>可以互相“<strong>覆盖</strong>”</p></li><li><p><strong>上层</strong>从子过程的<strong>最高地址</strong>开始分配</p><blockquote><p>代码实现的算法详见编译原理笔记仓库</p></blockquote></li></ul></li></ul><h3 id="_7-3-栈式存储分配与调用返回序列" tabindex="-1"><a class="header-anchor" href="#_7-3-栈式存储分配与调用返回序列" aria-hidden="true">#</a> 7.3 栈式存储分配与调用返回序列</h3><p><em>栈式存储分配与活动树：</em></p><ul><li><p>栈式存储分配的概念：</p><ul><li>将过程的<strong>活动记录</strong>以<strong>栈</strong>的形式进行管理</li><li>当过程被<strong>调用</strong>时，活动记录<strong>入栈</strong>；当过程<strong>结束</strong>时，活动记录<strong>出栈</strong></li></ul></li><li><p>栈式存储分配的优点：</p><ul><li><p>允许<strong>活跃时段不交叠</strong>的过程调用<strong>共享存储空间</strong></p></li><li><p>非局部变量的相对地址固定，与调用序列无关</p><blockquote><p>关于非局部变量会在后面讲到</p></blockquote></li></ul></li><li><p>活动树与控制栈：</p><ul><li>活动树的概念：描述程序运行期间控制<strong>进入和离开各个活动</strong>的情况的树</li><li>活动树的结构： <ul><li>每个<strong>结点</strong>对应一个<strong>活动</strong>，根结点是<strong>程序入口</strong>过程的活动</li><li><strong>子结点</strong>表示被父结点活动<strong>调用的活动</strong>，按被调用的顺序自左向右排列</li><li>一个子结点活动必须在其右兄弟结点活动开始之前结束</li></ul></li><li>活动树与控制栈的关系： <ul><li>活动树<strong>根的活动记录</strong>位于<strong>栈底</strong>，程序控制所在的活动记录位于<strong>栈顶</strong></li><li><strong>控制栈</strong>中全部活动记录的<strong>序列</strong>对应于<strong>活动树</strong>中从<strong>根结点</strong>到达<strong>当前控制</strong>所在活动结点的<strong>路径</strong></li></ul></li></ul></li><li><p>设计活动记录的原则：</p><ul><li><strong>传递的项</strong>：调用者和被调用者之间<strong>传递的值</strong>放置在被调用活动记录的<strong>起始位置</strong></li><li><strong>固定长度项</strong>：固定长度的项放置在活动记录的<strong>中间位置</strong>，包括<strong>控制链、访问链、机器状态字段</strong></li><li><strong>不定长度项</strong>：初期不确定长度的项放置在活动记录的<strong>尾部</strong></li><li><strong>栈顶指针</strong>：栈顶指针寄存器 <code>top_sp</code>指向活动记录中<strong>局部数据开始的位置</strong>，以该位置作为<strong>基地址</strong></li></ul></li></ul><hr><p><em>调用序列与返回序列：</em></p><ul><li><p>调用序列与返回序列概述：</p><ul><li>过程<strong>调用</strong>和过程<strong>返回</strong>都需要执行一些<strong>代码</strong>来管理<strong>活动记录栈</strong>，保存或恢复机器状态字等</li><li><strong>调用序列</strong>：实现<strong>过程调用</strong>的<strong>代码段</strong>。为活动记录<strong>分配栈空间</strong>，并填写活动记录的<strong>字段</strong></li><li><strong>返回序列</strong>：实现<strong>过程返回</strong>的<strong>代码段</strong>。回收活动记录的栈空间，<strong>恢复机器状态</strong>，使<strong>调用者过程</strong>能继续执行</li><li>调用序列和返回序列中的代码段通常被<strong>分割到调用者过程和被调用者过程</strong>中</li></ul></li><li><p><strong>调用</strong>序列的主要内容：</p><ul><li><p>参数：<strong>调用者</strong>计算实际参数的值</p></li><li><p>返回地址：<strong>调用者</strong>将返回地址（当前程序计数器的值）存到被调用活动记录的<strong>机器状态字段</strong>中</p></li><li><p><code>top_sp</code>：<strong>调用者</strong>将 <code>top_sp</code>的值存到被调用活动记录的<strong>控制链</strong>中，并<strong>增加</strong> <code>top_sp</code>的值，使其指向被调用活动记录<strong>局部数据开始的位置</strong></p></li><li><p>机器状态：<strong>被调用者</strong>保存寄存器值和其他状态信息（<strong>保存现场</strong>）</p></li><li><p>局部数据：<strong>被调用者</strong>初始化其<strong>局部数据</strong>并开始执行</p></li><li><p>访问链：<strong>调用者</strong>设置被调用活动记录的<strong>访问链</strong></p><blockquote><p>关于访问链会在后面讲到</p></blockquote></li></ul></li><li><p><strong>返回</strong>序列的主要内容：</p><ul><li><p>返回值：<strong>被调用者</strong>将<strong>返回值</strong>存到与<strong>参数</strong>相邻的位置</p></li><li><p><code>top_sp</code>：<strong>被调用者</strong>根据<strong>控制链</strong>中的数据恢复 <code>top_sp</code></p><blockquote><p>虽然 <code>top_sp</code>的值被减小，但调用者依然可以知道<strong>返回值</strong>的位置</p></blockquote></li><li><p>机器状态：<strong>被调用者</strong>根据<strong>机器状态字段</strong>中的信息恢复寄存器值和其他状态信息（<strong>恢复现场</strong>）</p></li><li><p>返回：<strong>被调用者</strong>根据<strong>机器状态字段</strong>中的信息跳转到<strong>返回地址</strong></p></li></ul></li></ul><hr><p><em>变长数据的存储分配：</em></p><ul><li><p>变长数据的栈分配策略：</p><ul><li><p>编译时刻不能确定大小的过程<strong>局部对象</strong>可以分配到<strong>运行时刻栈</strong>中</p><blockquote><p>这样的局部对象不算作活动记录的一部分</p></blockquote></li><li><p>可以避免对变长数据空间的主动垃圾回收，减少相应开销</p><blockquote><p>现代程序设计语言中，编译时不能确定大小的对象往往分配在<strong>堆区</strong>，但如果是局部对象也可以分配到栈区</p></blockquote></li></ul></li><li><p>动态数组的分配：</p><ul><li><p>在活动记录的局部数据中存放<strong>数组指针</strong></p><blockquote><p><strong>数组指针</strong>在<strong>编译时</strong>可以确定大小，属于<strong>活动记录</strong>的一部分</p></blockquote></li><li><p><strong>运行</strong>时在栈中<strong>当前活动记录之下</strong>开辟变长数组空间，存放数组元素</p><blockquote><p>变长数组虽然出现在栈中，但并不是<strong>活动记录</strong>的一部分，因为在<strong>编译时</strong>无法确定大小，需要在<strong>运行时</strong>动态分配</p></blockquote></li></ul></li></ul><h3 id="_7-4-非局部数据与访问链" tabindex="-1"><a class="header-anchor" href="#_7-4-非局部数据与访问链" aria-hidden="true">#</a> 7.4 非局部数据与访问链</h3><p><em>非局部数据相关概念：</em></p><ul><li><p>非局部数据的概念：</p><ul><li><p>语言可分为<strong>支持过程嵌套</strong>声明的和<strong>不支持过程嵌套</strong>声明的</p><blockquote><p>支持过程嵌套：Pascal，不支持过程嵌套：C</p></blockquote></li><li><p>支持过程嵌套的语言中，过程可以使用<strong>过程外定义的非局部数据</strong></p><blockquote><p>过程本就可以使用<strong>过程自身定义</strong>的局部数据和<strong>全局定义</strong>的数据。</p></blockquote><ul><li><strong>全局</strong>变量被分配在<strong>静态区</strong>，使用<strong>静态</strong>确定的地址访问它们</li><li><strong>局部</strong>变量被分配在<strong>栈区</strong>，在栈顶活动，通过<strong>运行时</strong>栈的 <code>top_sp</code>访问</li></ul></li></ul></li><li><p>嵌套深度的概念：</p><ul><li><strong>过程</strong>的嵌套深度： <ul><li>不内嵌在任何其他过程中的过程，其嵌套深度为1</li><li>如果一个过程p在一个嵌套深度为i的过程中定义，则过程p的嵌套深度为i+1</li></ul></li><li><strong>变量</strong>的嵌套深度： <ul><li>变量<strong>声明所在过程</strong>的嵌套深度即为该变量的嵌套深度</li></ul></li></ul></li></ul><hr><p><em>访问链及其建立：</em></p><ul><li><p>访问链的概念：</p><ul><li>静态作用域规则：只要过程b嵌套在过程a的声明中，过程b就可以访问过程a中声明的对象</li><li>访问链指针：在相互<strong>嵌套</strong>的过程的<strong>活动记录</strong>之间建立一种称为<strong>访问链</strong>的指针，使得内嵌的过程可以访问外层过程中声明的对象</li></ul></li><li><p>访问链的建立：</p><ul><li><p>建立规则：如果<strong>过程b</strong>在源代码中<strong>直接嵌套</strong>在<strong>过程a</strong>中，那么<strong>b的任何活动</strong>中的访问链都指向最近的<strong>a的活动</strong></p><blockquote><p>直接嵌套：过程b声明在过程a中且b的嵌套深度比a的嵌套深度大1</p><p>注意区分过程和活动，一个过程在运行时可以有多个活动</p></blockquote></li><li><p>建立步骤：建立访问链，其实就是在<strong>调用序列</strong>中加入相关代码，由<strong>调用者</strong>负责建立访问链</p><p>假设嵌套深度为 n_x 的过程x调用嵌套深度为 n_y 的过程y（ x\\rarr y ）</p><ul><li><p>如果 n_x&lt;n_y ，即<strong>外层调用内层</strong>，那么需要在y的访问链中放置一个指向x的活动记录的指针</p><blockquote><p>这种情况下y一定是<strong>直接定义</strong>在x中的，因此 n_y=n_x+1</p><p>因为外层<strong>无法进一步深入内层</strong>访问内层中的数据</p><p>外调内，内指外</p></blockquote></li><li><p>如果 n_x=n_y ，即<strong>本层调用本层</strong>，那么被调用活动记录的访问链与调用者活动记录相同，可以直接<strong>复制</strong></p><blockquote><p>递归调用自己也是同理</p><p>同级调，<strong>复制</strong></p></blockquote></li><li><p>如果 n_x&gt;n_y ，即<strong>内层调用外层</strong>，那么从x的活动记录开始，沿着访问链经过 n_x-n_y+1 步找到的活动记录，就是y的访问链要指向的活动记录</p><blockquote><p>这种情况下，一定存在一个过程z，满足过程x<strong>嵌套</strong>在过程z中，且z中<strong>直接定义</strong>了过程y。在上述过程中经过 n_x-n_y+1 步找到的活动记录就是离栈顶最近的z的活动记录</p><ul><li>这里说的“嵌套”不包括z直接定义x的情况，一定要存在一个嵌套的<strong>中间过程</strong></li></ul><p>内调外，指向最近<strong>公共祖先</strong>（不包括二者本身）</p></blockquote></li></ul></li></ul></li></ul><h3 id="_7-5-符号表的组织" tabindex="-1"><a class="header-anchor" href="#_7-5-符号表的组织" aria-hidden="true">#</a> 7.5 符号表的组织</h3><blockquote><p>由于本校考试不考查此部分，所以暂时没有知识总结</p></blockquote><h3 id="_7-6-堆式存储分配" tabindex="-1"><a class="header-anchor" href="#_7-6-堆式存储分配" aria-hidden="true">#</a> 7.6 堆式存储分配</h3><blockquote><p>由于本校考试不考查此部分，所以暂时没有知识总结</p></blockquote><h2 id="_8-代码优化" tabindex="-1"><a class="header-anchor" href="#_8-代码优化" aria-hidden="true">#</a> 8 代码优化</h2><blockquote><p>由于本校考试不考查此部分，所以暂时没有知识总结</p></blockquote><h2 id="_9-代码生成" tabindex="-1"><a class="header-anchor" href="#_9-代码生成" aria-hidden="true">#</a> 9 代码生成</h2><h3 id="_9-1-代码生成的主要任务" tabindex="-1"><a class="header-anchor" href="#_9-1-代码生成的主要任务" aria-hidden="true">#</a> 9.1 代码生成的主要任务</h3><p><em>指令选择：</em></p><ul><li><p>选择适当的<strong>目标机指令</strong>来实现中间表示（<strong>IR</strong>）语句</p></li><li><p>目标代码形式</p><ul><li>绝对机器语言代码</li><li>可重定位的机器语言代码</li><li>汇编语言代码</li></ul></li></ul><hr><p><em>寄存器分配和指派：</em></p><ul><li>选择适当的寄存器存放从内存中加载的值</li></ul><hr><p><em>指令排序：</em></p><ul><li>选择适当的顺序安排指令的执行</li></ul><h3 id="_9-2-目标机与指令选择" tabindex="-1"><a class="header-anchor" href="#_9-2-目标机与指令选择" aria-hidden="true">#</a> 9.2 目标机与指令选择</h3><p><em>目标机模型：</em></p>',56),f=l("ul",{"n-1":""},[l("li",null,[l("p",null,"特性："),l("ul",null,[l("li",null,[l("p",null,"指令集：有加载、保存、运算、跳转等操作。指令之间可以有标号")]),l("li",null,[l("p",null,"内存编址：内存按字节寻址")]),l("li",null,[l("p",null,"寄存器：有n个通用寄存器"),l("p",null,"R_0、R_1、...、R_")])])])],-1),R=o(`<p>​</p><ul><li><p>运算：所有运算分量都是整数</p></li><li><p>主要指令：</p><ul><li><p>加载指令：<code>LD dst, addr</code></p></li><li><p>保存指令：<code>ST x, r</code></p></li><li><p>运算指令：<code>OP dst, src1, src2</code></p></li><li><p>无条件跳转指令：<code>BR L</code></p></li><li><p>条件跳转指令：<code>Bcond r, L</code></p><blockquote><p>例：<code>BLTZ r, L</code></p><p>LTZ：Less then Zero</p></blockquote></li></ul></li><li><p>寻址模式：</p><blockquote><p><code>contents(x)</code>表示取出地址 <code>x</code>上的数据，<code>conteents(R)</code>表示取出寄存器 <code>R</code>中的数据（有时也可以直接用 <code>R</code>代替）</p></blockquote><ul><li><p><strong>变量名</strong>：直接用一个变量名表示<strong>地址</strong></p><blockquote><p>例：<code>LD R1, a // R1 = contents(a)</code></p></blockquote></li><li><p>偏移：用 <code>基址(偏移量)</code>的方式表示地址</p><ul><li><p><code>a(r)</code>：<code>a</code>是变量，<code>r</code>是寄存器</p><blockquote><p>例：<code>LD R1 a(R2) // R1 = contents(a + contens(R2))</code></p></blockquote></li><li><p><code>c(r)</code>：<code>a</code>是常整数，<code>r</code>是寄存器</p><blockquote><p>例：<code>LD R1 100(R2) // R1 = contents(100 + contens(R2))</code></p></blockquote></li></ul></li><li><p>间接：<strong>指出的地址</strong>中并不存放目标数据，而是又<strong>存放着目标数据所在地址</strong></p></li><li><p><code>*</code>运算符可以理解成把地址中存放的数据取出来。在寻址模式中意思就是，<strong>指出的地址中存放的数据</strong>是真正要访问的地址</p><ul><li><p><code>*r</code>：在寄存器 <code>r</code>指示的地址中存放着目标数据所在地址</p><blockquote><p>例：<code>LD R1, *R2 // R1 = contents(contents(R2))</code></p></blockquote></li><li><p><code>*c(r)</code>：寄存器 <code>r</code>中的值再加上常整数 <code>c</code>所指示的地址中存放着目标数据所在地址</p><blockquote><p>例：<code>LD R1, *100(R2) // R1 = contents(contents(100 + contents(R2)))</code></p></blockquote></li></ul></li><li><p>立即数：<code>#c</code>表示立即数整数 <code>c</code></p><blockquote><p>例：<code>LD R1, #100 // R1 = 100</code></p></blockquote></li></ul></li></ul><hr><p><em>指令选择：</em></p><ul><li><p><strong>运算</strong>三地址语句：<code>x = y - z</code></p><ul><li><p>目标代码：</p><ul><li><code>LD R1, y</code></li><li><code>LD R2, z</code></li><li><code>SUB R1, R1, R2</code></li><li><code>ST x, R1</code></li></ul><blockquote><p>上面列出的4条指令一定能实现运算语句，但在特定情况下可以省略一些指令，例如：</p><ul><li>所需的运算分量已经在寄存器中了</li><li>运算结果不需要放回内存</li></ul></blockquote></li></ul></li><li><p><strong>数组寻址</strong>三地址语句：</p><blockquote><p><code>a</code>是一个实数数组，每个实数占8字节</p></blockquote><ul><li><code>b = a[i]</code>的目标代码： <ul><li><code>LD R1, i</code></li><li><code>MUL R1, R1, 8</code></li><li><code>LD R2, a(R1) // R2 = contents(a + contents(R1))</code></li><li><code>ST b, R2</code></li></ul></li><li><code>a[j] = c</code>的目标代码： <ul><li><code>LD R1, c</code></li><li><code>LD R2, j</code></li><li><code>MUL R2, R2, 8</code></li><li><code>ST a(R2), R1 // contents(a + contents(R2)) = R1</code></li></ul></li></ul></li><li><p><strong>指针存取</strong>三地址语句：</p><ul><li><code>x = *p</code>的目标代码：</li><li><code>LD R1, p</code></li><li><code>LD R2, 0(R1) // R2 = contents(0 + contents(R1))</code></li><li><code>ST x, R2</code></li><li><code>*p = y</code>的目标代码：</li><li><code>LD R1, p</code></li><li><code>LD R2, y</code></li><li><code>ST 0(R1), R2 // contents(0 + contents(R1)) = R2</code></li></ul></li><li><p><strong>条件跳转</strong>三地址语句：<code>if x &lt; y goto L</code></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>LD R1, x
LD R2, y
SUB R1, R1, R2
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><code>BLTZ R1, M</code></p><blockquote><p><code>M</code>是标号为 <code>L</code>的三地址语句所产生的若干条目标代码中的第一条指令标号</p></blockquote></li><li><p><strong>过程调用</strong>三地址语句</p><ul><li><p>静态存储分配：<code>call callee</code>的目标代码</p><ul><li><p><code>ST callee.staticArea, #here + 20 // 存放返回地址</code></p></li><li><p><code>BR callee.codeArea // 控制流转向被调用过程</code></p><blockquote><p><code>callee.staticArea</code>：<code>callee</code>的活动记录在静态区中的起始位置</p><p><code>callee.codeArea</code>：<code>callee</code>的目标代码在静态代码区中的起始位置</p></blockquote></li></ul></li><li><p>栈式存储分配：<code>call callee</code>的目标代码</p><ul><li><code>ADD SP, SP, #caller.recordsize</code></li><li><code>ST 0(SP), #here + 16</code></li><li><code>BR callee.codeArea</code></li></ul></li></ul></li><li><p><strong>返回</strong>三地址语句</p><ul><li>静态存储分配：<code>return</code>的目标代码 <ul><li><code>BR *callee.staticArea</code></li></ul></li><li>栈式存储分配：<code>return</code>的目标代码 <ul><li><code>BR *0(SP) // 由被调用者执行</code></li><li><code>SUB SP, SP, #caller.recoredsize // 由调用者执行</code></li></ul></li></ul></li></ul><hr><p><em>指令开销：</em></p><ul><li>概念：存储开销，包括存储<strong>指令本身</strong>和指令涉及的其他<strong>地址</strong><ul><li>涉及立即数和变量地址寻址会额外增加一个开销</li><li>立即数会额外增加一个开销</li><li>其中寄存器不需要额外增加开销</li></ul></li></ul>`,8),T=[s,u,g,a,p,d,c,b,m,h,_,v,k,q,x,S,B,L,f,R];function E(D,w){return e(),t("div",null,T)}const O=i(r,[["render",E],["__file","CompilePrinciple.html.vue"]]);export{O as default};
