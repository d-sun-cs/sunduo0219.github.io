const e=JSON.parse('{"key":"v-f2a896e0","path":"/notes/ComputerTheory/XV6LabSummary.html","title":"XV6LabSummary","lang":"en-US","frontmatter":{"title":"XV6LabSummary","category":["Computer Theory"],"abbrlink":"8ecd89a3","date":"2023-01-05T11:24:08.000Z","tag":["Computer","Operation System","XV6","MIT","Lab"],"description":"Lab 4: traps Basic Theory Why to trap: Conversion between user mode and kernel mode What can supervisor actually do: Read or write control registers Use PTEs with 0 in PTE_U Still limited in virtual address set by page table When to trap or What leads to trap: Syscall Fault or Abort Device We also call Syscall and Fault as Software Interrupt, Internal Interrupt or Exception Key point of traps: Isolation &amp; Security Some relevant hardware registers / Control registers: pc: program counter mode: mark supervisor mode or user mode satp: supervisor address translation and protection, points to physical memory of page table stvec: supervisor trap vector base address, points to base memory of instructions handling traps sepc: supervisor exception program counter, keep value of pc when handling traps sscratch: supervisor scratch, keep virtual address of trapframe page to exchange with a0 scause: supervisor cause, keep the trap reason How to trap / Procedure of trap (take syscall as an example): Syscall function jump to usys.S and execute two instructions: Store syscall number into a7 Call ecall instruction ecall do three things by hardware: Disable interrupts Mark the mode to supervisor mode Keep pc in sepc Set pc to stvec and jump to uservec in trampoline.S ecall do only these things for more flexibility to software Kernel executes uservec in trampoline.S Exchange a0 and sscratch So now a0 keeps trapframe page, sscratch keeps a0’s old value Keep 32 user’s register in trapframe Set stack pointer to kernel stack (getting from trapframe) Set t0 to pointer of usertrap() (getting from trapframe) Set t1 to kernel page table and exchange satp and t1 (getting from trapframe) Now program keeps normal for trampoline page having same map in both user page table and kernel page table uservec jumps to usertrap() in trap.c usertrap() handles this trap Set stvec to kernelvec Traps can be triggered in kernel space, different from user space Keep sepc in trapframe May it change to another process and also trigger traps to overwrite sepc Check cause for this trap and handle it (If syscall, enable interrupts) Call usertrapret() usertrapret() finish some works to return to user space Disable interrupts Set stvec to uservec in trampoline.S Store kernel page table into trapframe Store kernel stack pointer into trapframe Store usertrap into trapframe Modify sstatus to ensure returning to user mode and interrupt on Set sepc to previous kept pc Jump to userret in trampoline.S Kernel executes uservec in trampoline.S Set satp to user page table (getting from usertrapret()) Restore 32 user’s resgisters Exchange a0 and sscratch So now sscratch keeps trapframe page, a0 keeps syscall return value sret sret Mark the mode to user mode Set pc to sepc Enable interrupts Return to user space","head":[["meta",{"property":"og:url","content":"https://SunDocker.github.io/notes/ComputerTheory/XV6LabSummary.html"}],["meta",{"property":"og:site_name","content":"SunDocker"}],["meta",{"property":"og:title","content":"XV6LabSummary"}],["meta",{"property":"og:description","content":"Lab 4: traps Basic Theory Why to trap: Conversion between user mode and kernel mode What can supervisor actually do: Read or write control registers Use PTEs with 0 in PTE_U Still limited in virtual address set by page table When to trap or What leads to trap: Syscall Fault or Abort Device We also call Syscall and Fault as Software Interrupt, Internal Interrupt or Exception Key point of traps: Isolation &amp; Security Some relevant hardware registers / Control registers: pc: program counter mode: mark supervisor mode or user mode satp: supervisor address translation and protection, points to physical memory of page table stvec: supervisor trap vector base address, points to base memory of instructions handling traps sepc: supervisor exception program counter, keep value of pc when handling traps sscratch: supervisor scratch, keep virtual address of trapframe page to exchange with a0 scause: supervisor cause, keep the trap reason How to trap / Procedure of trap (take syscall as an example): Syscall function jump to usys.S and execute two instructions: Store syscall number into a7 Call ecall instruction ecall do three things by hardware: Disable interrupts Mark the mode to supervisor mode Keep pc in sepc Set pc to stvec and jump to uservec in trampoline.S ecall do only these things for more flexibility to software Kernel executes uservec in trampoline.S Exchange a0 and sscratch So now a0 keeps trapframe page, sscratch keeps a0’s old value Keep 32 user’s register in trapframe Set stack pointer to kernel stack (getting from trapframe) Set t0 to pointer of usertrap() (getting from trapframe) Set t1 to kernel page table and exchange satp and t1 (getting from trapframe) Now program keeps normal for trampoline page having same map in both user page table and kernel page table uservec jumps to usertrap() in trap.c usertrap() handles this trap Set stvec to kernelvec Traps can be triggered in kernel space, different from user space Keep sepc in trapframe May it change to another process and also trigger traps to overwrite sepc Check cause for this trap and handle it (If syscall, enable interrupts) Call usertrapret() usertrapret() finish some works to return to user space Disable interrupts Set stvec to uservec in trampoline.S Store kernel page table into trapframe Store kernel stack pointer into trapframe Store usertrap into trapframe Modify sstatus to ensure returning to user mode and interrupt on Set sepc to previous kept pc Jump to userret in trampoline.S Kernel executes uservec in trampoline.S Set satp to user page table (getting from usertrapret()) Restore 32 user’s resgisters Exchange a0 and sscratch So now sscratch keeps trapframe page, a0 keeps syscall return value sret sret Mark the mode to user mode Set pc to sepc Enable interrupts Return to user space"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2023-02-01T12:47:50.000Z"}],["meta",{"property":"article:tag","content":"Computer"}],["meta",{"property":"article:tag","content":"Operation System"}],["meta",{"property":"article:tag","content":"XV6"}],["meta",{"property":"article:tag","content":"MIT"}],["meta",{"property":"article:tag","content":"Lab"}],["meta",{"property":"article:published_time","content":"2023-01-05T11:24:08.000Z"}],["meta",{"property":"article:modified_time","content":"2023-02-01T12:47:50.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"XV6LabSummary\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-01-05T11:24:08.000Z\\",\\"dateModified\\":\\"2023-02-01T12:47:50.000Z\\",\\"author\\":[]}"]]},"headers":[{"level":2,"title":"Lab 4: traps","slug":"lab-4-traps","link":"#lab-4-traps","children":[{"level":3,"title":"Basic Theory","slug":"basic-theory","link":"#basic-theory","children":[]},{"level":3,"title":"Task Analysis","slug":"task-analysis","link":"#task-analysis","children":[]}]},{"level":2,"title":"Lab 5: xv6 lazy page allocation","slug":"lab-5-xv6-lazy-page-allocation","link":"#lab-5-xv6-lazy-page-allocation","children":[{"level":3,"title":"Basic Theory","slug":"basic-theory-1","link":"#basic-theory-1","children":[]},{"level":3,"title":"Task Analysis","slug":"task-analysis-1","link":"#task-analysis-1","children":[]}]},{"level":2,"title":"Lab 6: Copy-on-Write Fork for xv6","slug":"lab-6-copy-on-write-fork-for-xv6","link":"#lab-6-copy-on-write-fork-for-xv6","children":[{"level":3,"title":"Basic Theory","slug":"basic-theory-2","link":"#basic-theory-2","children":[]},{"level":3,"title":"Task Analysis","slug":"task-analysis-2","link":"#task-analysis-2","children":[]}]},{"level":2,"title":"Lab 7: Multithreading","slug":"lab-7-multithreading","link":"#lab-7-multithreading","children":[{"level":3,"title":"Basic Theory","slug":"basic-theory-3","link":"#basic-theory-3","children":[]},{"level":3,"title":"Task Analysis","slug":"task-analysis-3","link":"#task-analysis-3","children":[]}]},{"level":2,"title":"Lab 8: locks","slug":"lab-8-locks","link":"#lab-8-locks","children":[{"level":3,"title":"Basic Theory","slug":"basic-theory-4","link":"#basic-theory-4","children":[]},{"level":3,"title":"Task Analysis","slug":"task-analysis-4","link":"#task-analysis-4","children":[]}]},{"level":2,"title":"Lab 9: file system","slug":"lab-9-file-system","link":"#lab-9-file-system","children":[{"level":3,"title":"Basic Theory","slug":"basic-theory-5","link":"#basic-theory-5","children":[]},{"level":3,"title":"Task Analysis","slug":"task-analysis-5","link":"#task-analysis-5","children":[]}]},{"level":2,"title":"Lab10: mmap","slug":"lab10-mmap","link":"#lab10-mmap","children":[{"level":3,"title":"Basic Theory","slug":"basic-theory-6","link":"#basic-theory-6","children":[]},{"level":3,"title":"Task Analysis","slug":"task-analysis-6","link":"#task-analysis-6","children":[]}]}],"git":{"createdTime":1675255670000,"updatedTime":1675255670000,"contributors":[{"name":"SunDocker","email":"sundocker@qq.com","commits":1}]},"readingTime":{"minutes":9.66,"words":2898},"filePathRelative":"notes/ComputerTheory/XV6LabSummary.md","localizedDate":"January 5, 2023","excerpt":"<h2> Lab 4: traps</h2>\\n<h3> Basic Theory</h3>\\n<ul>\\n<li>\\n<p>Why to trap: Conversion between user mode and kernel mode</p>\\n<ul>\\n<li>\\n<p>What can supervisor actually do:</p>\\n<ul>\\n<li>Read or write <strong>control registers</strong></li>\\n<li>Use PTEs with 0 in <code>PTE_U</code></li>\\n</ul>\\n<blockquote>\\n<p>Still limited in <strong>virtual address</strong> set by page table</p>\\n</blockquote>\\n</li>\\n</ul>\\n</li>\\n<li>\\n<p>When to trap or What leads to trap:</p>\\n<ul>\\n<li>Syscall</li>\\n<li>Fault or Abort</li>\\n<li>Device</li>\\n</ul>\\n<blockquote>\\n<p>We also call Syscall and Fault as <strong><em>Software Interrupt</em>, Internal Interrupt or Exception</strong></p>\\n</blockquote>\\n</li>\\n<li>\\n<p>Key point of traps: <strong>Isolation &amp; Security</strong></p>\\n</li>\\n<li>\\n<p>Some relevant hardware registers / <strong>Control registers</strong>:</p>\\n<ul>\\n<li>pc: program counter</li>\\n<li>mode: mark supervisor mode or user mode</li>\\n<li>satp: supervisor <strong>address translation</strong> and protection, points to physical memory of page table</li>\\n<li>stvec: supervisor <strong>trap vector</strong> base address, points to base memory of instructions handling traps</li>\\n<li>sepc: supervisor exception program counter, <strong>keep value of pc</strong> when handling traps</li>\\n<li>sscratch: supervisor scratch, keep virtual address of <strong>trapframe page</strong> to exchange with a0</li>\\n<li>scause: supervisor cause, keep the trap <strong>reason</strong></li>\\n</ul>\\n</li>\\n<li>\\n<p>How to trap / Procedure of trap (take syscall as an example):</p>\\n<ol>\\n<li>\\n<p>Syscall function jump to <strong>usys.S</strong> and execute two instructions:</p>\\n<ol>\\n<li>Store <strong>syscall number</strong> into a7</li>\\n<li>Call <strong><code>ecall</code> instruction</strong></li>\\n</ol>\\n</li>\\n<li>\\n<p><code>ecall</code> do three things by <strong>hardware</strong>:</p>\\n<ol start=\\"0\\">\\n<li>\\n<p>Disable interrupts</p>\\n</li>\\n<li>\\n<p>Mark the <strong>mode</strong> to supervisor mode</p>\\n</li>\\n<li>\\n<p>Keep <strong>pc</strong> in sepc</p>\\n</li>\\n<li>\\n<p>Set pc to <strong>stvec</strong> and jump to <code>uservec</code> in trampoline.S</p>\\n</li>\\n</ol>\\n<blockquote>\\n<p><code>ecall</code> do only these things for <strong>more flexibility to software</strong></p>\\n</blockquote>\\n</li>\\n<li>\\n<p>Kernel executes <code>uservec</code> in trampoline.S</p>\\n<ol>\\n<li>\\n<p>Exchange a0 and sscratch</p>\\n<blockquote>\\n<p>So now a0 keeps trapframe page, sscratch keeps a0’s old value</p>\\n</blockquote>\\n</li>\\n<li>\\n<p>Keep <strong>32 user’s register</strong> in trapframe</p>\\n</li>\\n<li>\\n<p>Set stack pointer to <strong>kernel stack</strong> (getting from trapframe)</p>\\n</li>\\n<li>\\n<p>Set t0 to <strong>pointer of <code>usertrap()</code></strong> (getting from trapframe)</p>\\n</li>\\n<li>\\n<p>Set t1 to <strong>kernel page table</strong> and exchange satp and t1 (getting from trapframe)</p>\\n<blockquote>\\n<p>Now program keeps normal for <strong>trampoline page having same map</strong> in both user page table and kernel page table</p>\\n</blockquote>\\n</li>\\n<li>\\n<p><code>uservec</code> jumps to <code>usertrap()</code> in trap.c</p>\\n</li>\\n</ol>\\n</li>\\n<li>\\n<p><code>usertrap()</code> handles this trap</p>\\n<ol>\\n<li>\\n<p>Set <strong>stvec</strong> to <code>kernelvec</code></p>\\n<blockquote>\\n<p>Traps can be triggered in kernel space, different from user space</p>\\n</blockquote>\\n</li>\\n<li>\\n<p>Keep <strong>sepc</strong> in trapframe</p>\\n<blockquote>\\n<p>May it change to another process and also trigger traps to overwrite sepc</p>\\n</blockquote>\\n</li>\\n<li>\\n<p>Check <strong>cause</strong> for this trap and handle it (If syscall, enable interrupts)</p>\\n</li>\\n<li>\\n<p>Call <code>usertrapret()</code></p>\\n</li>\\n</ol>\\n</li>\\n<li>\\n<p><code>usertrapret()</code> finish some works to return to user space</p>\\n<ol>\\n<li>Disable interrupts</li>\\n<li>Set <strong>stvec</strong> to <code>uservec </code>in trampoline.S</li>\\n<li>Store <strong>kernel page table</strong> into trapframe</li>\\n<li>Store <strong>kernel stack pointer</strong> into trapframe</li>\\n<li>Store <code>usertrap</code> into trapframe</li>\\n<li>Modify <strong>sstatus</strong> to ensure returning to user mode and interrupt on</li>\\n<li>Set <strong>sepc</strong> to previous kept pc</li>\\n<li>Jump to <code>userret</code> in trampoline.S</li>\\n</ol>\\n</li>\\n<li>\\n<p>Kernel executes <code>uservec</code> in trampoline.S</p>\\n<ol>\\n<li>\\n<p>Set satp to <strong>user page table</strong> (getting from <code>usertrapret()</code>)</p>\\n</li>\\n<li>\\n<p>Restore 32 user’s resgisters</p>\\n</li>\\n<li>\\n<p>Exchange a0 and sscratch</p>\\n<blockquote>\\n<p>So now sscratch keeps trapframe page, a0 keeps syscall return value</p>\\n</blockquote>\\n</li>\\n<li>\\n<p><code>sret</code></p>\\n</li>\\n</ol>\\n</li>\\n<li>\\n<p><code>sret</code></p>\\n<ol>\\n<li>Mark the <strong>mode</strong> to user mode</li>\\n<li>Set <strong>pc</strong> to sepc</li>\\n<li>Enable interrupts</li>\\n</ol>\\n</li>\\n<li>\\n<p>Return to user space</p>\\n</li>\\n</ol>\\n</li>\\n</ul>","autoDesc":true}');export{e as data};
