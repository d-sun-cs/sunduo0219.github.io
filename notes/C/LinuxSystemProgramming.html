<!DOCTYPE html>
<html lang="en-US" data-theme="light">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-beta.60" />
    <meta name="theme" content="VuePress Theme Hope" />
    <meta property="og:url" content="https://www.sundocker.online/notes/C/LinuxSystemProgramming.html"><meta property="og:site_name" content="SunDocker"><meta property="og:title" content="Linux系统编程"><meta property="og:description" content="1 常用工具 1.1 gcc 工作流程概述： 1. 预处理：头文件展开、宏替换、去除注释 gcc -E xxx.c -o xxx.i xxx.i仍然是一个c文件 预处理工作本质是由cpp工具完成的，gcc命令会调用这个工具 2. 编译：将c文件编译成汇编文件 gcc -S xxx.i -o xxx.s 这一步时间往往是最长的 编译工作由gcc工具完成 ..."><meta property="og:type" content="article"><meta property="og:locale" content="en-US"><meta property="og:updated_time" content="2023-02-06T12:08:01.000Z"><meta property="article:tag" content="Computer"><meta property="article:tag" content="Linux"><meta property="article:published_time" content="2022-10-10T11:40:02.000Z"><meta property="article:modified_time" content="2023-02-06T12:08:01.000Z"><script type="application/ld+json">{"@context":"https://schema.org","@type":"Article","headline":"Linux系统编程","image":[""],"datePublished":"2022-10-10T11:40:02.000Z","dateModified":"2023-02-06T12:08:01.000Z","author":[]}</script><title>Linux系统编程 | SunDocker</title><meta name="description" content="1 常用工具 1.1 gcc 工作流程概述： 1. 预处理：头文件展开、宏替换、去除注释 gcc -E xxx.c -o xxx.i xxx.i仍然是一个c文件 预处理工作本质是由cpp工具完成的，gcc命令会调用这个工具 2. 编译：将c文件编译成汇编文件 gcc -S xxx.i -o xxx.s 这一步时间往往是最长的 编译工作由gcc工具完成 ...">
    <style>
      :root {
        --bg-color: #fff;
      }

      html[data-theme="dark"] {
        --bg-color: #1d1e1f;
      }

      html,
      body {
        background: var(--bg-color);
      }
    </style>
    <script>
      const userMode = localStorage.getItem("vuepress-theme-hope-scheme");
      const systemDarkMode =
        window.matchMedia &&
        window.matchMedia("(prefers-color-scheme: dark)").matches;

      if (userMode === "dark" || (userMode !== "light" && systemDarkMode)) {
        document.querySelector("html").setAttribute("data-theme", "dark");
      }
    </script>
    <link rel="preload" href="/assets/style-4642d12a.css" as="style"><link rel="stylesheet" href="/assets/style-4642d12a.css">
    <link rel="modulepreload" href="/assets/app-92a4b31c.js"><link rel="modulepreload" href="/assets/framework-1f74d948.js"><link rel="modulepreload" href="/assets/LinuxSystemProgramming.html-c848bfbb.js"><link rel="modulepreload" href="/assets/LinuxSystemProgramming.html-47932d79.js">
  </head>
  <body>
    <div id="app"><!--[--><!--[--><!--[--><span tabindex="-1"></span><a href="#main-content" class="skip-link sr-only">Skip to main content</a><!--]--><div class="theme-container has-toc"><!--[--><header class="navbar" id="navbar"><div class="navbar-start"><button class="toggle-sidebar-button" title="Toggle Sidebar"><span class="icon"></span></button><!--[--><!----><!--]--><a href="/" class="brand"><img class="logo" src="/logo.svg" alt="SunDocker"><!----><span class="site-name hide-in-pad">SunDocker</span></a><!--[--><!----><!--]--></div><div class="navbar-center"><!--[--><!----><!--]--><nav class="nav-links"><div class="nav-item hide-in-mobile"><a href="/" class="nav-link" aria-label="Blog Home"><span class="font-icon icon iconfont icon-home" style=""></span>Blog Home<!----></a></div><div class="nav-item hide-in-mobile"><a href="/demo/" class="nav-link" aria-label="Demo"><span class="font-icon icon iconfont icon-discover" style=""></span>Demo<!----></a></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="Posts"><span class="title"><span class="font-icon icon iconfont icon-edit" style=""></span>Posts</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>Apple</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/posts/apple/1.html" class="nav-link" aria-label="Apple1"><span class="font-icon icon iconfont icon-edit" style=""></span>Apple1<!----></a></li><li class="dropdown-subitem"><a href="/posts/apple/2.html" class="nav-link" aria-label="Apple2"><span class="font-icon icon iconfont icon-edit" style=""></span>Apple2<!----></a></li><li class="dropdown-subitem"><a href="/posts/apple/3.html" class="nav-link" aria-label="Apple 3"><span class="font-icon icon iconfont icon-edit" style=""></span>Apple 3<!----></a></li><li class="dropdown-subitem"><a href="/posts/apple/4.html" class="nav-link" aria-label="Apple 4"><span class="font-icon icon iconfont icon-edit" style=""></span>Apple 4<!----></a></li></ul></li><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>Banana</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/posts/banana/1.html" class="nav-link" aria-label="Banana 1"><span class="font-icon icon iconfont icon-edit" style=""></span>Banana 1<!----></a></li><li class="dropdown-subitem"><a href="/posts/banana/2.html" class="nav-link" aria-label="Banana 2"><span class="font-icon icon iconfont icon-edit" style=""></span>Banana 2<!----></a></li><li class="dropdown-subitem"><a href="/posts/banana/3.html" class="nav-link" aria-label="Banana 3"><span class="font-icon icon iconfont icon-edit" style=""></span>Banana 3<!----></a></li><li class="dropdown-subitem"><a href="/posts/banana/4.html" class="nav-link" aria-label="Banana 4"><span class="font-icon icon iconfont icon-edit" style=""></span>Banana 4<!----></a></li></ul></li><li class="dropdown-item"><a href="/posts/cherry.html" class="nav-link" aria-label="Cherry"><span class="font-icon icon iconfont icon-edit" style=""></span>Cherry<!----></a></li><li class="dropdown-item"><a href="/posts/dragonfruit.html" class="nav-link" aria-label="Dragon Fruit"><span class="font-icon icon iconfont icon-edit" style=""></span>Dragon Fruit<!----></a></li><li class="dropdown-item"><a href="/posts/tomato.html" class="nav-link" aria-label="Tomato"><span class="font-icon icon iconfont icon-edit" style=""></span>Tomato<!----></a></li><li class="dropdown-item"><a href="/posts/strawberry.html" class="nav-link" aria-label="Strawberry"><span class="font-icon icon iconfont icon-edit" style=""></span>Strawberry<!----></a></li></ul></button></div></div><div class="nav-item hide-in-mobile"><a href="https://theme-hope.vuejs.press/zh/" rel="noopener noreferrer" target="_blank" aria-label="V2 Docs" class="nav-link"><span class="font-icon icon iconfont icon-note" style=""></span>V2 Docs<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!----></a></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="Knowledge Tree"><span class="title"><span class="font-icon icon iconfont icon-repo" style=""></span>Knowledge Tree</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>Computer Theory</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/notes/ComputerTheory/OperationSystem.html" class="nav-link" aria-label="Operation System"><span class="font-icon icon iconfont icon-note" style=""></span>Operation System<!----></a></li><li class="dropdown-subitem"><a href="/notes/ComputerTheory/DataStructure.html" class="nav-link" aria-label="Data Structure"><span class="font-icon icon iconfont icon-note" style=""></span>Data Structure<!----></a></li><li class="dropdown-subitem"><a href="/notes/ComputerTheory/ComputerNetwork.html" class="nav-link" aria-label="Computer Network"><span class="font-icon icon iconfont icon-note" style=""></span>Computer Network<!----></a></li><li class="dropdown-subitem"><a href="/notes/ComputerTheory/DatabaseSystem.html" class="nav-link" aria-label="Database System"><span class="font-icon icon iconfont icon-note" style=""></span>Database System<!----></a></li><li class="dropdown-subitem"><a href="/notes/ComputerTheory/CompositionPrinciple.html" class="nav-link" aria-label="Composition Principle of Computer"><span class="font-icon icon iconfont icon-note" style=""></span>Composition Principle of Computer<!----></a></li><li class="dropdown-subitem"><a href="/notes/ComputerTheory/DesignPatterns.html" class="nav-link" aria-label="Design Patterns"><span class="font-icon icon iconfont icon-note" style=""></span>Design Patterns<!----></a></li><li class="dropdown-subitem"><a href="/notes/ComputerTheory/CompilePrinciple.html" class="nav-link" aria-label="Compile Principle"><span class="font-icon icon iconfont icon-note" style=""></span>Compile Principle<!----></a></li><li class="dropdown-subitem"><a href="/notes/ComputerTheory/XV6LabSummary.html" class="nav-link" aria-label="XV6 Lab Summary"><span class="font-icon icon iconfont icon-note" style=""></span>XV6 Lab Summary<!----></a></li></ul></li><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>Java</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/notes/Java/JavaSE.html" class="nav-link" aria-label="JavaSE"><span class="font-icon icon iconfont icon-note" style=""></span>JavaSE<!----></a></li><li class="dropdown-subitem"><a href="/notes/Java/JakartaServlet" class="nav-link" aria-label="Servlet"><span class="font-icon icon iconfont icon-note" style=""></span>Servlet<!----></a></li><li class="dropdown-subitem"><a href="/notes/Java/JDBC.html" class="nav-link" aria-label="JDBC"><span class="font-icon icon iconfont icon-note" style=""></span>JDBC<!----></a></li><li class="dropdown-subitem"><a href="/notes/Java/Spring" class="nav-link" aria-label="Spring"><span class="font-icon icon iconfont icon-note" style=""></span>Spring<!----></a></li><li class="dropdown-subitem"><a href="/notes/Java/MyBatis.html" class="nav-link" aria-label="MyBatis"><span class="font-icon icon iconfont icon-note" style=""></span>MyBatis<!----></a></li><li class="dropdown-subitem"><a href="/notes/Java/SpringMVC.html" class="nav-link" aria-label="Spring MVC"><span class="font-icon icon iconfont icon-note" style=""></span>Spring MVC<!----></a></li><li class="dropdown-subitem"><a href="/notes/Java/SpringBoot.html" class="nav-link" aria-label="Spring Boot"><span class="font-icon icon iconfont icon-note" style=""></span>Spring Boot<!----></a></li><li class="dropdown-subitem"><a href="/notes/Java/SpringCloud.html" class="nav-link" aria-label="Spring Cloud"><span class="font-icon icon iconfont icon-note" style=""></span>Spring Cloud<!----></a></li><li class="dropdown-subitem"><a href="/notes/Java/JUC.html" class="nav-link" aria-label="JUC"><span class="font-icon icon iconfont icon-note" style=""></span>JUC<!----></a></li><li class="dropdown-subitem"><a href="/notes/Java/Java-gRPC.html" class="nav-link" aria-label="Java gRPC"><span class="font-icon icon iconfont icon-note" style=""></span>Java gRPC<!----></a></li><li class="dropdown-subitem"><a href="/notes/Java/Netty.html" class="nav-link" aria-label="Netty"><span class="font-icon icon iconfont icon-note" style=""></span>Netty<!----></a></li><li class="dropdown-subitem"><a href="/notes/Java/Kotlin.html" class="nav-link" aria-label="Kotlin"><span class="font-icon icon iconfont icon-note" style=""></span>Kotlin<!----></a></li></ul></li><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>Data Persistence</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/notes/DataPersistence/MySQL.html" class="nav-link" aria-label="MySQL"><span class="font-icon icon iconfont icon-note" style=""></span>MySQL<!----></a></li><li class="dropdown-subitem"><a href="/notes/DataPersistence/Redis.html" class="nav-link" aria-label="Redis"><span class="font-icon icon iconfont icon-note" style=""></span>Redis<!----></a></li></ul></li><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>Frontend</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/notes/Frontend/HTML.html" class="nav-link" aria-label="HTML"><span class="font-icon icon iconfont icon-note" style=""></span>HTML<!----></a></li><li class="dropdown-subitem"><a href="/notes/Frontend/JavaScript.html" class="nav-link" aria-label="JavaScript"><span class="font-icon icon iconfont icon-note" style=""></span>JavaScript<!----></a></li><li class="dropdown-subitem"><a href="/notes/Frontend/CSS.html" class="nav-link" aria-label="CSS"><span class="font-icon icon iconfont icon-note" style=""></span>CSS<!----></a></li><li class="dropdown-subitem"><a href="/notes/Frontend/AJAX" class="nav-link" aria-label="AJAX"><span class="font-icon icon iconfont icon-note" style=""></span>AJAX<!----></a></li><li class="dropdown-subitem"><a href="/notes/Frontend/Vue.html" class="nav-link" aria-label="Vue"><span class="font-icon icon iconfont icon-note" style=""></span>Vue<!----></a></li><li class="dropdown-subitem"><a href="/notes/Frontend/uni-app.html" class="nav-link" aria-label="uni-app"><span class="font-icon icon iconfont icon-note" style=""></span>uni-app<!----></a></li></ul></li><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>Golang</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/notes/Golang/Golang.html" class="nav-link" aria-label="Golang"><span class="font-icon icon iconfont icon-note" style=""></span>Golang<!----></a></li><li class="dropdown-subitem"><a href="/notes/Golang/Gin.html" class="nav-link" aria-label="Gin"><span class="font-icon icon iconfont icon-note" style=""></span>Gin<!----></a></li><li class="dropdown-subitem"><a href="/notes/Golang/Go-gRPC.html" class="nav-link" aria-label="Go gRPC"><span class="font-icon icon iconfont icon-note" style=""></span>Go gRPC<!----></a></li></ul></li><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>Operations</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/notes/Operations/Linux.html" class="nav-link" aria-label="Linux"><span class="font-icon icon iconfont icon-note" style=""></span>Linux<!----></a></li><li class="dropdown-subitem"><a href="/notes/Operations/Docker.html" class="nav-link" aria-label="Docker"><span class="font-icon icon iconfont icon-note" style=""></span>Docker<!----></a></li><li class="dropdown-subitem"><a href="/notes/Operations/Nginx.html" class="nav-link" aria-label="Nginx"><span class="font-icon icon iconfont icon-note" style=""></span>Nginx<!----></a></li><li class="dropdown-subitem"><a href="/notes/Operations/Kubernetes.html" class="nav-link" aria-label="Kubernetes"><span class="font-icon icon iconfont icon-note" style=""></span>Kubernetes<!----></a></li></ul></li><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>Project Mangement</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/notes/ProjectManagement/Git.html" class="nav-link" aria-label="Git"><span class="font-icon icon iconfont icon-note" style=""></span>Git<!----></a></li><li class="dropdown-subitem"><a href="/notes/ProjectManagement/Maven.html" class="nav-link" aria-label="Maven"><span class="font-icon icon iconfont icon-note" style=""></span>Maven<!----></a></li><li class="dropdown-subitem"><a href="/notes/ProjectManagement/Gradle.html" class="nav-link" aria-label="Gradle"><span class="font-icon icon iconfont icon-note" style=""></span>Gradle<!----></a></li></ul></li><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>C</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a aria-current="page" href="/notes/C/LinuxSystemProgramming.html" class="router-link-active router-link-exact-active nav-link active" aria-label="Linux System Programming"><span class="font-icon icon iconfont icon-note" style=""></span>Linux System Programming<!----></a></li><li class="dropdown-subitem"><a href="/notes/C/Cpp.html" class="nav-link" aria-label="C++"><span class="font-icon icon iconfont icon-note" style=""></span>C++<!----></a></li></ul></li><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>AI</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/notes/AI/Hadoop.html" class="nav-link" aria-label="Hadoop"><span class="font-icon icon iconfont icon-note" style=""></span>Hadoop<!----></a></li><li class="dropdown-subitem"><a href="/notes/AI/DataMining.html" class="nav-link" aria-label="Data Mining"><span class="font-icon icon iconfont icon-note" style=""></span>Data Mining<!----></a></li><li class="dropdown-subitem"><a href="/notes/AI/DataAnalysis.html" class="nav-link" aria-label="Data Analysis"><span class="font-icon icon iconfont icon-note" style=""></span>Data Analysis<!----></a></li><li class="dropdown-subitem"><a href="/notes/AI/MachineLearning.html" class="nav-link" aria-label="Machine Learning"><span class="font-icon icon iconfont icon-note" style=""></span>Machine Learning<!----></a></li></ul></li></ul></button></div></div></nav><!--[--><!----><!--]--></div><div class="navbar-end"><!--[--><!----><!--]--><div class="nav-item"><div class="dropdown-wrapper i18n-dropdown"><button class="dropdown-title" type="button" aria-label="Select language"><!--[--><svg xmlns="http://www.w3.org/2000/svg" class="icon i18n-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="i18n icon" style="width:1rem;height:1rem;vertical-align:middle;"><path d="M379.392 460.8 494.08 575.488l-42.496 102.4L307.2 532.48 138.24 701.44l-71.68-72.704L234.496 460.8l-45.056-45.056c-27.136-27.136-51.2-66.56-66.56-108.544h112.64c7.68 14.336 16.896 27.136 26.112 35.84l45.568 46.08 45.056-45.056C382.976 312.32 409.6 247.808 409.6 204.8H0V102.4h256V0h102.4v102.4h256v102.4H512c0 70.144-37.888 161.28-87.04 210.944L378.88 460.8zM576 870.4 512 1024H409.6l256-614.4H768l256 614.4H921.6l-64-153.6H576zM618.496 768h196.608L716.8 532.48 618.496 768z"></path></svg><!--]--><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><a aria-current="page" href="/notes/C/LinuxSystemProgramming.html" class="router-link-active router-link-exact-active nav-link active" aria-label="English"><!---->English<!----></a></li><li class="dropdown-item"><a href="/zh/" class="nav-link" aria-label="简体中文"><!---->简体中文<!----></a></li></ul></button></div></div><div class="nav-item"><a class="repo-link" href="https://github.com/SunDocker/SunDocker.github.io" target="_blank" rel="noopener noreferrer" aria-label="GitHub"><svg xmlns="http://www.w3.org/2000/svg" class="icon github-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="github icon" style="width:1.25rem;height:1.25rem;vertical-align:middle;"><path d="M511.957 21.333C241.024 21.333 21.333 240.981 21.333 512c0 216.832 140.544 400.725 335.574 465.664 24.49 4.395 32.256-10.07 32.256-23.083 0-11.69.256-44.245 0-85.205-136.448 29.61-164.736-64.64-164.736-64.64-22.315-56.704-54.4-71.765-54.4-71.765-44.587-30.464 3.285-29.824 3.285-29.824 49.195 3.413 75.179 50.517 75.179 50.517 43.776 75.008 114.816 53.333 142.762 40.79 4.523-31.66 17.152-53.377 31.19-65.537-108.971-12.458-223.488-54.485-223.488-242.602 0-53.547 19.114-97.323 50.517-131.67-5.035-12.33-21.93-62.293 4.779-129.834 0 0 41.258-13.184 134.912 50.346a469.803 469.803 0 0 1 122.88-16.554c41.642.213 83.626 5.632 122.88 16.554 93.653-63.488 134.784-50.346 134.784-50.346 26.752 67.541 9.898 117.504 4.864 129.834 31.402 34.347 50.474 78.123 50.474 131.67 0 188.586-114.73 230.016-224.042 242.09 17.578 15.232 33.578 44.672 33.578 90.454v135.85c0 13.142 7.936 27.606 32.854 22.87C862.25 912.597 1002.667 728.747 1002.667 512c0-271.019-219.648-490.667-490.71-490.667z"></path></svg></a></div><div class="nav-item hide-in-mobile"><button class="outlook-button" tabindex="-1" ariahidden="true"><svg xmlns="http://www.w3.org/2000/svg" class="icon outlook-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="outlook icon"><path d="M224 800c0 9.6 3.2 44.8 6.4 54.4 6.4 48-48 76.8-48 76.8s80 41.6 147.2 0 134.4-134.4 38.4-195.2c-22.4-12.8-41.6-19.2-57.6-19.2C259.2 716.8 227.2 761.6 224 800zM560 675.2l-32 51.2c-51.2 51.2-83.2 32-83.2 32 25.6 67.2 0 112-12.8 128 25.6 6.4 51.2 9.6 80 9.6 54.4 0 102.4-9.6 150.4-32l0 0c3.2 0 3.2-3.2 3.2-3.2 22.4-16 12.8-35.2 6.4-44.8-9.6-12.8-12.8-25.6-12.8-41.6 0-54.4 60.8-99.2 137.6-99.2 6.4 0 12.8 0 22.4 0 12.8 0 38.4 9.6 48-25.6 0-3.2 0-3.2 3.2-6.4 0-3.2 3.2-6.4 3.2-6.4 6.4-16 6.4-16 6.4-19.2 9.6-35.2 16-73.6 16-115.2 0-105.6-41.6-198.4-108.8-268.8C704 396.8 560 675.2 560 675.2zM224 419.2c0-28.8 22.4-51.2 51.2-51.2 28.8 0 51.2 22.4 51.2 51.2 0 28.8-22.4 51.2-51.2 51.2C246.4 470.4 224 448 224 419.2zM320 284.8c0-22.4 19.2-41.6 41.6-41.6 22.4 0 41.6 19.2 41.6 41.6 0 22.4-19.2 41.6-41.6 41.6C339.2 326.4 320 307.2 320 284.8zM457.6 208c0-12.8 12.8-25.6 25.6-25.6 12.8 0 25.6 12.8 25.6 25.6 0 12.8-12.8 25.6-25.6 25.6C470.4 233.6 457.6 220.8 457.6 208zM128 505.6C128 592 153.6 672 201.6 736c28.8-60.8 112-60.8 124.8-60.8-16-51.2 16-99.2 16-99.2l316.8-422.4c-48-19.2-99.2-32-150.4-32C297.6 118.4 128 291.2 128 505.6zM764.8 86.4c-22.4 19.2-390.4 518.4-390.4 518.4-22.4 28.8-12.8 76.8 22.4 99.2l9.6 6.4c35.2 22.4 80 12.8 99.2-25.6 0 0 6.4-12.8 9.6-19.2 54.4-105.6 275.2-524.8 288-553.6 6.4-19.2-3.2-32-19.2-32C777.6 76.8 771.2 80 764.8 86.4z"></path></svg><div class="outlook-dropdown"><!----></div></button></div><!--[--><button class="search-pro-button" role="search" aria-label="Search"><svg xmlns="http://www.w3.org/2000/svg" class="icon search-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="search icon"><path d="M192 480a256 256 0 1 1 512 0 256 256 0 0 1-512 0m631.776 362.496-143.2-143.168A318.464 318.464 0 0 0 768 480c0-176.736-143.264-320-320-320S128 303.264 128 480s143.264 320 320 320a318.016 318.016 0 0 0 184.16-58.592l146.336 146.368c12.512 12.48 32.768 12.48 45.28 0 12.48-12.512 12.48-32.768 0-45.28"></path></svg></button><!--]--><!--[--><!----><!--]--><button class="toggle-navbar-button" aria-label="Toggle Navbar" aria-expanded="false" aria-controls="nav-screen"><span class="button-container"><span class="button-top"></span><span class="button-middle"></span><span class="button-bottom"></span></span></button></div></header><!----><!--]--><!----><div class="toggle-sidebar-wrapper"><span class="arrow start"></span></div><aside class="sidebar" id="sidebar"><!--[--><!----><!--]--><ul class="sidebar-links"><li><!--[--><a href="/notes/" class="nav-link sidebar-link sidebar-page" aria-label="Knowledge Tree"><!---->Knowledge Tree<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/notes/slides.html" class="nav-link sidebar-link sidebar-page" aria-label="Learning Sharing Slides"><span class="font-icon icon iconfont icon-slides" style=""></span>Learning Sharing Slides<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><section class="sidebar-group"><button class="sidebar-heading clickable active"><span class="font-icon icon iconfont icon-note" style=""></span><span class="title">Notes</span><span class="arrow down"></span></button><ul class="sidebar-links"><li><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">A I</span><span class="arrow end"></span></button><!----></section></li><li><section class="sidebar-group"><button class="sidebar-heading clickable active"><!----><span class="title">C</span><span class="arrow down"></span></button><ul class="sidebar-links"><li><!--[--><a href="/notes/C/Cpp.html" class="nav-link sidebar-link sidebar-page" aria-label="C++"><!---->C++<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-current="page" href="/notes/C/LinuxSystemProgramming.html" class="router-link-active router-link-exact-active nav-link active sidebar-link sidebar-page active" aria-label="Linux系统编程"><!---->Linux系统编程<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/notes/C/LinuxSystemProgramming.html#_1-常用工具" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1 常用工具"><!---->1 常用工具<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/notes/C/LinuxSystemProgramming.html#_1-1-gcc" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.1 gcc"><!---->1.1 gcc<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/notes/C/LinuxSystemProgramming.html#_1-2-gdb" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.2 gdb"><!---->1.2 gdb<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/notes/C/LinuxSystemProgramming.html#_1-3-makefile" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.3 makefile"><!---->1.3 makefile<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/notes/C/LinuxSystemProgramming.html#_2-内存与文件系统" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="2 内存与文件系统"><!---->2 内存与文件系统<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/notes/C/LinuxSystemProgramming.html#_2-1-内存管理" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="2.1 内存管理"><!---->2.1 内存管理<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/notes/C/LinuxSystemProgramming.html#_2-3-io" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="2.3 IO"><!---->2.3 IO<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/notes/C/LinuxSystemProgramming.html#_3-进程与线程" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="3 进程与线程"><!---->3 进程与线程<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/notes/C/LinuxSystemProgramming.html#_3-1-进程相关数据结构" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="3.1 进程相关数据结构"><!---->3.1 进程相关数据结构<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/notes/C/LinuxSystemProgramming.html#_3-2-进程控制" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="3.2 进程控制"><!---->3.2 进程控制<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/notes/C/LinuxSystemProgramming.html#_3-3-进程间通信" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="3.3 进程间通信"><!---->3.3 进程间通信<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/notes/C/LinuxSystemProgramming.html#_3-4-进程信号" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="3.4 进程信号"><!---->3.4 进程信号<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/notes/C/LinuxSystemProgramming.html#_3-5-竞态条件" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="3.5 竞态条件"><!---->3.5 竞态条件<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/notes/C/LinuxSystemProgramming.html#_3-6-进程组与会话" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="3.6 进程组与会话"><!---->3.6 进程组与会话<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/notes/C/LinuxSystemProgramming.html#_3-7-线程基础" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="3.7 线程基础"><!---->3.7 线程基础<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/notes/C/LinuxSystemProgramming.html#_3-8-线程和进程的同步与互斥" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="3.8 线程和进程的同步与互斥"><!---->3.8 线程和进程的同步与互斥<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/notes/C/LinuxSystemProgramming.html#_4-网络编程" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="4 网络编程"><!---->4 网络编程<!----></a><ul class="sidebar-sub-headers"></ul></li></ul><!--]--></li></ul></section></li><li><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">Computer Theory</span><span class="arrow end"></span></button><!----></section></li><li><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">Data Persistence</span><span class="arrow end"></span></button><!----></section></li><li><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">Frontend</span><span class="arrow end"></span></button><!----></section></li><li><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">Golang</span><span class="arrow end"></span></button><!----></section></li><li><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">Java</span><span class="arrow end"></span></button><!----></section></li><li><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">Life Sharing</span><span class="arrow end"></span></button><!----></section></li><li><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">Operations</span><span class="arrow end"></span></button><!----></section></li><li><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">Project Management</span><span class="arrow end"></span></button><!----></section></li></ul></section></li></ul><!--[--><!----><!--]--></aside><!--[--><main class="page" id="main-content"><!--[--><!----><nav class="breadcrumb disable"></nav><div class="page-title"><h1><!---->Linux系统编程</h1><div class="page-info"><span class="page-author-info" aria-label="Author🖊" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon author-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="author icon"><path d="M649.6 633.6c86.4-48 147.2-144 147.2-249.6 0-160-128-288-288-288s-288 128-288 288c0 108.8 57.6 201.6 147.2 249.6-121.6 48-214.4 153.6-240 288-3.2 9.6 0 19.2 6.4 25.6 3.2 9.6 12.8 12.8 22.4 12.8h704c9.6 0 19.2-3.2 25.6-12.8 6.4-6.4 9.6-16 6.4-25.6-25.6-134.4-121.6-240-243.2-288z"></path></svg><span><a class="page-author-item" href="https://sundocker.online" target="_blank" rel="noopener noreferrer">Dominic Sun</a></span><span property="author" content="Dominic Sun"></span></span><!----><span class="page-date-info" aria-label="Writing Date📅" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon calendar-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="calendar icon"><path d="M716.4 110.137c0-18.753-14.72-33.473-33.472-33.473-18.753 0-33.473 14.72-33.473 33.473v33.473h66.993v-33.473zm-334.87 0c0-18.753-14.72-33.473-33.473-33.473s-33.52 14.72-33.52 33.473v33.473h66.993v-33.473zm468.81 33.52H716.4v100.465c0 18.753-14.72 33.473-33.472 33.473a33.145 33.145 0 01-33.473-33.473V143.657H381.53v100.465c0 18.753-14.72 33.473-33.473 33.473a33.145 33.145 0 01-33.473-33.473V143.657H180.6A134.314 134.314 0 0046.66 277.595v535.756A134.314 134.314 0 00180.6 947.289h669.74a134.36 134.36 0 00133.94-133.938V277.595a134.314 134.314 0 00-133.94-133.938zm33.473 267.877H147.126a33.145 33.145 0 01-33.473-33.473c0-18.752 14.72-33.473 33.473-33.473h736.687c18.752 0 33.472 14.72 33.472 33.473a33.145 33.145 0 01-33.472 33.473z"></path></svg><span><!----></span><meta property="datePublished" content="2022-10-10T11:40:02.000Z"></span><!----><span class="page-reading-time-info" aria-label="Reading Time⌛" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon timer-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="timer icon"><path d="M799.387 122.15c4.402-2.978 7.38-7.897 7.38-13.463v-1.165c0-8.933-7.38-16.312-16.312-16.312H256.33c-8.933 0-16.311 7.38-16.311 16.312v1.165c0 5.825 2.977 10.874 7.637 13.592 4.143 194.44 97.22 354.963 220.201 392.763-122.204 37.542-214.893 196.511-220.2 389.397-4.661 5.049-7.638 11.651-7.638 19.03v5.825h566.49v-5.825c0-7.379-2.849-13.981-7.509-18.9-5.049-193.016-97.867-351.985-220.2-389.527 123.24-37.67 216.446-198.453 220.588-392.892zM531.16 450.445v352.632c117.674 1.553 211.787 40.778 211.787 88.676H304.097c0-48.286 95.149-87.382 213.728-88.676V450.445c-93.077-3.107-167.901-81.297-167.901-177.093 0-8.803 6.99-15.793 15.793-15.793 8.803 0 15.794 6.99 15.794 15.793 0 80.261 63.69 145.635 142.01 145.635s142.011-65.374 142.011-145.635c0-8.803 6.99-15.793 15.794-15.793s15.793 6.99 15.793 15.793c0 95.019-73.789 172.82-165.96 177.093z"></path></svg><span>About 40 min</span><meta property="timeRequired" content="PT40M"></span><span class="page-category-info" aria-label="Category🌈" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon category-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="category icon"><path d="M148.41 106.992h282.176c22.263 0 40.31 18.048 40.31 40.31V429.48c0 22.263-18.047 40.31-40.31 40.31H148.41c-22.263 0-40.311-18.047-40.311-40.31V147.302c0-22.263 18.048-40.31 40.311-40.31zM147.556 553.478H429.73c22.263 0 40.311 18.048 40.311 40.31v282.176c0 22.263-18.048 40.312-40.31 40.312H147.555c-22.263 0-40.311-18.049-40.311-40.312V593.79c0-22.263 18.048-40.311 40.31-40.311zM593.927 106.992h282.176c22.263 0 40.31 18.048 40.31 40.31V429.48c0 22.263-18.047 40.31-40.31 40.31H593.927c-22.263 0-40.311-18.047-40.311-40.31V147.302c0-22.263 18.048-40.31 40.31-40.31zM730.22 920.502H623.926c-40.925 0-74.22-33.388-74.22-74.425V623.992c0-41.038 33.387-74.424 74.425-74.424h222.085c41.038 0 74.424 33.226 74.424 74.067v114.233c0 10.244-8.304 18.548-18.547 18.548s-18.548-8.304-18.548-18.548V623.635c0-20.388-16.746-36.974-37.33-36.974H624.13c-20.585 0-37.331 16.747-37.331 37.33v222.086c0 20.585 16.654 37.331 37.126 37.331H730.22c10.243 0 18.547 8.304 18.547 18.547 0 10.244-8.304 18.547-18.547 18.547z"></path></svg><span class="page-category-item category5 clickable" role="navigation">C &amp; C++</span><meta property="articleSection" content="C &amp; C++"></span><span class="page-tag-info" aria-label="Tag🏷" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon tag-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="tag icon"><path d="M939.902 458.563L910.17 144.567c-1.507-16.272-14.465-29.13-30.737-30.737L565.438 84.098h-.402c-3.215 0-5.726 1.005-7.634 2.913l-470.39 470.39a10.004 10.004 0 000 14.164l365.423 365.424c1.909 1.908 4.42 2.913 7.132 2.913s5.223-1.005 7.132-2.913l470.39-470.39c2.01-2.11 3.014-5.023 2.813-8.036zm-240.067-72.121c-35.458 0-64.286-28.828-64.286-64.286s28.828-64.285 64.286-64.285 64.286 28.828 64.286 64.285-28.829 64.286-64.286 64.286z"></path></svg><span class="page-tag-item tag3 clickable" role="navigation">Computer</span><span class="page-tag-item tag0 clickable" role="navigation">Linux</span><meta property="keywords" content="Computer,Linux"></span></div><hr></div><div class="toc-place-holder"><aside id="toc"><div class="toc-header">On This Page<button class="print-button" title="print"><svg xmlns="http://www.w3.org/2000/svg" class="icon print-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="print icon"><path d="M819.2 364.8h-44.8V128c0-17.067-14.933-32-32-32H281.6c-17.067 0-32 14.933-32 32v236.8h-44.8C145.067 364.8 96 413.867 96 473.6v192c0 59.733 49.067 108.8 108.8 108.8h44.8V896c0 17.067 14.933 32 32 32h460.8c17.067 0 32-14.933 32-32V774.4h44.8c59.733 0 108.8-49.067 108.8-108.8v-192c0-59.733-49.067-108.8-108.8-108.8zM313.6 160h396.8v204.8H313.6V160zm396.8 704H313.6V620.8h396.8V864zM864 665.6c0 25.6-19.2 44.8-44.8 44.8h-44.8V588.8c0-17.067-14.933-32-32-32H281.6c-17.067 0-32 14.933-32 32v121.6h-44.8c-25.6 0-44.8-19.2-44.8-44.8v-192c0-25.6 19.2-44.8 44.8-44.8h614.4c25.6 0 44.8 19.2 44.8 44.8v192z"></path></svg></button></div><div class="toc-wrapper"><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/notes/C/LinuxSystemProgramming.html#_1-常用工具" class="router-link-active router-link-exact-active toc-link level2">1 常用工具</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/notes/C/LinuxSystemProgramming.html#_1-1-gcc" class="router-link-active router-link-exact-active toc-link level3">1.1 gcc</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/notes/C/LinuxSystemProgramming.html#_1-2-gdb" class="router-link-active router-link-exact-active toc-link level3">1.2 gdb</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/notes/C/LinuxSystemProgramming.html#_1-3-makefile" class="router-link-active router-link-exact-active toc-link level3">1.3 makefile</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/notes/C/LinuxSystemProgramming.html#_2-内存与文件系统" class="router-link-active router-link-exact-active toc-link level2">2 内存与文件系统</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/notes/C/LinuxSystemProgramming.html#_2-1-内存管理" class="router-link-active router-link-exact-active toc-link level3">2.1 内存管理</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/notes/C/LinuxSystemProgramming.html#_2-3-io" class="router-link-active router-link-exact-active toc-link level3">2.3 IO</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/notes/C/LinuxSystemProgramming.html#_3-进程与线程" class="router-link-active router-link-exact-active toc-link level2">3 进程与线程</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/notes/C/LinuxSystemProgramming.html#_3-1-进程相关数据结构" class="router-link-active router-link-exact-active toc-link level3">3.1 进程相关数据结构</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/notes/C/LinuxSystemProgramming.html#_3-2-进程控制" class="router-link-active router-link-exact-active toc-link level3">3.2 进程控制</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/notes/C/LinuxSystemProgramming.html#_3-3-进程间通信" class="router-link-active router-link-exact-active toc-link level3">3.3 进程间通信</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/notes/C/LinuxSystemProgramming.html#_3-4-进程信号" class="router-link-active router-link-exact-active toc-link level3">3.4 进程信号</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/notes/C/LinuxSystemProgramming.html#_3-5-竞态条件" class="router-link-active router-link-exact-active toc-link level3">3.5 竞态条件</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/notes/C/LinuxSystemProgramming.html#_3-6-进程组与会话" class="router-link-active router-link-exact-active toc-link level3">3.6 进程组与会话</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/notes/C/LinuxSystemProgramming.html#_3-7-线程基础" class="router-link-active router-link-exact-active toc-link level3">3.7 线程基础</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/notes/C/LinuxSystemProgramming.html#_3-8-线程和进程的同步与互斥" class="router-link-active router-link-exact-active toc-link level3">3.8 线程和进程的同步与互斥</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/notes/C/LinuxSystemProgramming.html#_4-网络编程" class="router-link-active router-link-exact-active toc-link level2">4 网络编程</a></li><!----><!--]--></ul></div></aside></div><!----><div class="theme-hope-content"><h2 id="_1-常用工具" tabindex="-1"><a class="header-anchor" href="#_1-常用工具" aria-hidden="true">#</a> 1 常用工具</h2><h3 id="_1-1-gcc" tabindex="-1"><a class="header-anchor" href="#_1-1-gcc" aria-hidden="true">#</a> 1.1 gcc</h3><p><em>工作流程概述：</em></p><ol><li><p>预处理：<strong>头文件</strong>展开、<strong>宏</strong>替换、去除<strong>注释</strong></p><p><code>gcc -E xxx.c -o xxx.i</code></p><blockquote><p><code>xxx.i</code>仍然是一个<strong>c文件</strong></p><p>预处理工作本质是由<strong>cpp工具</strong>完成的，gcc命令会调用这个工具</p></blockquote></li><li><p>编译：将c文件编译成<strong>汇编文件</strong></p><p><code>gcc -S xxx.i -o xxx.s</code></p><blockquote><p>这一步时间往往是<strong>最长</strong>的</p><p>编译工作由<strong>gcc工具</strong>完成</p></blockquote></li><li><p>汇编：将汇编文件转换成<strong>二进制文件</strong></p><p><code>gcc -c xxx.s -o xxx.o</code></p><blockquote><p>汇编工作本质是由<strong>as工具</strong>完成的，gcc命令会调用这个工具</p></blockquote></li><li><p>链接：将<strong>函数库</strong>中相应的代码组合到目标文件中</p><p><code>gcc xxx.o -o xxx</code></p><blockquote><p>将所有相关的<code>.o</code>文件打包成一个<strong>可执行文件</strong>，并将<code>main</code>函数作为<strong>启动函数</strong></p><p>链接工作本质是由<strong>ld工具</strong>完成的，gcc命令会调用这个工具</p></blockquote><blockquote><p>可以直接调用链接的命令，这样会自动调用之前的三步：<code>gcc xxx.c -o xxx</code></p></blockquote></li></ol><hr><p><em>常用参数：</em></p><ul><li><p><code>-I 目录</code>：指定<strong>头文件</strong>所在目录</p><blockquote><p>头文件一般放在<code>include</code>目录下；如果是在<strong>同级目录</strong>就不用参数指定了</p></blockquote></li><li><p><code>-L 目录</code>：指定<strong>库文件</strong>所在目录</p><blockquote><p>库文件一般放在<code>lib</code>目录下</p></blockquote></li><li><p><code>-l 库名</code>：指定<strong>库文件</strong>的名字</p></li><li><p><code>-D 宏名</code>：指定一个宏</p><blockquote><p>经典使用场景是控制log的输出</p></blockquote></li><li><p><code>-O1</code>、<code>-O2</code>、<code>-O3</code>：生成汇编之前<strong>优化</strong>代码，<code>-O</code>后面数字越大，优化等级越大</p></li><li><p><code>-Wall</code>：输出<strong>警告</strong>信息</p></li><li><p><code>-g</code>：添加调试信息，之后可以用gdb工具调试</p></li></ul><hr><p><em>静态库：</em></p><ul><li><p>命名规则：<code>lib + 库的名字 + .a</code></p><blockquote><p><code>.a</code>文件一般放在<code>lib</code>目录下</p></blockquote></li><li><p>制作步骤</p><ol><li><p>生成<code>.o</code>文件：<code>gcc 所有需要的.c文件 -c -I 头文件所在目录</code></p></li><li><p>将生成的<code>.o</code>文件打包：<code>ar rcs lib库的名字.a 所有需要的.o文件</code></p><blockquote><p>使用<code>ar</code>打包工具</p></blockquote></li></ol></li><li><p>发布和使用静态库</p><ul><li>发布静态库</li><li>提供头文件，在源程序中引入</li><li>在编译时指定静态库，生成可执行程序： <ul><li><code>gcc 源程序.c lib库的名字.a -I 头文件所在目录 -o xxx</code></li><li><code>gcc 源程序.c -I 头文件所在目录 -L 静态库所在目录 -l 库的名字 -o xxx</code></li></ul></li><li>运行可执行程序</li></ul></li><li><p>查看组成静态库的<code>.o</code>文件：<code>nm lib库名.a</code></p><ul><li>打包的最小单元是<code>.o</code>文件，并不会直接把整个库打包</li></ul></li><li><p>静态库的优点和缺点</p><ul><li>优点 <ul><li>发布程序时，不需要再<strong>提供对应库</strong></li><li>加载静态库的<strong>速度</strong>快</li></ul></li><li>缺点 <ul><li>增加了应用程序的<strong>大小</strong></li><li>库发生<strong>更新</strong>后必须<strong>重新编译</strong>程序</li></ul></li></ul></li></ul><hr><p><em>共享库/动态库：</em></p><ul><li><p>命名规则：<code>lib + 库名 + .so</code></p></li><li><p>制作步骤</p><ol><li><p>生成与位置无关的<code>.o</code>文件：<code>gcc -fPIC -c 所有需要的.c文件</code></p><blockquote><p>生成静态库的时候，是与位置有关的<code>.o</code></p><ul><li>与位置有关的<code>.o</code>，直接“静态地”存放在**<code>.text</code>代码段**</li><li>与位置无关的<code>.o</code>，在程序运行时才会动态加载到<strong>虚拟地址空间的共享库</strong>中</li></ul></blockquote></li><li><p>将<code>.o</code>文件打包成共享库：<code>gcc -shared lib库名.so -o 所有需要的.o文件</code></p></li></ol></li><li><p>发布和使用共享库</p><ul><li><p>发布静态库</p></li><li><p>提供头文件，在源程序中引入</p></li><li><p>在编译时指定动态库，生成可执行程序：</p><ul><li><code>gcc 源程序.c lib库名.so -I 头文件所在目录 -o xxx</code></li><li><code>gcc 源程序.c -I 头文件所在目录 -L 共享库所在目录 -l 库的名字 -o xxx</code></li></ul></li><li><p>运行可执行程序</p><blockquote><p>解决自定义动态库无法加载的问题：</p><hr><p><code>ldd 可执行程序</code>可以查看程序<strong>依赖的所有共享库</strong></p><p>一般来说，程序都会依赖一个库，叫做动态链接器：<code>/lib64/ld-linux-x86-64.so.2</code></p><ul><li><p>动态链接器可以<strong>加载程序依赖的其他动态库</strong></p></li><li><p>动态链接器的查找规则：根据某些<strong>环境变量</strong>查找</p><blockquote><p>系统提供的动态库一般都放在<code>/lib</code>下（但不要把自己制作的库放进去</p><p>**环境变量<code>LD_LIBRARY_PATH</code>**也在动态链接器的查找范围内，且是优先被查找的</p></blockquote></li></ul><p>所以如果要使用自定义动态库，可以执行<code>export LD_LIBRARY_PATH = xxx</code>，让动态链接器能找到自定义动态库，这样可以临时生效，用于<strong>测试</strong></p><blockquote><p>如果不只要临时生效，可以把<code>export</code>语句写入<code>~/.bachrc</code>文件中再重启终端，但这种做法比较少见</p></blockquote><p>还可以使用<strong>配置文件</strong>的方式：</p><ol><li><p>以管理员权限修改<code>/etc/ld.so.conf</code>，将自定义动态库路径写入新行</p></li><li><p>使配置文件生效：<code>ldconfig -v</code></p><blockquote><p><code>-v</code>代表打印提示信息，也可以不加</p></blockquote></li></ol></blockquote></li></ul></li><li><p>动态库的优点和缺点</p><ul><li><p>优点</p><ul><li><p>不会把动态库打包到应用程序中，<strong>体积小</strong></p></li><li><p>库发生<strong>更新</strong>后可以不需要<strong>重新编译</strong>程序</p><blockquote><p>前提是<strong>接口</strong>没有发生太大变化</p></blockquote></li></ul></li><li><p>缺点</p><ul><li>发布程序时，还需要再<strong>提供对应库</strong></li><li>加载动态库的<strong>速度</strong>相对较慢</li></ul></li></ul></li></ul><h3 id="_1-2-gdb" tabindex="-1"><a class="header-anchor" href="#_1-2-gdb" aria-hidden="true">#</a> 1.2 gdb</h3><p><em>概述：</em></p><ul><li>GDB（GNU Debugger）是GCC的调试工具</li></ul><hr><p><em>常用指令：</em></p><blockquote><p>编译时需要加<code>-g</code>选项，通过<code>gdb 可执行程序</code>可以开启gdb调试</p></blockquote><ul><li><p>工作目录</p><ul><li><code>pwd</code>：查看当前工作目录</li><li><code>cd</code>：切换工作目录</li></ul></li><li><p>运行时参数</p><ul><li><code>set args 参数1 参数2 ...</code>：指定运行时参数</li><li><code>show args</code>：查看设置好的运行时参数</li></ul></li><li><p>查看源代码</p><blockquote><p>l：list，列出10行</p></blockquote><ul><li><code>l 要查看的文件名:行号</code>：显示指定文件某行前后的代码</li><li><code>l 要查看的文件名:函数名</code>：显示指定文件某函数定义前后的代码</li><li><code>l</code>：从上一次列出的代码后继续列出代码，或是从程序入口开始列出代码</li><li><code>set listsize count</code>：设置一次显示的代码行数</li><li><code>show listsize</code>：查看一次显示的代码行数</li></ul></li><li><p>设置断点</p><blockquote><p>b：break</p></blockquote><ul><li><p><code>b 行号</code>：（在当前所在文件中）设置一个断点</p></li><li><p><code>b 行号 if 逻辑表达式</code>：当逻辑表达式成立时断点才有效</p><blockquote><p>注意，如果是设置循环的条件停止，要把断点设置在<code>{}</code>代码块里</p></blockquote></li><li><p><code>d 断点编号范围</code>：删除断点。如果不加断点编号范围，则删除所有断点</p><blockquote><p>d：delete</p><p><code>范围</code>可以直接写一个数字，也可以写类似<code>3-7</code>这种</p></blockquote></li><li><p><code>disable 断点编号范围</code>：让指定断点暂时失效</p></li><li><p><code>enable 断点编号范围</code>：让指定断点重新生效</p></li></ul></li><li><p>运行程序</p><ul><li><p><code>start</code>：开始运行程序，等待调试（只执行一步）</p></li><li><p><code>r</code>：运行程序，直到断点或运行结束</p><blockquote><p>r：run</p></blockquote></li><li><p><code>n</code>：单步执行</p><blockquote><p>n：next</p></blockquote></li><li><p><code>c</code>：继续运行程序，直到断点或运行结束</p><blockquote><p>c：continue</p></blockquote></li><li><p><code>s</code>：进入当前行中的函数内部</p><blockquote><p>s：step</p></blockquote></li><li><p><code>u</code>：跳出循环</p><blockquote><p>u：until</p><p>相当于程序中的<code>break</code>关键字</p></blockquote></li><li><p><code>finish</code>：跳出之前进入的函数</p><blockquote><p>要求之后不能有断点出现，否则无法跳出</p></blockquote></li></ul></li><li><p>打印信息</p><ul><li><code>p 表达式</code>：打印表达式的值</li><li><code>ptype 表达式</code>：打印表达式的类型</li><li><code>display 表达式</code>：追踪打印表达式的值，每运行一次都会打印</li><li><code>undisplay 被追踪的表达式编号范围</code>：取消追踪的表达式</li></ul></li><li><p>设置值</p><ul><li><code>set var 变量名=变量值 </code>：设置变量的值</li></ul></li><li><p>查看信息</p><blockquote><p>i：info</p></blockquote><ul><li><code>i b</code>：查看断点信息</li><li><code>i display</code>：查看被追踪的表达式信息</li></ul></li></ul><h3 id="_1-3-makefile" tabindex="-1"><a class="header-anchor" href="#_1-3-makefile" aria-hidden="true">#</a> 1.3 makefile</h3><p><em>一个规则：</em></p><ul><li><p>makefile文件命名规则：</p><ul><li><code>makefile</code></li><li><code>Makefile</code></li></ul></li><li><p>运行makefile：</p><ul><li><code>make</code>：生成终极目标</li><li><code>make xxx</code>：生成<code>xxx</code>目标，运行对应规则的命令</li></ul></li><li><p>规则三要素：目标、依赖、命令</p><div class="language-makefile line-numbers-mode" data-ext="makefile"><pre class="language-makefile"><code><span class="token comment"># 如下方式定义一条“规则”</span>
<span class="token target symbol">目标</span><span class="token punctuation">:</span> 依赖的所有文件
	gcc命令
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>注意命令前必须有一个<code>tab</code>缩进</li><li>默认从当前目录中寻找依赖文件，否则就要指定路径</li></ul><div class="language-makefile line-numbers-mode" data-ext="makefile"><pre class="language-makefile"><code><span class="token target symbol">app</span><span class="token punctuation">:</span> main.o add.o sub.o mul.o
    gcc main.o add.o sub.o mul.o -o app

<span class="token target symbol">main.o</span><span class="token punctuation">:</span> main.c
    gcc -c main.c

<span class="token target symbol">add.o</span><span class="token punctuation">:</span> add.c
    gcc -c add.c

<span class="token target symbol">mul.o</span><span class="token punctuation">:</span> mul.c
    gcc -c mul.c

<span class="token target symbol">sub.o</span><span class="token punctuation">:</span> sub.c
    gcc -c sub.c
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>如果有多条规则，默认<strong>第1条规则</strong>的目标为<strong>终极目标</strong>，后面的规则都是为此服务的</p><blockquote><p>终极目标可以向下查找依赖项的生成，然后从下向上执行</p></blockquote></li><li><p>如上所示分开生成<code>.o</code>文件，则执行<code>make</code>时<strong>只会编译修改过的文件</strong></p><blockquote><p>终极目标是<code>app</code>，其他的可以不变；</p><p>当<strong>依赖的更新时间</strong>晚于<strong>目标的更新时间</strong>时，会再次执行<strong>命令</strong></p></blockquote></li></ul></li><li><p><code>clean</code>规则与伪目标</p><div class="language-makefile line-numbers-mode" data-ext="makefile"><pre class="language-makefile"><code><span class="token builtin-target builtin">.PHONY</span><span class="token punctuation">:</span> clean
<span class="token target symbol">clean</span><span class="token punctuation">:</span>
    rm <span class="token variable">$</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span> -f
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><code>make clean</code>即可运行命令</li><li>解决目录下有名为<code>clean</code>的文件的问题：声明伪目标<code>.PHONY</code></li></ul></li></ul><hr><p><em>三个变量：</em></p><ul><li><p><code>变量名=变量值</code></p><p><code>$(变量名)</code></p><ul><li>可以在makefile中以<code>变量名=变量值</code>和格式定义变量</li><li>然后用<code>$(变量名)</code>引用</li></ul><p><code>%</code></p><ul><li><p>向下寻找依赖时，会自动匹配下方规则中的<code>%</code>，替换成要寻找的依赖，生成一条规则</p><blockquote><p>替换时会自动将<code>.后缀</code>去掉</p></blockquote></li></ul></li><li><p><code>$&lt;</code>：规则中的<strong>第一个依赖</strong></p><p><code>$^</code>：规则中的<strong>所有依赖</strong></p></li><li><p><code>$@</code>：规则中的<strong>目标</strong></p></li></ul><blockquote><p><code>$&lt; $^ $@</code>是makefile中的自动变量，只能在规则的<strong>命令</strong>中使用</p></blockquote><div class="language-makefile line-numbers-mode" data-ext="makefile"><pre class="language-makefile"><code>obj <span class="token operator">=</span> main.o add.o sub.o mul.o
target <span class="token operator">=</span> app 

<span class="token target symbol"><span class="token variable">$</span>{target}</span><span class="token punctuation">:</span> <span class="token variable">$</span><span class="token punctuation">{</span>obj<span class="token punctuation">}</span> 
    gcc <span class="token variable">$</span><span class="token punctuation">{</span>obj<span class="token punctuation">}</span> -o <span class="token variable">$</span><span class="token punctuation">{</span>target<span class="token punctuation">}</span>

<span class="token target symbol">%.o</span><span class="token punctuation">:</span> %.c 
    gcc -c <span class="token variable">$&lt;</span> -o <span class="token variable">$@</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>makefile维护的变量</p><blockquote><p>通常为<strong>大写</strong>。用户自定义变量通常为小写</p></blockquote><ul><li><code>CC</code>：默认值<code>cc</code>，也就是<code>gcc</code></li><li><code>CPPFLAGS</code>：预处理时需要的选项，如<code>-I</code></li><li><code>CFLAGS</code>：编译的时候使用的参数，如<code>-Wall -D -g -c</code></li><li><code>LDFLAGS</code>：链接时使用的选项，如<code>-L -l</code></li></ul></li></ul><hr><p><em>两个函数：</em></p><ul><li><p><code>wildcard</code>：</p><p><code>src = $(wildcard 某目录下用*匹配的文件)</code></p></li><li><p><code>patsubst</code>：</p><p><code>obj = $(patsubst 某目录下用%匹配的文件, 保留%后要替换成的样子, $(src))</code></p></li></ul><div class="language-makefile line-numbers-mode" data-ext="makefile"><pre class="language-makefile"><code>target <span class="token operator">=</span> app 
src <span class="token operator">=</span> <span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">wildcard</span> ./*.c<span class="token punctuation">)</span>
obj <span class="token operator">=</span> <span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">patsubst</span> ./%.c, ./%.o, <span class="token variable">$</span><span class="token punctuation">(</span>src<span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token target symbol"><span class="token variable">$</span>{target}</span><span class="token punctuation">:</span> <span class="token variable">$</span><span class="token punctuation">{</span>obj<span class="token punctuation">}</span> 
    gcc <span class="token variable">$</span><span class="token punctuation">{</span>obj<span class="token punctuation">}</span> -o <span class="token variable">$</span><span class="token punctuation">{</span>target<span class="token punctuation">}</span>

<span class="token target symbol">%.o</span><span class="token punctuation">:</span> %.c 
    gcc -c <span class="token variable">$&lt;</span> -o <span class="token variable">$@</span>

<span class="token builtin-target builtin">.PHONY</span><span class="token punctuation">:</span> clean
<span class="token target symbol">clean</span><span class="token punctuation">:</span>
    rm <span class="token variable">$</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span> -f
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h2 id="_2-内存与文件系统" tabindex="-1"><a class="header-anchor" href="#_2-内存与文件系统" aria-hidden="true">#</a> 2 内存与文件系统</h2><h3 id="_2-1-内存管理" tabindex="-1"><a class="header-anchor" href="#_2-1-内存管理" aria-hidden="true">#</a> 2.1 内存管理</h3><p><em>进程虚拟地址空间：</em></p><ul><li><p><u>大小</u>：对于 32bit 操作系统，有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>32</mn></msup><mo>=</mo><mn>4</mn><mi>G</mi></mrow><annotation encoding="application/x-tex">2^{32}=4G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">32</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">4</span><span class="mord mathnormal">G</span></span></span></span> 的可用虚拟地址空间，从0开始</p><blockquote><p>为进程按需分配物理内存，不会直接分配4G</p></blockquote></li><li><p><u>内核区</u>：3G~4G</p><blockquote><p>不允许用户直接操作</p></blockquote><ul><li><p><strong>PCB</strong>：</p><ul><li><p>文件描述符表：一个大小为1024的数组，数组<strong>索引</strong>就是<strong>文件描述符</strong>，数组元素代表文件</p><p>0：<code>STDIN_FILENO</code></p><p>1：<code>STDOUT_FILENO</code></p><p>2：<code>STDERR_FILENO</code></p><blockquote><p>标准输入、标准输出、标准错误默认是打开状态</p></blockquote><p>3~1023：每打开一个新文件，会占用<strong>空闲文件描述符</strong>中最小的那个</p></li><li><p>页表</p></li><li><p>...（PCB中的其他内容）</p></li></ul></li><li><p>物理存储区</p></li><li><p>内核代码和数据</p></li><li><p>...（内核区的其他内容）</p></li></ul></li><li><p><u>用户区</u>：0~3G</p><blockquote><p>允许用户访问并操作；</p><p>接下来的<strong>从低地址向高地址</strong>介绍</p></blockquote><ul><li><p>受保护的地址（header）：0~4K</p><blockquote><p><code>#define NULL (void*)0</code>指向的就是这里</p></blockquote></li><li><p>ELF 段：ELF是Linux下<strong>可执行文件格式</strong></p><blockquote><p><code>file a.out</code>命令可以查看<code>a.out</code>的文件格式</p></blockquote><ul><li><p><strong>.text段</strong>：只读的<strong>代码段</strong>，二进制机器指令</p><blockquote><p>代码段也可以包括一些<strong>静态库</strong></p></blockquote></li><li><p>.rodata段：只读的数据段、符号段等</p></li><li><p><strong>.data段</strong>：已初始化的<strong>全局变量</strong>，可读写</p></li><li><p><strong>.bss段</strong>：未初始化的<strong>全局变量</strong>，可读写</p></li></ul></li><li><p><strong>堆空间</strong>：从低地址向高地址增长，<code>malloc</code>相关函数分配的地址空间</p></li><li><p>共享库：加载程序执行时引用的<strong>动态链接库</strong>（C标准库等）</p><blockquote><p>由于加载到共享库的位置不定，所以动态库中应当时位置无关代码（相对地址）</p></blockquote></li><li><p><strong>栈空间</strong>：从高地址向低地址增长，主要存放<strong>函数栈帧</strong>，包括调用信息、局部变量等</p></li><li><p>命令行参数：<code>argv[]</code></p></li><li><p>环境变量（env）</p></li></ul></li><li><p><u>虚拟地址空间的优点</u></p><ul><li>有利于编译器和操作系统利用<strong>离散的物理地址空间</strong>，为进程提供虚拟的<strong>连续地址空间</strong></li><li>有利于进程之间<strong>地址空间的隔离</strong></li><li>有利于在逻辑上<strong>扩展物理内存</strong></li></ul></li></ul><hr><p><em>MMU的基本工作原理</em>：</p><ul><li><p>Memory Management Unit，内存管理单元，位于CPU内部</p></li><li><p>主要功能</p><ul><li><p>虚拟内存和物理内存的映射，按**页（4k大小）**分配物理地址空间</p><ul><li><p>不同进程的<strong>内核区</strong>映射到<strong>相同的内核物理内存</strong></p><blockquote><p>当然，不同进程的PCB不同，只是位于同一块内核物理内存中</p></blockquote></li><li><p>不同进程的用户区映射到不同的物理内存</p></li></ul></li><li><p>管理<strong>内存访问权限</strong>（用户级、内核级）</p></li></ul></li></ul><h3 id="_2-3-io" tabindex="-1"><a class="header-anchor" href="#_2-3-io" aria-hidden="true">#</a> 2.3 IO</h3><h2 id="_3-进程与线程" tabindex="-1"><a class="header-anchor" href="#_3-进程与线程" aria-hidden="true">#</a> 3 进程与线程</h2><h3 id="_3-1-进程相关数据结构" tabindex="-1"><a class="header-anchor" href="#_3-1-进程相关数据结构" aria-hidden="true">#</a> 3.1 进程相关数据结构</h3><p><em>进程控制块PCB：</em></p><ul><li><p>Linux内核的进程控制块是<code>task_struct</code>结构体</p><blockquote><p><code>/usr/src/linux-headers-3.16.0-30/include/linux/sched.h</code>文件中可以查看<code>struct task_struct</code>结构体定义</p></blockquote></li><li><p><code>task_struct</code>结构体重要成员</p><ul><li><p>进程<strong>描述</strong>信息：</p><ul><li><p>进程标识符（<strong>PID</strong>）：系统中每个进程都有<strong>唯一</strong>的id，用<code>pid_t</code>表示其<strong>类型</strong>，本质是非负整数</p><blockquote><p>Unix系统的第一个进程<strong>init进程的pid为1</strong></p></blockquote></li><li><p>用户id和组id</p></li></ul></li><li><p>进程<strong>控制和管理</strong>信息：</p><ul><li>进程当前<strong>状态</strong></li><li><strong>信号</strong>相关的信息</li><li><strong>会话</strong>（Session）和<strong>进程组</strong></li></ul></li><li><p><strong>资源分配</strong>清单：</p><ul><li><p>描述<strong>虚拟地址空间</strong>的信息</p></li><li><p>进程可以使用的<strong>资源上限</strong>（Resource Limit）</p><blockquote><p><code>ulimit -a</code>命令可以查看一些资源上限</p></blockquote></li></ul></li><li><p><strong>处理机</strong>相关信息：</p><ul><li>进程<strong>切换</strong>时需要保存和恢复的<strong>寄存器</strong></li><li>描述<strong>控制终端</strong>的信息</li><li>当前<strong>工作目录</strong>位置</li><li><code>umask</code>掩码</li><li><strong>文件描述符</strong>表</li></ul></li></ul></li></ul><hr><p><em>环境变量：</em></p><ul><li><p>操作系统中用来<strong>指定运行环境</strong>的一些参数</p></li><li><p>特征：</p><ul><li>本质是<strong>字符串</strong></li><li>统一的格式：<code>名=值1:值2:值3</code></li><li>描述<strong>进程环境信息</strong></li></ul></li><li><p><strong>shell进程</strong>的常见环境变量</p><ul><li><p>PATH：记录<strong>可执行</strong>程序的<strong>搜索路径</strong></p></li><li><p>SHELL：记录当前所使用的<strong>命令解析器</strong></p></li><li><p>HOME：当前用户家目录</p></li><li><p>LANG：当前使用的语言和本地信息</p><blockquote><p>决定了字符编码、时间、货币等信息的显示格式</p></blockquote></li><li><p>TERM：当前终端类型</p></li></ul></li><li><p>在c程序中使用环境变量：</p><ul><li><p>存储形式：<code>char *[]</code>数组，数组名为<code>environ</code>，内部存储字符串，<code>NULL</code>作为哨兵结尾</p></li><li><p>加载位置：位于用户区，高于stack的起始位置</p></li><li><p>引入环境变量表：<code>extern char **environ</code></p></li><li><p>相关函数</p><ul><li><code>char *getenv(const char *name);</code></li><li><code>int setenv(const char *name, const char *value, int overwrite)</code></li><li><code>int unsetenv(const char *name);</code></li></ul><blockquote><p><code>man getenv</code>、<code>man setenv</code>、<code>man unsetenv</code></p></blockquote></li></ul></li></ul><h3 id="_3-2-进程控制" tabindex="-1"><a class="header-anchor" href="#_3-2-进程控制" aria-hidden="true">#</a> 3.2 进程控制</h3><div class="hint-container info"><p class="hint-container-title">进程控制</p><ul><li><a href="#%E5%88%9B%E5%BB%BA%E8%BF%9B%E7%A8%8B">创建进程</a></li><li><a href="#%E8%BF%9B%E7%A8%8B%E6%8F%8F%E8%BF%B0%E4%BF%A1%E6%81%AF">进程描述信息</a></li><li><a href="#%60exec%60%E5%87%BD%E6%95%B0%E6%97%8F"><code>exec</code>函数族</a></li><li><a href="#%E8%BF%9B%E7%A8%8B%E7%BB%88%E6%AD%A2">进程终止</a></li><li><a href="#%E5%9B%9E%E6%94%B6%E8%BF%9B%E7%A8%8B">回收进程</a></li></ul></div><h4 id="创建进程" tabindex="-1"><a class="header-anchor" href="#创建进程" aria-hidden="true">#</a> <em>创建进程：</em></h4><ul><li><p>方式一：<strong>运行可执行程序</strong>时，就会创建进程</p><blockquote><p>一般可执行程序对应进程的<u>父进程是<code>bash</code>/shell进程</u>， shell进程会将前台交给该进程，自己到后台去，直到该进程结束，再回到前台</p></blockquote></li><li><p>方式二：<code>pid_t fork(void);</code></p><blockquote><p><code>#include &lt;unistd.h&gt;</code>：Unix系统标准头文件</p></blockquote><ul><li><p>创建n个进程：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">int</span> i<span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">pid_t</span> pid <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>pid <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// child process</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token comment">// parent process</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>刚fork之后：</p><ul><li>父子相同处：全局变量、.data、.text、栈、堆、环境变量、用户ID、宿主目录、进程工作目录、信号处理方式...</li><li>父子不同处：进程ID、fork返回值、父进程ID、进程运行时间、闹钟(定时器)、未决信号集</li></ul></li><li><p><strong>读时共享写时复制</strong></p><ul><li>共享的是<strong>物理地址空间</strong>，虚拟的地址空间当然可以直接复制多个</li></ul></li><li><p>父子进程的共享资源</p><ul><li><p>文件描述符</p><blockquote><p>打开文件的结构体</p></blockquote></li><li><p>mmap建立的映射区</p></li></ul></li></ul></li></ul><blockquote><p>进程图：</p><ul><li>点：语句 <ul><li><code>printf </code> 节点可以用输出来进行标记</li><li>每个进程图都由一个没有入边的节点开始</li><li><code>fork</code> 节点出边有两条</li></ul></li><li>有向边：语句执行顺序 <ul><li>边可以用变量的当前值来做标记</li></ul></li></ul></blockquote><hr><h4 id="进程描述信息" tabindex="-1"><a class="header-anchor" href="#进程描述信息" aria-hidden="true">#</a> <em>进程描述信息：</em></h4><ul><li>进程id相关 <ul><li>获得进程id：<code>pid_t getpid(void);</code></li><li>获得父进程id：<code>pid_t getppid(void);</code></li></ul></li><li>用户id相关 <ul><li>获取当前进程实际用户ID：<code>uid_t getuid(void);</code></li><li>获取当前进程有效用户ID：<code>uid_t geteuid(void);</code></li><li>获取当前进程实际用户组ID：<code>gid_t getgid(void);</code></li><li>获取当前进程有效用户组ID：<code>gid_t getegid(void);</code></li></ul></li></ul><hr><h4 id="exec函数族" tabindex="-1"><a class="header-anchor" href="#exec函数族" aria-hidden="true">#</a> <em><code>exec</code>函数族：</em></h4><ul><li><p>fork创建的子进程往往要调用一种exec函数以执行另一个程序。当进程调用一种exec函数时，该进程的用户空间<strong>代码和数据</strong>完全被新程序<strong>替换</strong>，从新程序的<strong>启动例程</strong>开始执行</p><blockquote><p>启动例程：调用<code>main</code>函数的函数</p><p>调用exec并<strong>不创建新进程</strong>，所以调用exec前后该<strong>进程的id并未改变</strong></p><p>一个程序调用了<code>exec</code>之后，在不出错的情况下，不再有返回值，原程序后续代码不会执行，若出错了才有返回值，并执行原程序后续代码</p></blockquote></li><li><p>⭐<code>int execlp(const char *file, const char *arg, ...);</code></p><blockquote><p>l：list，p：path</p></blockquote><ul><li>加载一个进程，要依赖系统当前的PATH环境变量</li><li><code>file</code>：可执行程序名</li><li><code>arg, ...</code>：命令行参数，从<code>argv[0]</code>开始，可变参要以<code>NULL</code>结尾</li></ul><blockquote><p>举例：<code>execlp(&quot;ls&quot;, &quot;ls&quot;, &quot;-l&quot;, &quot;-F&quot;, NULL);</code></p></blockquote></li><li><p>⭐<code>int execl(const char *path, const char *arg, ...);</code></p><ul><li>加载一个进程， 通过<code>路径+程序名</code>来加载，不需要依赖系统当前的PATH环境变量</li></ul><blockquote><p>举例：<code>execl(&quot;/bin/ls&quot;, &quot;ls&quot;, &quot;-l&quot;, &quot;-F&quot;, NULL);</code></p></blockquote></li><li><p><code>int execle(const char *path, const char *arg, ..., char *const envp[]);</code></p><ul><li>需要引入新的环境变量表</li></ul></li><li><p><code>int execv(const char *path, char *const argv[]);</code></p><blockquote><p>v：vector</p></blockquote></li><li><p><code>int execvp(const char *file, char *const argv[]);</code></p></li><li><p><code>int execve(const char *path, char *const argv[], char *const envp[]);</code></p><ul><li>只有<code>execve</code>是真正的系统调用</li></ul></li></ul><hr><h4 id="进程终止" tabindex="-1"><a class="header-anchor" href="#进程终止" aria-hidden="true">#</a> <em>进程终止：</em></h4><ul><li>引进终止的事件 <ul><li>正常结束</li><li>异常结束</li><li>外界干预 <ul><li>操作系统干预</li><li>父进程干预（父进程终止、父进程请求）</li></ul></li></ul></li><li><code>exit</code></li></ul><hr><h4 id="回收进程" tabindex="-1"><a class="header-anchor" href="#回收进程" aria-hidden="true">#</a> <em>回收进程：</em></h4><ul><li><p>孤儿进程：父进程先于子进程结束，则子进程成为孤儿进程，子进程的父进程成为 init 进程</p><blockquote><p>“init 进程”可能是整个系统的 init 进程，也可能是用户的 init 进程</p></blockquote></li><li><p>僵尸进程：进程终止，父进程尚未回收，子进程**残留资源（PCB）**存放于内核中，变成僵尸（Zombie）进程。</p><blockquote><p>所谓回收就是在<strong>回收PCB</strong></p></blockquote></li><li><p><code>pid_t wait(int *status)</code></p><ul><li><p>三个功能</p><ul><li><strong>阻塞</strong>并等待一个子进程退出</li><li><strong>回收</strong>子进程残留资源</li><li>获取子进程结束<strong>状态</strong>(退出原因)</li></ul></li><li><p>返回-1代表出错（无子进程）</p></li><li><p>用<code>status</code>结合<strong>宏函数</strong>判断子进程终止原因</p><ul><li><p>⭐<code>WIFEXITED(status)</code>：返回值非0代表子进程<strong>正常结束</strong></p><p>如上宏为真可以使用此宏<code>WEXITSTATUS(status)</code>：获取进程<strong>退出状态</strong>(<code>exit</code>的参数)</p></li><li><p>⭐<code>WIFSIGNALED(status)</code>：返回值非0代表<strong>异常结束</strong></p><blockquote><p>Linux中所有异常结束都是因为收到了<strong>信号</strong></p></blockquote><p>如上宏为真可以使用此宏<code>WTERMSIG(status)</code>：取得使子进程终止的那个<strong>信号的编号</strong></p></li><li><p><code>WIFSTOPPED(status)</code>：返回值非0代表子进程处于<strong>暂停状态</strong></p><p>如上宏为真可以使用此宏<code>WSTOPSIG(status)</code>：获取使子进程暂停的那个<strong>信号的编号</strong></p><blockquote><p><code>WIFCONTINUED(status)</code>为真 → 子进程暂停后已经继续运行</p></blockquote></li></ul></li></ul></li><li><p><code>pid_t waitpid(pid_t pid, int *status, int options);</code></p><ul><li><code>pid</code>：要回收的子进程id <ul><li>⭐大于0则回收指定id子进程</li><li>⭐为-1则回收任意子进程（相当于<code>wait</code>）</li><li>为0则回收和当前调用waitpid的进程同一个<strong>进程组</strong>的所有子进程</li><li>小于-1则回收指定<strong>进程组</strong>内的任意子进程</li></ul></li><li><code>options</code>：若指定为0则<strong>阻塞</strong>；若指定为<code>WNOHANG</code>则<strong>不阻塞</strong>，只是检查子进程是否结束，结束则回收，否则<strong>返回0</strong>并继续运行</li></ul></li></ul><h3 id="_3-3-进程间通信" tabindex="-1"><a class="header-anchor" href="#_3-3-进程间通信" aria-hidden="true">#</a> 3.3 进程间通信</h3><p><em>管道：</em></p><ul><li>普通管道：<code>pipe</code></li><li>命名管道：<code>mkfifo</code></li></ul><hr><p><em><code>mmap</code></em>：</p><h3 id="_3-4-进程信号" tabindex="-1"><a class="header-anchor" href="#_3-4-进程信号" aria-hidden="true">#</a> 3.4 进程信号</h3><div class="hint-container info"><p class="hint-container-title">进程信号</p><ul><li><a href="#%E4%BF%A1%E5%8F%B7%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">信号的基本概念</a></li><li><a href="#%E4%BF%A1%E5%8F%B7%E7%9A%84%E4%BA%A7%E7%94%9F">信号的产生</a></li><li><a href="#%E4%BF%A1%E5%8F%B7%E9%9B%86%E6%93%8D%E4%BD%9C">信号集操作</a></li><li><a href="#%E4%BF%A1%E5%8F%B7%E6%8D%95%E6%8D%89">信号捕捉</a></li><li><a href="#%60pause%60%E5%87%BD%E6%95%B0%E4%B8%8E%60sigsuspend%60%E5%87%BD%E6%95%B0"><code>pause</code>与<code>sigsuspend</code></a></li><li><a href="#%E4%BF%A1%E5%8F%B7%E4%BC%A0%E5%8F%82">信号传参</a></li><li><a href="#%E4%B8%AD%E6%96%AD%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8">中断系统调用</a></li><li><a href="#%E5%AE%89%E5%85%A8%E7%9A%84%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86">安全的信号处理</a></li></ul></div><hr><h4 id="信号的基本概念" tabindex="-1"><a class="header-anchor" href="#信号的基本概念" aria-hidden="true">#</a> <em>信号的基本概念：</em></h4><ul><li><p>信号是信息的载体，有如下<strong>特征</strong>：</p><ul><li><p>简单</p><blockquote><p>信号的<strong>开销很小</strong>，就算不使用信号也会有这样的开销</p></blockquote></li><li><p>不能携带大量信息</p><blockquote><p>一般来说只能带一个<strong>标志</strong>过去</p></blockquote></li><li><p>满足某个<strong>特设条件</strong>才发送</p></li></ul></li><li><p>信号<strong>机制</strong>：</p><ul><li><p>进程收到信号后，不管执行到程序的什么位置，都要<strong>中断</strong>运行去处理信号，处理完毕再继续执行</p><blockquote><p>采用与<strong>硬件中断</strong>类似的异步模式。但信号是<strong>软件层面</strong>上实现的<strong>中断</strong>，早期常被称为“软中断”，有一定<strong>延时性</strong>（相对于硬件来说）</p></blockquote></li><li><p>⭐<strong>每个进程收到的所有信号，都是由<u>内核负责产生并发送</u>的，<u>内核处理</u></strong>⭐</p></li></ul></li><li><p>信号<strong>产生</strong>的五种方式：</p><ul><li>终端按键产生</li><li>硬件异常产生</li><li>命令产生</li><li>系统调用产生</li><li>软件条件产生</li></ul></li><li><p>信号<strong>状态</strong>：</p><ul><li><p><strong>递达</strong>：递送并且到达进程</p><blockquote><p>内核产生信号后会<strong>立刻发送</strong>给相应进程</p></blockquote></li><li><p><strong>阻塞</strong>（屏蔽、未决）：信号产生后受到阻塞，未能递达进程</p></li></ul></li><li><p>信号的<strong>编号</strong>与<strong>信号集</strong></p><ul><li><p>信号<strong>编号</strong></p><ul><li><p>可以使用<code>kill –l</code>命令查看当前系统可使用的信号有哪些</p></li><li><p>1-31号信号称之为<strong>常规信号</strong>（也叫普通信号或标准信号）</p></li><li><p>34-64称之为实时信号</p><blockquote><p>与嵌入式开发和驱动编程有关</p></blockquote></li></ul><blockquote><p><code>man 7 signal</code>可以查看相关文档</p></blockquote></li><li><p><strong>阻塞信号集(信号屏蔽字)</strong></p><ul><li><p>将某些信号加入集合，对他们设置屏蔽，收到这些信号时，对其的处理将推迟到解除屏蔽后</p><blockquote><p>常规信号会阻塞但<strong>不支持排队</strong>，产生多次<strong>只记录一次</strong></p></blockquote></li></ul></li><li><p><strong>未决信号集</strong></p><ul><li><p>信号产生后未决信号集中<strong>描述该信号的位</strong>立刻翻转为1，表信号处于未决状态，信号被处理后对应位再翻转为0</p></li><li><p>信号产生后由于某些原因(主要是阻塞)不能抵达，这类信号的集合称之为未决信号集。</p><blockquote><p>在屏蔽解除前，信号一直处于未决状态</p></blockquote></li></ul></li></ul></li><li><p>信号的<strong>三种处理方式</strong></p><ul><li>执行信号预设的默认动作 <ul><li>Term：终止进程</li><li>Ign：忽略信号（默认即时对该种信号忽略操作）</li><li>Core：终止进程并生成<strong>Core文件</strong>（记录进程死亡原因， 可用于gdb调试）</li><li>Stop：暂停进程</li><li>Cont：继续运行进程</li></ul></li><li>忽略：丢弃</li><li>捕捉：调用用户处理函数</li></ul><blockquote><p>值得注意的是 <em><strong>9) SIGKILL</strong></em> 和 <em><strong>19) SIGSTOP</strong></em> 信号，不允许忽略和捕捉，只能执行默认动作。甚至不能将其设置为阻塞。</p></blockquote></li><li><p>⭐信号<strong>四要素</strong></p><ul><li>编号</li><li>名称</li><li>默认处理动作</li><li>事件：使得该信号<strong>产生</strong>的事件</li></ul></li></ul><hr><h4 id="信号的产生" tabindex="-1"><a class="header-anchor" href="#信号的产生" aria-hidden="true">#</a> <em>信号的产生：</em></h4><ul><li><p><strong>终端按键</strong>产生信号</p><ul><li><p>Ctrl + c → <em><strong>2) SIGINT</strong></em>：终止/中断</p><blockquote><p>&quot;INT&quot; ----Interrupt</p></blockquote></li><li><p>Ctrl + z → <em><strong>20) SIGTSTP</strong></em>：暂停/停止</p><blockquote><p>&quot;T&quot; ----Terminal 终端，只能停止与终端交互的进程</p></blockquote></li><li><p>Ctrl + \ → <em><strong>3) SIGQUIT</strong></em>：退出进程（核心已转储，也是终止进程）</p></li></ul></li><li><p><strong>硬件异常</strong>产生</p><ul><li><p>浮点数例外：<em><strong>8) SIGFPE</strong></em></p><blockquote><p>例如：除0</p><p>&quot;F&quot; -----float 浮点数</p></blockquote></li><li><p>段错误：<em><strong>11) SIGSEGV</strong></em></p><blockquote><p>例如：非法访问内存</p></blockquote></li><li><p>总线错误：<em><strong>7) SIGBUS</strong></em></p><blockquote><p>例如：内存对齐出错</p></blockquote></li></ul></li><li><p><strong>命令</strong>产生</p><ul><li><p>⭐<code>kill -信号编号 进程ID</code>：给对应ID的进程发送信号</p><blockquote><p>默认发送的是 <em><strong>15) SIGTERM</strong></em></p></blockquote></li></ul></li><li><p><strong>系统调用</strong>产生</p><ul><li><p>⭐<code>int kill(pid_t pid, int sig);</code>：给对应ID的进程发送信号</p><blockquote><p><code>man 2 kill</code>查看相关文档</p></blockquote><ul><li>成功返回0，失败返回-1并设置<code>errno</code></li></ul></li><li><p><code>int raise(int sig);</code>：给当前进程自己发送信号</p><p><code>raise(signo) == kill(getpid(), signo);</code></p></li><li><p><code>void abort(void);</code>：给当前进程自己发送异常终止信号</p><p><em><strong>6) SIGABRT</strong></em> 信号，终止并产生core文件</p></li></ul></li><li><p>软件条件产生</p><ul><li><p>⭐<code>unsigned int alarm(unsigned int seconds);</code>：设置定时器(闹钟)。在指定seconds后，内核会给当前进程发送 <em><strong>14) SIGALRM</strong></em> 信号</p><blockquote><p>进程收到该信号，默认动作<strong>终止</strong></p></blockquote><ul><li><p><strong>每个进程都有且只有<u>唯一</u>个定时器</strong></p></li><li><p>调用<code>alarm</code>后会取消旧闹钟，并<strong>返回旧闹钟余下秒数</strong></p><blockquote><p><code>alarm(0)</code>取消闹钟</p></blockquote></li><li><p>定时<strong>与进程状态无关</strong>(自然定时法)</p></li></ul><blockquote><p>使用time命令查看<strong>程序执行的时间</strong>：</p><p>实际执行时间 = 系统时间 + 用户时间 + <strong>等待</strong>时间</p><blockquote><p>IO往往会造成较长的等待时间，程序运行的瓶颈在于IO，优化程序，首选优化IO</p></blockquote></blockquote></li><li><p><code>int setitimer(int which, const struct itimerval *new_value, struct itimerval *old_value);</code></p><ul><li><p><code>which</code>：指定定时方式</p><blockquote><p>自然定时：ITIMER_REAL → <em><strong>14）SIGLARM</strong></em></p><p>虚拟空间计时(用户空间)：ITIMER_VIRTUAL → <em><strong>26）SIGVTALRM</strong></em></p><blockquote><p>只计算进程占用cpu的时间</p></blockquote><p>运行时计时(用户+内核)：ITIMER_PROF → <em><strong>27）SIGPROF</strong></em></p><blockquote><p>计算占用cpu及执行系统调用的时间</p></blockquote></blockquote></li><li><p><code>man setitimer</code>学习其他参数</p><blockquote><p>可以设置周期定时</p></blockquote></li></ul></li></ul></li></ul><hr><h4 id="信号集操作" tabindex="-1"><a class="header-anchor" href="#信号集操作" aria-hidden="true">#</a> <em>信号集操作：</em></h4><ul><li><p><code>sigset_t set; // typedef unsigned long sigset_t;</code></p></li><li><p>设置<strong>自定义信号集</strong></p><ul><li><p><code>int sigemptyset(sigset_t *set);</code>：将某个信号集清0</p><blockquote><p>返回值：成功0、失败-1，下面3个函数返回值也一样</p></blockquote></li><li><p><code>int sigfillset(sigset_t *set);</code>：将某个信号集全部置1</p></li><li><p><code>int sigaddset(sigset_t *set, int signum);</code>：将某个信号加入信号集</p></li><li><p><code>int sigdelset(sigset_t *set, int signum);</code>：将某个信号清出信号集</p></li><li><p><code>int sigismember(const sigset_t *set, int signum);</code>：判断某个信号是否在信号集中</p><blockquote><p>返回值：在集合1、不在：0、出错：-1</p></blockquote></li></ul></li><li><p><strong>信号屏蔽字与未决信号集</strong>的操作</p><ul><li><p>⭐<code>int sigprocmask(int how, const sigset_t *set, sigset_t *oldset);</code>：屏蔽信号或解除屏蔽</p><ul><li><p><code>how</code></p><p><code>SIG_BLOCK</code>：<code>set</code>表示需要屏蔽的信号</p><p><code>SIG_UNBLOCK</code>：<code>set</code>表示需要解除屏蔽的信号(set位为1代表解除屏蔽)</p><p><code>SIG_SETMASK</code>：<code>set</code>表示用于替代原始屏蔽及的新屏蔽集</p></li><li><p>成功返回0，失败返回-1</p></li></ul></li><li><p><code>int sigpending(sigset_t *set);</code>：读取当前进程的<strong>未决</strong>信号集</p><ul><li>成功返回0，失败返回-1</li></ul></li></ul></li></ul><hr><h4 id="信号捕捉" tabindex="-1"><a class="header-anchor" href="#信号捕捉" aria-hidden="true">#</a> <em>信号捕捉：</em></h4><ul><li><p><code>sighandler_t signal(int signum, sighandler_t handler);</code>：注册一个信号捕捉函数</p><blockquote><p><code>typedef void (*sighandler_t)(int);</code>，参数是<strong>信号编号</strong></p></blockquote><ul><li>返回值为<code>sighandler_t </code>，若是<code>SIG_ERR</code>则代表出错，若不是则代表该信号之前的捕捉函数</li><li><code>handler</code>是要注册的处理函数，也可赋值为<code>SIG_IGN</code>表<strong>忽略</strong>或<code>SIG_DFL</code>表执行<strong>默认动作</strong></li></ul></li><li><p>⭐<code>int sigaction(int signum, const struct sigaction *act, struct sigaction *oldact);</code></p><ul><li><p>成功：0；失败：-1</p></li><li><p><code>struct sigaction</code>结构体重要成员</p><ul><li><p><code>sa_handler</code>成员：要注册的处理函数</p></li><li><p><code>sigset_t sa_mask</code>：信号处理函数执行期间进程的<strong>信号屏蔽字</strong></p><blockquote><p>仅在处理函数被调用期间屏蔽生效，是临时性设置；当然，如果处理函数执行期间未被屏蔽的信号到来，则依然按照正常的机制去处理</p></blockquote></li><li><p><code>int sa_flags</code>：通常设置为0，代表使用默认属性，即处理函数执行期间<strong>自动屏蔽</strong>被捕捉信号</p><blockquote><p>如果不希望自动阻塞被捕捉信号，则可以设置为<code>SA_NODEFER</code>，当然这种情况要求处理函数是可重入的（后面会讲”重入“）</p></blockquote></li></ul></li></ul></li><li><p>内核实现信号捕捉的过程</p><ol><li>进程收到成功<strong>递达</strong>的信号，陷入内核</li><li><strong>内核</strong>处理信号，如果有注册处理函数，则回到用户态<strong>执行回调</strong></li><li>处理函数执行完后，执行特殊的<strong>系统调用</strong>函数<code>sigreturn</code>，再次回到内核</li><li>最后回到用户态继续向后执行</li></ol></li><li><p>通过 <em><strong>17) SIGCHILD</strong></em> 信号回收子进程</p><ol><li>屏蔽SIGCHILD信号</li><li>注册 SIGCHILD 信号处理函数 <ul><li>在函数中通过<code>while ((pid = waitpid(0, &amp;status, WNOHANG)) &gt; 0)</code> 的方式回收子进程</li></ul></li><li>解除对SIGCHILD信号的屏蔽</li></ol></li></ul><hr><h4 id="pause函数与sigsuspend函数" tabindex="-1"><a class="header-anchor" href="#pause函数与sigsuspend函数" aria-hidden="true">#</a> <em><code>pause</code>函数与<code>sigsuspend</code>函数</em>：</h4><ul><li><p><code>int pause(void);</code>：让进程主动阻塞，等待信号唤醒</p><ul><li><p>不能返回的情况</p><ul><li><p>信号的<strong>默认处理动作</strong>是终止进程，进程<strong>终止</strong></p><blockquote><p>一般来说，<strong>执行默认动作</strong>就不能返回了</p></blockquote></li><li><p>信号被<strong>忽略</strong></p></li><li><p>信号被<strong>屏蔽</strong></p></li></ul></li><li><p>可以返回的情况：<strong>捕捉</strong>且<strong>处理函数</strong>执行后</p><ul><li>返回 -1 并设置errno为EINTR</li></ul></li></ul></li><li><p><code>int sigsuspend(const sigset_t *mask);</code>：让进程主动阻塞，等待信号唤醒，阻塞期间的信号屏蔽字由参数决定</p></li></ul><hr><h4 id="信号传参" tabindex="-1"><a class="header-anchor" href="#信号传参" aria-hidden="true">#</a> <em>信号传参：</em></h4><ul><li><p>发送信号时传参：<code>int sigqueue(pid_t pid, int sig, const union sigval value);</code></p><ul><li><p><code>union sigval {int sival_int; void *sival_ptr;};</code></p><blockquote><p>注意，不同进程<strong>虚拟地址空间</strong>不同，所以<strong>不同进程之间</strong>用信号传地址是没有太大意义的，但<strong>同一个进程</strong>可以</p></blockquote></li><li><p>成功返回0，失败返回-1并设置error</p></li></ul></li><li><p>捕捉信号时接收到的参数：<code>int sigaction(int signum, const struct sigaction *act, struct sigaction *oldact);</code></p><ul><li><p><code>sigaction</code>结构体的<code>sa_sigaction</code>成员：<code>void (*sa_sigaction)(int, siginfo_t *, void *);</code></p><blockquote><p><code>siginfo_t</code>是较为复杂的结构体，详见<code>man sigaction</code></p></blockquote></li><li><p>用<code>sa_sigaction</code>成员代替<code>sa_handler</code>，并且<code>sa_flags</code>要置为<code>SA_SIGINFO</code></p></li></ul></li></ul><hr><h4 id="中断系统调用" tabindex="-1"><a class="header-anchor" href="#中断系统调用" aria-hidden="true">#</a> <em>中断系统调用：</em></h4><ul><li><p>系统调用的一种分类</p><ul><li><p>慢速系统调用：可能会使进程永远阻塞的一类系统调用</p><blockquote><p>如，read、write、pause、wait...</p></blockquote></li><li><p>其他系统调用</p></li></ul></li><li><p>慢速系统调用执行期间捕捉到信号，则系统调用会被中断，处理函数执行后，慢速系统调用通常会返回-1，并设置<code>errno</code>为<code>EINTR</code></p><blockquote><p>想中断慢速系统调用，不能屏蔽、忽略、执行默认动作；</p><p>EINTR代表“被信号中断“</p></blockquote></li><li><p>中断慢速系统调用后，如果想重启，可以自行在程序中书写重启的逻辑，也可以设置<code>sa_flags</code>参数为<code>SA_RESTART</code></p><blockquote><p><code>SA_INTERRUPT</code>为不重启</p></blockquote></li></ul><hr><h4 id="安全的信号处理" tabindex="-1"><a class="header-anchor" href="#安全的信号处理" aria-hidden="true">#</a> <em>安全的信号处理：</em></h4><ul><li>在处理程序中只调用异步信号安全的函数 <ul><li>异步信号安全：可重入或不能被信号中断</li><li>常见安全函数：<code>_exit, fork, accept, kill, execve, signal, waitpid, write</code></li><li>常用不安全函数：<code>printf、sprintf、malloc、exit</code></li></ul></li><li>保存和恢复<code>errno</code></li><li>阻塞所有的信号，保护对共享全局数据结构的访问</li><li>用<code>volatile</code>声明全局变量</li><li>用<code>sig_atomic_t</code>声明标志</li></ul><h3 id="_3-5-竞态条件" tabindex="-1"><a class="header-anchor" href="#_3-5-竞态条件" aria-hidden="true">#</a> 3.5 竞态条件</h3><p><em>时序竞态问题：</em></p><ul><li>竞态条件，跟系统负载有很紧密的关系，体现出信号的不可靠性。系统负载越严重，信号不可靠性越强。</li><li>竞态问题就是指由于进程抢占CPU时间片执行的<strong>异步性和不确定性</strong>导致的<strong>数据不一致问题</strong>。这种意外情况只能在编写程序过程中，提早预见，主动规避，而无法通过gdb程序调试等其他手段弥补。</li><li>条件：<strong>共享</strong>数据<strong>并发</strong>访问，且有<strong>写</strong>动作</li></ul><hr><p><em>全局变量的异步读写</em>：</p><ul><li>进程本身的函数和内核调用的<strong>回调函数</strong>可能会对全局变量有异步读写操作</li><li>解决方案 <ul><li>不使用全局变量</li><li>锁机制</li></ul></li></ul><hr><p><em>可重入与不可重入函数：</em></p><ul><li>一个函数在被调用执行期间，由于某种时序又被重复调用，称之为“重入”。 <ul><li>不可重入函数意思是，在函数的执行过程中，受到异步时序影响<strong>再次执行</strong>此函数（原执行暂停，直到再次执行结束后再继续执行），最终得到的结果与两次<strong>串行执行</strong>函数不一致</li></ul></li><li>可重入函数的特点 <ul><li>不能含有全局变量和<code>static</code>变量</li><li>不能使用<code>malloc</code>、<code>free</code></li><li>不是<strong>标准IO</strong>函数</li></ul></li><li>信号处理程序能调用的可重入函数可参阅<code>man 7 signal</code></li></ul><h3 id="_3-6-进程组与会话" tabindex="-1"><a class="header-anchor" href="#_3-6-进程组与会话" aria-hidden="true">#</a> 3.6 进程组与会话</h3><p><em>终端与Shell进程：</em></p><ul><li><p>所谓终端，就是<strong>所有输入输出设备的总称</strong></p></li><li><p>UNIX系统中用户可以通过<strong>终端</strong>登录系统，并得到一个<strong>Shell进程</strong>，终端就是Shell进程的<strong>控制终端</strong>。控制终端记录在PCB中，而<code>fork</code>时复制PCB，所以Shell进程启动的其他进程的控制终端也是该终端</p></li><li><p>终端的启动流程：init<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rarr</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span>fork、exec<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rarr</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span>getty<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rarr</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span>login<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rarr</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span>exec、bash</p></li><li><p>终端与用户进程的交互：</p><p>用户进程</p><p>​ <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>↑</mo><mo>↓</mo></mrow><annotation encoding="application/x-tex">\uarr\darr</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mrel">↑↓</span></span></span></span></p><p>系统调用</p><p>​ <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>↑</mo><mo>↓</mo></mrow><annotation encoding="application/x-tex">\uarr\darr</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mrel">↑↓</span></span></span></span></p><p>line discipline</p><p>​ <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>↑</mo><mo>↓</mo></mrow><annotation encoding="application/x-tex">\uarr\darr</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mrel">↑↓</span></span></span></span></p><p>终端设备驱动程序</p><p>​ <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>↑</mo><mo>↓</mo></mrow><annotation encoding="application/x-tex">\uarr\darr</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mrel">↑↓</span></span></span></span></p><p>终端设备</p><blockquote><p>line disciline: 线路规程，用来过滤键盘输入的内容</p></blockquote></li><li><p><code>char *ttyname(int fd);</code>：由文件描述符查出对应的文件名/设备名</p></li></ul><hr><p><em>进程组的概念与特性：</em></p><ul><li><p>进程组，也称之为<strong>作业</strong>，代表一个或多个进程的集合。<strong>每个进程都属于一个进程组</strong>，操作系统设计的进程组的概念，是为了简化<strong>对多个进程的管理</strong>。</p></li><li><p>父进程<code>fork</code>创建子进程的时候，默认子进程与父进程属于同一进程组，父进程为组长进程。<strong>组长进程</strong>的<strong>进程ID</strong>等于<strong>组进程ID</strong>。</p></li><li><p>进程组<strong>生存期</strong>：进程组创建的<strong>最后一个进程离开</strong>(终止或转移到另一个进程组)</p><blockquote><p>只要进程组中有一个进程存在，进程组就存在，与<strong>组长进程是否终止</strong>无关</p></blockquote></li></ul><hr><p><em>进程组操作函数：</em></p><ul><li><p><code>pid_t getpgrp(void);</code>：获取当前进程的进程组ID</p></li><li><p><code>pid_t getpgid(pid_t pid); </code>：获取指定进程的进程组ID</p><ul><li>如果<code>pid</code>为0，与<code>getpgrp</code>作用相同</li></ul></li><li><p><code>int setpgid(pid_t pid, pid_t pgid);</code>：改变进程默认所属的进程组</p><ul><li><p>可用来<strong>加入</strong>一个现有的进程组或<strong>创建</strong>一个新进程组(并作为组长)</p></li><li><p>成功返回0失败返回-1并设置errno</p></li><li><p>权级问题：非root进程只能改变<strong>自己创建的子进程</strong>，或<strong>有权限操作</strong>的进程</p><blockquote><p>也可以改变自己的进程组</p></blockquote></li></ul></li></ul><hr><p><em>会话的概念与特性：</em></p><ul><li>会话就是<strong>一组进程组</strong></li><li>创建会话的进程<strong>不能是原组长</strong>进程。创建会话的进程会成为<strong>首进程/会长</strong>(session leader)，并且会成为一个<strong>新进程组的组长</strong></li><li><strong>新会话</strong><u>丢弃原有的控制终端</u>，<strong>没有控制终端</strong>，只在后台执行</li><li>Shell进程创建出的进程，进程组会变化，但会话与Shell进程保持一致</li></ul><hr><p><em>会话操作函数：</em></p><ul><li><code>pid_t getsid(pid_t pid);</code>：获取进程<strong>所属的会话ID</strong><ul><li>成功返回会话ID，失败返回-1并设置errno</li><li><code>pid</code>为0表示查看当前进程会话ID</li></ul></li><li><code>pid_t setsid(void);</code>：创建一个会话，并以自己的ID设置<strong>新进程组ID</strong>，同时也是<strong>新会话ID</strong><ul><li>成功返回新会话ID，失败返回-1并设置errno</li><li>创建会话的一般流程：父进程<code>fork</code>并退出，子进程<code>setsid</code></li></ul></li></ul><hr><p><em>守护进程：</em></p><ul><li><p>Daemon(精灵)进程，是Linux中的<strong>后台服务进程</strong>，通常独立于控制终端，并且<strong>周期性</strong>地执行某种任务或等待处理某些发生的事件。一般采用以d结尾的名字。</p></li><li><p><strong>创建守护进程</strong>的模型</p><ol><li><p>创建子进程，父进程退出</p><blockquote><p>形式上<strong>脱离了控制终端</strong></p></blockquote></li><li><p>在子进程中创建新会话</p><blockquote><p>使子进程<strong>完全独立</strong>出来，脱离控制，不受用户登录和注销的影响</p></blockquote></li><li><p>改变<strong>工作目录</strong>为根目录等不会被删除的目录</p><blockquote><p><code>chdir()</code>函数</p></blockquote></li><li><p>重设文件权限掩码</p><blockquote><p><code>umask()</code>函数</p><p>防止继承的文件创建屏蔽字拒绝某些权限，增加守护进程灵活性</p></blockquote></li><li><p>关闭标准输入、输出、错误的<strong>文件描述符</strong></p><blockquote><p>继承的打开文件不会用到，浪费系统资源，无法卸载；</p><p>更常用的做法是，将0、1、2重定向到/dev/null，保持可用的文件描述符从3开始</p></blockquote></li><li><p>开始执行守护进程核心工作（周期性执行）</p></li><li><p>守护进程退出处理程序模型</p></li></ol><blockquote><p>如果想让守护进程随着机器重启，可以修改<code>~/.bashrc</code>，将守护进程的启动加入进去</p></blockquote></li></ul><h3 id="_3-7-线程基础" tabindex="-1"><a class="header-anchor" href="#_3-7-线程基础" aria-hidden="true">#</a> 3.7 线程基础</h3><h4 id="线程资源" tabindex="-1"><a class="header-anchor" href="#线程资源" aria-hidden="true">#</a> <em>线程资源：</em></h4><ul><li><p>共享资源</p><ul><li><p>大部分内存地址空间 (.text/.data/.bss/heap/共享库)、文件描述符表</p><blockquote><p>除了<strong>栈</strong>和errno变量不共享，其他的包括<strong>全局变量</strong>都共享，所以可以在一个线程中释放其他线程的申请的空间（<code>malloc</code>、<code>mmap</code>）</p></blockquote></li><li><p>当前工作目录、用户ID和组ID</p></li><li><p>每种信号的处理方式</p></li></ul></li><li><p>非共享资源</p><ul><li><p>线程id</p></li><li><p>处理器现场和栈指针(内核栈)、独立的<strong>栈空间</strong>(用户空间栈)</p><blockquote><p>同一进程各线程栈的空间地址值是互相不冲突、不相同的</p></blockquote></li><li><p>errno变量</p></li><li><p><strong>信号屏蔽字</strong></p></li><li><p>调度优先级</p></li></ul></li></ul><hr><h4 id="线程操作函数" tabindex="-1"><a class="header-anchor" href="#线程操作函数" aria-hidden="true">#</a> <em>线程操作函数：</em></h4><blockquote><p>编译链接时要加<code>-pthread</code>才可以链接到这些函数，同时注意版本<code>getconf GNU_LIBPTHREAD_VERSION</code></p></blockquote><ul><li><p><code>pthread_t pthread_self(void);</code>：获取线程ID</p><ul><li><p><code>pthread_t</code>在 Linux 中本质是无符号整数</p></li><li><p>该函数调用不会失败，返回的就是线程ID</p><blockquote><p>线程ID和LWP线程号不是同一个东西，<strong>LWP线程号</strong>是<strong>CPU给线程分配时间片</strong>的依据</p><blockquote><p><code>ps -Lf 进程ID</code>可以查看线程 LWP 号</p></blockquote></blockquote></li></ul></li><li><p><code>int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine) (void *), void *arg);</code>：</p><ul><li><p><code>thread</code>：是传出参数，代表创建的线程ID</p></li><li><p><code>attr</code>：线程属性，默认可以传NULL</p></li><li><p><code>start_routine</code>：线程的主控函数</p></li><li><p><code>arg</code>：主控函数的参数</p></li><li><p>成功返回0，失败直接返回error number</p><blockquote><p>Linux环境下所有线程API都是这样的返回</p></blockquote></li><li><p>循环创建多个子线程</p><p><code>pthread_create(&amp;tid, NULL, thrd_func, (void *)arg)</code></p><ul><li><p>子线程中<code>arg</code>可能的使用方式：<code>(int)arg</code></p></li><li><p>如果使用<code>(void *)&amp;arg</code>这种方式，传入的是父线程的地址空间，可能会造成问题</p><blockquote><p>这种情况下可能的使用方式：<code>*((int *)arg)</code></p></blockquote></li></ul></li></ul></li><li><p><code>void pthread_exit(void *retval);</code></p><ul><li><p><code>retval</code>表示线程退出状态，通常传<code>NULL</code></p></li><li><p>用<code>pthread_exit</code>退出主控线程或子线程，若<strong>进程内还有其他线程</strong>存在，则进程不会结束</p><blockquote><p>如果在主控线程或子线程中使用<code>exit</code>函数退出，会直接退出整个进程；</p><p>如果在主控线程中使用<code>return</code>退出，会直接退出整个进程；</p><p>如果在子线程的主控函数中使用<code>return</code>退出，相当于用<code>pthread_exit</code>退出</p></blockquote></li></ul></li><li><p><code>int pthread_join(pthread_t thread, void **retval);</code>：<strong>阻塞</strong>等待线程退出，获取线程退出状态</p><ul><li><code>retval</code>：存储线程结束状态，指向的是<code>pthread_exit</code>函数的入参，所以是<code>void**</code>类型</li><li>可能的使用方式：<code>pthread_join(tid, (void **)&amp;retval)</code>，<code>retval</code>是<strong>一级指针</strong></li><li>与进程的区别是，线程与线程之间也可以调用<code>pthread_join</code>来“回收”</li><li>成功返回0，失败返回error number</li></ul></li><li><p><code>int pthread_detach(pthread_t thread);</code>：分离线程</p><ul><li>线程分离状态：线程与主控线程断开关系，结束后<strong>自动释放</strong>（清理PCB）</li><li>如果用<code>pthread_join</code>回收分离的线程，会出错，返回22</li><li>成功返回0，失败返回error number</li></ul></li><li><p><code>int pthread_cancel(pthread_t thread);</code>：杀死(取消)线程</p><ul><li><p>线程的取消并不是实时的，需要等待线程<strong>到达</strong>某个**<u>取消点(检查点)</u>**时</p><ul><li><p>取消点：线程检查是否被取消，并按请求进行动作的一个位置，通常是某些系统调用</p><blockquote><p><code>man 7 pthreads</code>可以查看具备取消点的系统调用列表</p></blockquote></li><li><p>自行添加取消点：<code>pthread_testcancel();</code></p></li></ul></li><li><p>如果用<code>pthread_join</code>回收取消的线程，会出错，返回-1</p><blockquote><p><code>pthread.h: #define PTHREAD_CANCELED ((void *) -1)</code></p></blockquote></li><li><p>成功返回0，失败返回error number</p></li></ul></li><li><p><code>int pthread_equal(pthread_t t1, pthread_t t2);</code>：比较两个线程ID是否相等</p><ul><li>当然，目前<code>pthread_t</code>就是整型，可以直接用<code>==</code>判等，之后如果改成其他的比如结构体类型，就需要用<code>pthread_equal</code>了</li></ul></li></ul><hr><h4 id="线程属性" tabindex="-1"><a class="header-anchor" href="#线程属性" aria-hidden="true">#</a> <em>线程属性：</em></h4><ul><li><p><code>pthread_attr_t </code>结构体的重要成员</p><ul><li><p><code>int etachstate; //线程的分离状态</code></p></li><li><p><code>size_t stacksize; //线程栈的大小</code></p><blockquote><p>线程栈默认大小是<strong>均分进程栈（8MB）</strong></p></blockquote></li><li><p><code>size_t guardsize; //线程栈末尾的警戒缓冲区大小</code></p><blockquote><p>警戒区用于防止线程栈溢出</p></blockquote></li></ul></li><li><p>线性属性初始化与销毁</p><ul><li><code>int pthread_attr_init(pthread_attr_t *attr);</code>：初始化线程属性 <ul><li>应先初始化线程属性，再<code>pthread_create</code>创建线程。当然这个函数只是初始化，不是设置属性</li><li>成功返回0，失败返回错误号</li></ul></li><li><code>int pthread_attr_destroy(pthread_attr_t *attr);</code>：销毁线程属性所占用的资源 <ul><li>成功返回0，失败返回错误号</li></ul></li></ul></li><li><p>线程分离的属性</p><ul><li><p><code>int pthread_attr_setdetachstate(pthread_attr_t *attr, int detachstate);</code>：设置线程的分离属性</p><ul><li><p><code>detachstate</code></p><p><code>PTHREAD_CREATE_DETACHED</code>：分离</p><p><code>PTHREAD _CREATE_JOINABLE</code>：不分离</p></li></ul></li><li><p><code>int pthread_attr_getdetachstate(pthread_attr_t *attr, int *detachstate);</code>：获取线程的分离属性</p></li></ul><blockquote><p>如果设置一个线程为分离线程，而这个线程运行又非常快，它很可能在<code>pthread_create</code>函数返回之前就终止了，终止后可能将<strong>线程号和系统资源</strong>移交给其他的线程使用，这样调用<code>pthread_create</code>的线程就得到了<strong>错误的线程号</strong>。可以用线程同步的手段解决这个问题。</p></blockquote></li><li><p>线程的栈空间属性</p><ul><li><p><code>int pthread_attr_setstack(pthread_attr_t *attr, void *stackaddr, size_t stacksize);</code>：设置栈地址和大小</p><blockquote><p>可以将线程的栈地址设置到<strong>堆</strong>中（<code>malloc</code>）</p></blockquote></li><li><p><code>int pthread_attr_getstack(pthread_attr_t *attr, void **stackaddr, size_t *stacksize);</code>：获取栈地址和大小</p></li><li><p><code>int pthread_attr_setstacksize(pthread_attr_t *attr, size_t stacksize);</code>：设置栈大小</p></li><li><p><code>int pthread_attr_getstacksize(pthread_attr_t *attr, size_t *stacksize);</code>：获取栈大小</p></li></ul></li></ul><hr><h4 id="线程使用注意事项" tabindex="-1"><a class="header-anchor" href="#线程使用注意事项" aria-hidden="true">#</a> <em>线程使用注意事项：</em></h4><ul><li>线程库版本问题<code>getconf GNU_LIBPTHREAD_VERSION</code></li><li>避免僵尸线程，要么<code>join</code>回收，要么<code>detach</code>分离（或者修改线程属性使其分离）</li><li>尽量避免在多线程模型中使用<code>fork</code>。<code>fork</code>后子进程中只存在调用<code>fork</code>的“线程”，其他“线程”都退出了</li><li>尽量避免在多线程模型中使用信号机制</li></ul><h3 id="_3-8-线程和进程的同步与互斥" tabindex="-1"><a class="header-anchor" href="#_3-8-线程和进程的同步与互斥" aria-hidden="true">#</a> 3.8 线程和进程的同步与互斥</h3><h4 id="互斥量mutex" tabindex="-1"><a class="header-anchor" href="#互斥量mutex" aria-hidden="true">#</a> <em>互斥量<code>mutex</code>：</em></h4><ul><li><p><code>pthread_mutex_t</code>本质是结构体，可以简单认为其只有0、1两种取值</p></li><li><p><code>mutex</code>相关函数</p><blockquote><p>这些函数均是成功返回0，失败返回错误号</p></blockquote><ul><li><p><code>int pthread_mutex_init(pthread_mutex_t *restrict mutex, const pthread_mutexattr_t *restrict attr);</code>：初始化一个互斥锁</p><ul><li><p>可以理解为<code>mutex = 1</code></p></li><li><p><code>restrict</code>关键字：所有修改<strong>该指针指向内存</strong>的操作，只能通过本指针完成，不能通过除本指针以外的其他变量或指针修改</p></li><li><p><code>attr</code>：互斥锁的属性，传入<code>NULL</code>为默认属性</p></li><li><p>也可以使用<strong>宏</strong>直接初始化：（静态初始化）</p><p><code>pthead_mutex_t muetx = PTHREAD_MUTEX_INITIALIZER;</code></p></li></ul></li><li><p><code>int pthread_mutex_destroy(pthread_mutex_t *mutex);</code>：销毁一个互斥锁</p></li><li><p><code>int pthread_mutex_lock(pthread_mutex_t *mutex);</code>：上锁</p><ul><li>可理解为<code>mutex--</code></li><li>锁被占用则阻塞，直到成功获得锁</li></ul></li><li><p><code>int pthread_mutex_unlock(pthread_mutex_t *mutex);</code>：解锁</p><ul><li>可理解为<code>mutex++</code></li></ul></li><li><p><code>int pthread_mutex_trylock(pthread_mutex_t *mutex);</code>：尝试上锁</p><ul><li>锁被占用不阻塞，返回<code>EBUSY</code>代表无法获得锁</li></ul></li></ul></li><li><p><code>mutex</code>的应用</p><ol><li>定义锁：<code>pthread_mutex_t mutex;</code><ul><li>一般为<strong>全局变量</strong></li></ul></li><li>初始化锁</li><li>上锁</li><li>解锁</li></ol><blockquote><p>锁的<strong>粒度</strong>应当尽量小</p></blockquote></li><li><p>死锁</p><ul><li>两种产生情况 <ul><li>不可重入锁</li><li>两把锁</li></ul></li><li>对应解决方法 <ul><li>可重入锁</li><li><code>trylock</code>失败则释放锁</li></ul></li></ul></li></ul><hr><h4 id="读写锁rwlock" tabindex="-1"><a class="header-anchor" href="#读写锁rwlock" aria-hidden="true">#</a> <em>读写锁<code>rwlock</code>：</em></h4><ul><li><p><code>rwlock</code>特性</p><ul><li>⭐写独占、读共享</li><li>⭐写锁优先级高</li></ul></li><li><p><code>rwlock</code>相关函数</p><blockquote><p>这些函数均是成功返回0，失败返回错误号。用法与<code>mutex</code>很相似</p></blockquote><ul><li><p><code>int pthread_rwlock_init(pthread_rwlock_t *restrict rwlock, const pthread_rwlockattr_t *restrict attr);</code>：初始化一把读写锁</p><ul><li><p><code>attr</code>：传入<code>NULL</code>代表使用默认属性</p></li><li><p>也可以使用<strong>宏</strong>直接初始化：（静态初始化）</p><p><code>pthread_rwlock_t rwlock = PTHREAD_RWLOCK_INITIALIZER;</code></p></li></ul></li><li><p><code>int pthread_rwlock_destroy(pthread_rwlock_t *rwlock);</code>：销毁一把读写锁</p></li><li><p><code> int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock);</code>：请求读锁</p></li><li><p><code>int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock);</code>：请求写锁</p></li><li><p><code>int pthread_rwlock_unlock(pthread_rwlock_t *rwlock);</code>：解锁</p></li><li><p><code>int pthread_rwlock_tryrdlock(pthread_rwlock_t *rwlock);</code>：非阻塞请求读锁</p></li><li><p><code>int pthread_rwlock_trywrlock(pthread_rwlock_t *rwlock);</code>：非阻塞请求写锁</p></li></ul></li><li><p><code>rwlock</code>的应用：<code>pthread_rwlock t rwlock;</code></p><blockquote><p>与<code>mutex</code>很相似</p></blockquote></li><li><p><code>rwlock</code>的优点：适合读多写少的场景，减少不必要的竞争</p></li></ul><hr><h4 id="条件变量cond" tabindex="-1"><a class="header-anchor" href="#条件变量cond" aria-hidden="true">#</a> <em>条件变量<code>cond</code>：</em></h4><ul><li><p>特点：</p><ul><li>条件变量本身不是锁！但它也可以造成线程阻塞。</li><li>通常与互斥锁配合使用，给多线程提供一个会合的场所。</li></ul></li><li><p><code>cond</code>相关函数：</p><blockquote><p>这些函数均是成功返回0，失败返回错误号。</p></blockquote><ul><li><p><code>int pthread_cond_init(pthread_cond_t *restrict cond, const pthread_condattr_t *restrict attr);</code>：初始化一个条件变量</p><ul><li><p>也可以使用<strong>宏</strong>直接初始化：（静态初始化）</p><p><code>pthread_cond_t cond = PTHREAD_COND_INITIALIZER;</code></p></li></ul></li><li><p><code>int pthread_cond_destroy(pthread_cond_t *cond);</code>：销毁一个条件变量</p></li><li><p>⭐<code>int pthread_cond_wait(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex);</code>：阻塞等待一个条件变量满足</p><ul><li><p><code>mutex</code>：需要传入一个也初始化好的<code>mutex</code>，并且已经对其<strong>加锁</strong>了</p></li><li><p>会释放已掌握的互斥锁（<strong>解锁互斥量</strong>），相当于<code>pthread_mutex_unlock(&amp;mutex)</code></p><blockquote><p><strong>检查条件变量是否满足与加锁</strong>的操作是不可分割的</p></blockquote></li><li><p>当被<strong>唤醒</strong>，函数返回即将时，会解除阻塞并重新申请<strong>获取互斥锁</strong>，相当于<code>pthread_mutex_lock(&amp;mutex)</code></p></li></ul></li><li><p><code>int pthread_cond_signal(pthread_cond_t *cond);</code>：唤醒<strong>至少一个</strong>阻塞在条件变量上的线程</p></li><li><p><code>int pthread_cond_broadcast(pthread_cond_t *cond);</code>：唤醒<strong>全部</strong>阻塞在条件变量上的线程</p></li><li><p><code>int pthread_cond_timedwait(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex, const struct timespec *restrict abstime);</code>：限时等待一个条件变量</p><ul><li><p>也会释放锁和申请锁</p></li><li><p><code>abstime</code>：绝对时间，是相对于<code>1970-1-1 00:00:00</code>的时间</p><blockquote><p>可以在<code>man sem_timedwait</code>中找到对应结构体的定义</p></blockquote><blockquote><p>正确用法：</p><p><code>time_t cur = time(NULL);</code></p><p><code>struct timespec t;</code></p><p><code>t.tv_sec = cur + 1</code></p><p><code>pthread_cond_timedwait(&amp;cond, &amp;mutex, &amp;t)</code></p></blockquote></li></ul></li></ul></li><li><p>条件变量的优点：相比于<code>mutex</code>，可以减少不必要的竞争，提高效率</p><blockquote><p>例如生产者与消费者模型中，在没有产品时，使用条件变量，消费者就<strong>不必互相竞争，而是都等待</strong></p></blockquote></li></ul><hr><h4 id="信号量semaphore" tabindex="-1"><a class="header-anchor" href="#信号量semaphore" aria-hidden="true">#</a> <em>信号量<code>semaphore</code>：</em></h4><ul><li><p><code>semaphore.h</code>，信号量，可以理解成互斥锁的“加强版”，可以进一步细化锁，保证互斥与同步，又提高并发度</p></li><li><p>主要应用函数（注意，没有<code>pthread</code>前缀，进程线程都可以用）</p><blockquote><p>这些函数都是成功返回0， 失败返回-1，同时设置errno</p></blockquote><ul><li><p><code>int sem_init(sem_t *sem, int pshared, unsigned int value);</code>：初始化一个信号量</p><ul><li><p><code>pshared</code>：0表示只用于线程间，非0表示可用于进程间</p></li><li><p><code>value</code>：信号量初值</p><blockquote><p><strong>信号量的初值决定了占用信号量的线程/进程个数</strong></p></blockquote></li></ul></li><li><p><code>int sem_destroy(sem_t *sem);</code>：销毁一个信号量</p></li><li><p><code>int sem_wait(sem_t *sem);</code>：给信号量加锁（<code>sem--</code>）</p></li><li><p><code>int sem_post(sem_t *sem);</code>：给信号量解锁（<code>sem++</code>）</p></li><li><p><code>int sem_trywait(sem_t *sem);</code>：尝试对信号量加锁</p></li><li><p><code>int sem_timedwait(sem_t *sem, const struct timespec *abs_timeout);</code>：限时尝试对信号量加锁</p></li></ul></li><li><p>信号量的特点：可以由多个线程/进程占用</p></li></ul><hr><h4 id="进程间同步" tabindex="-1"><a class="header-anchor" href="#进程间同步" aria-hidden="true">#</a> <em>进程间同步：</em></h4><ul><li><p>通过互斥量<code>mutex</code>实现：指定初始化时的属性<code>pthread_mutexattr_t mattr attr</code></p><ul><li><p><code>int pthread_mutexattr_init(pthread_mutexattr_t *attr);</code>：初始化一个**<code>mutex</code>属性**对象</p></li><li><p><code>int pthread_mutexattr_destroy(pthread_mutexattr_t *attr);</code>：销毁**<code>mutex</code>属性**对象</p></li><li><p><code>int pthread_mutexattr_setpshared(pthread_mutexattr_t *attr, int pshared);</code>：修改<code>mutex</code>的共享属性</p><ul><li><p><code>PTHREAD_PROCESS_PRIVATE</code>：进程间私有，即线程锁</p><blockquote><p>也是默认属性</p></blockquote></li><li><p><code>PTHREAD_PROCESS_SHARED</code>：进程锁</p></li></ul></li></ul></li><li><p>通过信号量<code>semaphore</code>实现</p></li><li><p>借助文件锁实现：<code>int fcntl(int fd, int cmd, ... /* arg */ );</code></p><ul><li><p><code>cmd</code>：函数操作类型</p><ul><li><p><code>F_SETLK</code>：设置文件锁（trylock）</p></li><li><p><code>F_SETLKW</code>：设置文件锁（lock、unlock）</p><blockquote><p>通过下面结构体的<code>l_type</code>成员指定</p></blockquote></li><li><p><code>F_GETLK</code>：获取文件锁</p></li></ul></li><li><p>可变参：<code>struct flock</code></p><p><code>struct flock {</code></p><p>​ <code>short l_type; 锁的类型：F_RDLCK 、F_WRLCK 、F_UNLCK</code></p><p>​ <code>short l_whence; 偏移位置：SEEK_SET、SEEK_CUR、SEEK_END </code></p><p>​ <code>off_t l_start; 起始偏移：1000</code></p><p>​ <code>off_t l_len; 长度：0表示整个文件加锁</code></p><p>​ <code>pid_t l_pid; 持有该锁的进程ID：(F_GETLK only)</code></p><p>​ <code> };</code></p><blockquote><p>提供了读锁和写锁，也允许只锁一个文件的<strong>一部分</strong></p></blockquote></li></ul><blockquote><p>多线程同步不能使用文件锁，因为同一个进程中的多线程共享文件描述符，也共享相应的文件结构体</p></blockquote></li></ul><h2 id="_4-网络编程" tabindex="-1"><a class="header-anchor" href="#_4-网络编程" aria-hidden="true">#</a> 4 网络编程</h2></div><!----><footer class="page-meta"><div class="meta-item edit-link"><a href="https://github.com/SunDocker/SunDocker.github.io/edit/main/docs/notes/C/LinuxSystemProgramming.md" rel="noopener noreferrer" target="_blank" aria-label="Edit this page on GitHub" class="nav-link label"><!--[--><svg xmlns="http://www.w3.org/2000/svg" class="icon edit-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="edit icon"><path d="M430.818 653.65a60.46 60.46 0 0 1-50.96-93.281l71.69-114.012 7.773-10.365L816.038 80.138A60.46 60.46 0 0 1 859.225 62a60.46 60.46 0 0 1 43.186 18.138l43.186 43.186a60.46 60.46 0 0 1 0 86.373L588.879 565.55l-8.637 8.637-117.466 68.234a60.46 60.46 0 0 1-31.958 11.229z"></path><path d="M728.802 962H252.891A190.883 190.883 0 0 1 62.008 771.98V296.934a190.883 190.883 0 0 1 190.883-192.61h267.754a60.46 60.46 0 0 1 0 120.92H252.891a69.962 69.962 0 0 0-69.098 69.099V771.98a69.962 69.962 0 0 0 69.098 69.098h475.911A69.962 69.962 0 0 0 797.9 771.98V503.363a60.46 60.46 0 1 1 120.922 0V771.98A190.883 190.883 0 0 1 728.802 962z"></path></svg><!--]-->Edit this page on GitHub<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!----></a></div><div class="meta-item git-info"><div class="update-time"><span class="label">Last update: </span><!----></div><div class="contributors"><span class="label">Contributors: </span><!--[--><!--[--><span class="contributor" title="email: sundocker@qq.com">SunDocker</span><!--]--><!--]--></div></div></footer><nav class="page-nav"><a href="/notes/C/Cpp.html" class="nav-link prev" aria-label="C++"><div class="hint"><span class="arrow start"></span>Prev</div><div class="link"><!---->C++</div></a><!----></nav><!----><!----><!--]--></main><!--]--><footer class="footer-wrapper"><div class="footer">Default footer</div><div class="copyright">Copyright © 2023 Dominic Sun</div></footer></div><!--]--><!----><!----><!--]--></div>
    <script type="module" src="/assets/app-92a4b31c.js" defer></script>
  </body>
</html>
