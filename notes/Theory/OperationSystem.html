<!DOCTYPE html>
<html lang="en-US" data-theme="light">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-beta.60" />
    <meta name="theme" content="VuePress Theme Hope" />
    <meta property="og:url" content="https://www.sundocker.online/notes/Theory/OperationSystem.html"><meta property="og:site_name" content="SunDocker"><meta property="og:title" content="Operation System"><meta property="og:description" content="1 操作系统概述 1.1 基本概念与功能 概念：操作系统（Operating System，OS）是指; 控制和管理整个计算机系统的硬件和软件资源，并合理地组织调度计算机的工作和资源的分配，; 以提供给用户和其他软件方便的接口调用和环境的系统软件，; 它是计算机系统中最基本的系统软件。; 简单来说， - 从程序的角度来讲，操作系统就是 对象+API（系..."><meta property="og:type" content="article"><meta property="og:locale" content="en-US"><meta property="og:updated_time" content="2023-02-20T07:31:00.000Z"><meta property="article:tag" content="Computer"><meta property="article:tag" content="Operation System"><meta property="article:published_time" content="2023-02-19T00:00:00.000Z"><meta property="article:modified_time" content="2023-02-20T07:31:00.000Z"><script type="application/ld+json">{"@context":"https://schema.org","@type":"Article","headline":"Operation System","image":[""],"datePublished":"2023-02-19T00:00:00.000Z","dateModified":"2023-02-20T07:31:00.000Z","author":[]}</script><title>Operation System | SunDocker</title><meta name="description" content="1 操作系统概述 1.1 基本概念与功能 概念：操作系统（Operating System，OS）是指; 控制和管理整个计算机系统的硬件和软件资源，并合理地组织调度计算机的工作和资源的分配，; 以提供给用户和其他软件方便的接口调用和环境的系统软件，; 它是计算机系统中最基本的系统软件。; 简单来说， - 从程序的角度来讲，操作系统就是 对象+API（系...">
    <style>
      :root {
        --bg-color: #fff;
      }

      html[data-theme="dark"] {
        --bg-color: #1d1e1f;
      }

      html,
      body {
        background: var(--bg-color);
      }
    </style>
    <script>
      const userMode = localStorage.getItem("vuepress-theme-hope-scheme");
      const systemDarkMode =
        window.matchMedia &&
        window.matchMedia("(prefers-color-scheme: dark)").matches;

      if (userMode === "dark" || (userMode !== "light" && systemDarkMode)) {
        document.querySelector("html").setAttribute("data-theme", "dark");
      }
    </script>
    <link rel="preload" href="/assets/style-28c78fad.css" as="style"><link rel="stylesheet" href="/assets/style-28c78fad.css">
    <link rel="modulepreload" href="/assets/app-aa324d52.js"><link rel="modulepreload" href="/assets/framework-3800c176.js"><link rel="modulepreload" href="/assets/OperationSystem.html-fc19a38e.js"><link rel="modulepreload" href="/assets/OperationSystem.html-5f70e895.js">
  </head>
  <body>
    <div id="app"><!--[--><!--[--><!--[--><span tabindex="-1"></span><a href="#main-content" class="skip-link sr-only">Skip to main content</a><!--]--><div class="theme-container has-toc"><!--[--><header class="navbar" id="navbar"><div class="navbar-start"><button class="toggle-sidebar-button" title="Toggle Sidebar"><span class="icon"></span></button><!--[--><!----><!--]--><a href="/" class="brand"><img class="logo" src="/logo0.png" alt="SunDocker"><!----><span class="site-name hide-in-pad">SunDocker</span></a><!--[--><!----><!--]--></div><div class="navbar-center"><!--[--><!----><!--]--><nav class="nav-links"><div class="nav-item hide-in-mobile"><a href="/" class="nav-link" aria-label="Blog Home"><span class="font-icon icon iconfont icon-home" style=""></span>Blog Home<!----></a></div><div class="nav-item hide-in-mobile"><a href="/posts/" class="nav-link" aria-label="Posts"><span class="font-icon icon iconfont icon-blog" style=""></span>Posts<!----></a></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="Notes"><span class="title"><span class="font-icon icon iconfont icon-repo" style=""></span>Notes</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>Theory</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a aria-current="page" href="/notes/Theory/OperationSystem.html" class="router-link-active router-link-exact-active nav-link active" aria-label="Operation System"><span class="font-icon icon iconfont icon-OS" style=""></span>Operation System<!----></a></li><li class="dropdown-subitem"><a href="/notes/Theory/DataStructure.html" class="nav-link" aria-label="Data Structure &amp; Algorithm"><span class="font-icon icon iconfont icon-emmet" style=""></span>Data Structure &amp; Algorithm<!----></a></li><li class="dropdown-subitem"><a href="/notes/Theory/ComputerNetwork.html" class="nav-link" aria-label="Computer Network"><span class="font-icon icon iconfont icon-network" style=""></span>Computer Network<!----></a></li><li class="dropdown-subitem"><a href="/notes/Theory/DatabaseSystem.html" class="nav-link" aria-label="Database System"><span class="font-icon icon iconfont icon-storage" style=""></span>Database System<!----></a></li><li class="dropdown-subitem"><a href="/notes/Theory/CompositionPrinciple.html" class="nav-link" aria-label="Composition Principle"><span class="font-icon icon iconfont icon-process" style=""></span>Composition Principle<!----></a></li><li class="dropdown-subitem"><a href="/notes/Theory/DesignPatterns.html" class="nav-link" aria-label="Design Patterns"><span class="font-icon icon iconfont icon-float" style=""></span>Design Patterns<!----></a></li><li class="dropdown-subitem"><a href="/notes/Theory/CompilePrinciple.html" class="nav-link" aria-label="Compiler Principle"><span class="font-icon icon iconfont icon-semantic" style=""></span>Compiler Principle<!----></a></li><li class="dropdown-subitem"><a href="/notes/Theory/XV6LabSummary.html" class="nav-link" aria-label="XV6 Lab Summary"><span class="font-icon icon iconfont icon-OS" style=""></span>XV6 Lab Summary<!----></a></li></ul></li><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>C</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/notes/C/Cpp.html" class="nav-link" aria-label="C++"><span class="font-icon icon iconfont icon-c" style=""></span>C++<!----></a></li><li class="dropdown-subitem"><a href="/notes/C/LinuxSystemProgramming.html" class="nav-link" aria-label="Linux System Programming"><span class="font-icon icon iconfont icon-linux" style=""></span>Linux System Programming<!----></a></li><li class="dropdown-subitem"><a href="/notes/C/LinuxNetworkProgramming.html" class="nav-link" aria-label="Linux Network Programming"><span class="font-icon icon iconfont icon-linux" style=""></span>Linux Network Programming<!----></a></li></ul></li><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>Java</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/notes/Java/JavaSE.html" class="nav-link" aria-label="Java SE"><span class="font-icon icon iconfont icon-java" style=""></span>Java SE<!----></a></li><li class="dropdown-subitem"><a href="/notes/Java/Servlet.html" class="nav-link" aria-label="Servlet"><span class="font-icon icon iconfont icon-api" style=""></span>Servlet<!----></a></li><li class="dropdown-subitem"><a href="/notes/Java/JDBC.html" class="nav-link" aria-label="JDBC"><span class="font-icon icon iconfont icon-api" style=""></span>JDBC<!----></a></li><li class="dropdown-subitem"><a href="/notes/Java/SpringFramework.html" class="nav-link" aria-label="Spring Framework"><span class="font-icon icon iconfont icon-leaf" style=""></span>Spring Framework<!----></a></li><li class="dropdown-subitem"><a href="/notes/Java/MyBatis.html" class="nav-link" aria-label="MyBatis"><span class="font-icon icon iconfont icon-storage" style=""></span>MyBatis<!----></a></li><li class="dropdown-subitem"><a href="/notes/Java/SpringMVC.html" class="nav-link" aria-label="Spring MVC"><span class="font-icon icon iconfont icon-view" style=""></span>Spring MVC<!----></a></li><li class="dropdown-subitem"><a href="/notes/Java/SpringBoot.html" class="nav-link" aria-label="Spring Boot"><span class="font-icon icon iconfont icon-light" style=""></span>Spring Boot<!----></a></li><li class="dropdown-subitem"><a href="/notes/Java/SpringCloud.html" class="nav-link" aria-label="Spring Cloud"><span class="font-icon icon iconfont icon-cache" style=""></span>Spring Cloud<!----></a></li><li class="dropdown-subitem"><a href="/notes/Java/JUC.html" class="nav-link" aria-label="JUC"><span class="font-icon icon iconfont icon-asynchronous" style=""></span>JUC<!----></a></li><li class="dropdown-subitem"><a href="/notes/Java/Java-gRPC.html" class="nav-link" aria-label="Java gRPC"><span class="font-icon icon iconfont icon-remote" style=""></span>Java gRPC<!----></a></li><li class="dropdown-subitem"><a href="/notes/Java/Netty.html" class="nav-link" aria-label="Netty"><span class="font-icon icon iconfont icon-network" style=""></span>Netty<!----></a></li><li class="dropdown-subitem"><a href="/notes/Java/Hadoop.html" class="nav-link" aria-label="Hadoop"><span class="font-icon icon iconfont icon-overflow" style=""></span>Hadoop<!----></a></li><li class="dropdown-subitem"><a href="/notes/Java/Kotlin.html" class="nav-link" aria-label="Kotlin"><span class="font-icon icon iconfont icon-compare" style=""></span>Kotlin<!----></a></li></ul></li><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>Database</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/notes/Database/MySQL.html" class="nav-link" aria-label="MySQL"><span class="font-icon icon iconfont icon-mysql" style=""></span>MySQL<!----></a></li><li class="dropdown-subitem"><a href="/notes/Database/Redis.html" class="nav-link" aria-label="Redis"><span class="font-icon icon iconfont icon-bitbucket" style=""></span>Redis<!----></a></li></ul></li><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>Frontend</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/notes/Frontend/HTML.html" class="nav-link" aria-label="HTML"><span class="font-icon icon iconfont icon-html" style=""></span>HTML<!----></a></li><li class="dropdown-subitem"><a href="/notes/Frontend/JavaScript.html" class="nav-link" aria-label="JavaScript"><span class="font-icon icon iconfont icon-javascript" style=""></span>JavaScript<!----></a></li><li class="dropdown-subitem"><a href="/notes/Frontend/CSS.html" class="nav-link" aria-label="CSS"><span class="font-icon icon iconfont icon-css" style=""></span>CSS<!----></a></li><li class="dropdown-subitem"><a href="/notes/Frontend/Node.html" class="nav-link" aria-label="Node"><span class="font-icon icon iconfont icon-nodeJS" style=""></span>Node<!----></a></li><li class="dropdown-subitem"><a href="/notes/Frontend/Vue.html" class="nav-link" aria-label="Vue"><span class="font-icon icon iconfont icon-vue" style=""></span>Vue<!----></a></li><li class="dropdown-subitem"><a href="/notes/Frontend/uni-app.html" class="nav-link" aria-label="uni-app"><span class="font-icon icon iconfont icon-app" style=""></span>uni-app<!----></a></li><li class="dropdown-subitem"><a href="/notes/Frontend/Dart.html" class="nav-link" aria-label="Dart"><span class="font-icon icon iconfont icon-dart" style=""></span>Dart<!----></a></li><li class="dropdown-subitem"><a href="/notes/Frontend/Flutter.html" class="nav-link" aria-label="Flutter"><span class="font-icon icon iconfont icon-dart" style=""></span>Flutter<!----></a></li></ul></li><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>Golang</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/notes/Golang/Golang.html" class="nav-link" aria-label="Golang"><span class="font-icon icon iconfont icon-chrome" style=""></span>Golang<!----></a></li><li class="dropdown-subitem"><a href="/notes/Golang/Gin.html" class="nav-link" aria-label="Gin"><span class="font-icon icon iconfont icon-rss" style=""></span>Gin<!----></a></li><li class="dropdown-subitem"><a href="/notes/Golang/Go-gRPC.html" class="nav-link" aria-label="Go gRPC"><span class="font-icon icon iconfont icon-remote" style=""></span>Go gRPC<!----></a></li></ul></li><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>Operations</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/notes/Operations/Linux.html" class="nav-link" aria-label="Linux"><span class="font-icon icon iconfont icon-linux" style=""></span>Linux<!----></a></li><li class="dropdown-subitem"><a href="/notes/Operations/Docker.html" class="nav-link" aria-label="Docker"><span class="font-icon icon iconfont icon-module" style=""></span>Docker<!----></a></li><li class="dropdown-subitem"><a href="/notes/Operations/Nginx.html" class="nav-link" aria-label="Nginx"><span class="font-icon icon iconfont icon-nginx" style=""></span>Nginx<!----></a></li><li class="dropdown-subitem"><a href="/notes/Operations/Kubernetes.html" class="nav-link" aria-label="Kubernetes"><span class="font-icon icon iconfont icon-relation" style=""></span>Kubernetes<!----></a></li></ul></li><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>Mangement</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/notes/Management/Git.html" class="nav-link" aria-label="Git"><span class="font-icon icon iconfont icon-git" style=""></span>Git<!----></a></li><li class="dropdown-subitem"><a href="/notes/Management/Maven.html" class="nav-link" aria-label="Maven"><span class="font-icon icon iconfont icon-box" style=""></span>Maven<!----></a></li><li class="dropdown-subitem"><a href="/notes/Management/Gradle.html" class="nav-link" aria-label="Gradle"><span class="font-icon icon iconfont icon-leaf" style=""></span>Gradle<!----></a></li></ul></li><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>Python</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/notes/Python/DataMining.html" class="nav-link" aria-label="Data Mining"><!---->Data Mining<!----></a></li><li class="dropdown-subitem"><a href="/notes/Python/DataAnalysis.html" class="nav-link" aria-label="Data Analysis"><!---->Data Analysis<!----></a></li><li class="dropdown-subitem"><a href="/notes/Python/MachineLearning.html" class="nav-link" aria-label="Machine Learning"><!---->Machine Learning<!----></a></li></ul></li></ul></button></div></div><div class="nav-item hide-in-mobile"><a href="/demo/" class="nav-link" aria-label="Overall"><span class="font-icon icon iconfont icon-discover" style=""></span>Overall<!----></a></div><div class="nav-item hide-in-mobile"><a href="https://theme-hope.vuejs.press/zh/" rel="noopener noreferrer" target="_blank" aria-label="Theme Docs" class="nav-link"><span class="font-icon icon iconfont icon-note" style=""></span>Theme Docs<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!----></a></div></nav><!--[--><!----><!--]--></div><div class="navbar-end"><!--[--><!----><!--]--><!----><div class="nav-item"><a class="repo-link" href="https://github.com/SunDocker/SunDocker.github.io" target="_blank" rel="noopener noreferrer" aria-label="GitHub"><svg xmlns="http://www.w3.org/2000/svg" class="icon github-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="github icon" style="width:1.25rem;height:1.25rem;vertical-align:middle;"><path d="M511.957 21.333C241.024 21.333 21.333 240.981 21.333 512c0 216.832 140.544 400.725 335.574 465.664 24.49 4.395 32.256-10.07 32.256-23.083 0-11.69.256-44.245 0-85.205-136.448 29.61-164.736-64.64-164.736-64.64-22.315-56.704-54.4-71.765-54.4-71.765-44.587-30.464 3.285-29.824 3.285-29.824 49.195 3.413 75.179 50.517 75.179 50.517 43.776 75.008 114.816 53.333 142.762 40.79 4.523-31.66 17.152-53.377 31.19-65.537-108.971-12.458-223.488-54.485-223.488-242.602 0-53.547 19.114-97.323 50.517-131.67-5.035-12.33-21.93-62.293 4.779-129.834 0 0 41.258-13.184 134.912 50.346a469.803 469.803 0 0 1 122.88-16.554c41.642.213 83.626 5.632 122.88 16.554 93.653-63.488 134.784-50.346 134.784-50.346 26.752 67.541 9.898 117.504 4.864 129.834 31.402 34.347 50.474 78.123 50.474 131.67 0 188.586-114.73 230.016-224.042 242.09 17.578 15.232 33.578 44.672 33.578 90.454v135.85c0 13.142 7.936 27.606 32.854 22.87C862.25 912.597 1002.667 728.747 1002.667 512c0-271.019-219.648-490.667-490.71-490.667z"></path></svg></a></div><div class="nav-item hide-in-mobile"><button class="outlook-button" tabindex="-1" ariahidden="true"><svg xmlns="http://www.w3.org/2000/svg" class="icon outlook-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="outlook icon"><path d="M224 800c0 9.6 3.2 44.8 6.4 54.4 6.4 48-48 76.8-48 76.8s80 41.6 147.2 0 134.4-134.4 38.4-195.2c-22.4-12.8-41.6-19.2-57.6-19.2C259.2 716.8 227.2 761.6 224 800zM560 675.2l-32 51.2c-51.2 51.2-83.2 32-83.2 32 25.6 67.2 0 112-12.8 128 25.6 6.4 51.2 9.6 80 9.6 54.4 0 102.4-9.6 150.4-32l0 0c3.2 0 3.2-3.2 3.2-3.2 22.4-16 12.8-35.2 6.4-44.8-9.6-12.8-12.8-25.6-12.8-41.6 0-54.4 60.8-99.2 137.6-99.2 6.4 0 12.8 0 22.4 0 12.8 0 38.4 9.6 48-25.6 0-3.2 0-3.2 3.2-6.4 0-3.2 3.2-6.4 3.2-6.4 6.4-16 6.4-16 6.4-19.2 9.6-35.2 16-73.6 16-115.2 0-105.6-41.6-198.4-108.8-268.8C704 396.8 560 675.2 560 675.2zM224 419.2c0-28.8 22.4-51.2 51.2-51.2 28.8 0 51.2 22.4 51.2 51.2 0 28.8-22.4 51.2-51.2 51.2C246.4 470.4 224 448 224 419.2zM320 284.8c0-22.4 19.2-41.6 41.6-41.6 22.4 0 41.6 19.2 41.6 41.6 0 22.4-19.2 41.6-41.6 41.6C339.2 326.4 320 307.2 320 284.8zM457.6 208c0-12.8 12.8-25.6 25.6-25.6 12.8 0 25.6 12.8 25.6 25.6 0 12.8-12.8 25.6-25.6 25.6C470.4 233.6 457.6 220.8 457.6 208zM128 505.6C128 592 153.6 672 201.6 736c28.8-60.8 112-60.8 124.8-60.8-16-51.2 16-99.2 16-99.2l316.8-422.4c-48-19.2-99.2-32-150.4-32C297.6 118.4 128 291.2 128 505.6zM764.8 86.4c-22.4 19.2-390.4 518.4-390.4 518.4-22.4 28.8-12.8 76.8 22.4 99.2l9.6 6.4c35.2 22.4 80 12.8 99.2-25.6 0 0 6.4-12.8 9.6-19.2 54.4-105.6 275.2-524.8 288-553.6 6.4-19.2-3.2-32-19.2-32C777.6 76.8 771.2 80 764.8 86.4z"></path></svg><div class="outlook-dropdown"><!----></div></button></div><!--[--><button class="search-pro-button" role="search" aria-label="Search"><svg xmlns="http://www.w3.org/2000/svg" class="icon search-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="search icon"><path d="M192 480a256 256 0 1 1 512 0 256 256 0 0 1-512 0m631.776 362.496-143.2-143.168A318.464 318.464 0 0 0 768 480c0-176.736-143.264-320-320-320S128 303.264 128 480s143.264 320 320 320a318.016 318.016 0 0 0 184.16-58.592l146.336 146.368c12.512 12.48 32.768 12.48 45.28 0 12.48-12.512 12.48-32.768 0-45.28"></path></svg><div class="placeholder">Search</div><div class="key-hints"><kbd class="key">Ctrl</kbd><kbd class="key">K</kbd></div></button><!--]--><!--[--><!----><!--]--><button class="toggle-navbar-button" aria-label="Toggle Navbar" aria-expanded="false" aria-controls="nav-screen"><span class="button-container"><span class="button-top"></span><span class="button-middle"></span><span class="button-bottom"></span></span></button></div></header><!----><!--]--><!----><div class="toggle-sidebar-wrapper"><span class="arrow start"></span></div><aside class="sidebar" id="sidebar"><!--[--><!----><!--]--><ul class="sidebar-links"><li><!--[--><a href="/notes/" class="nav-link sidebar-link sidebar-page" aria-label="Note"><span class="font-icon icon iconfont icon-list" style=""></span>Note<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><section class="sidebar-group"><button class="sidebar-heading clickable"><span class="font-icon icon iconfont icon-c" style=""></span><span class="title">C</span><span class="arrow end"></span></button><!----></section></li><li><section class="sidebar-group"><button class="sidebar-heading clickable"><span class="font-icon icon iconfont icon-storage" style=""></span><span class="title">Database</span><span class="arrow end"></span></button><!----></section></li><li><section class="sidebar-group"><button class="sidebar-heading clickable"><span class="font-icon icon iconfont icon-page" style=""></span><span class="title">Frontend</span><span class="arrow end"></span></button><!----></section></li><li><section class="sidebar-group"><button class="sidebar-heading clickable"><span class="font-icon icon iconfont icon-chrome" style=""></span><span class="title">Golang</span><span class="arrow end"></span></button><!----></section></li><li><section class="sidebar-group"><button class="sidebar-heading clickable"><span class="font-icon icon iconfont icon-java" style=""></span><span class="title">Java</span><span class="arrow end"></span></button><!----></section></li><li><section class="sidebar-group"><button class="sidebar-heading clickable"><span class="font-icon icon iconfont icon-tool" style=""></span><span class="title">Management</span><span class="arrow end"></span></button><!----></section></li><li><section class="sidebar-group"><button class="sidebar-heading clickable"><span class="font-icon icon iconfont icon-software" style=""></span><span class="title">Operations</span><span class="arrow end"></span></button><!----></section></li><li><section class="sidebar-group"><button class="sidebar-heading clickable"><span class="font-icon icon iconfont icon-python" style=""></span><span class="title">Python</span><span class="arrow end"></span></button><!----></section></li><li><section class="sidebar-group"><button class="sidebar-heading clickable active"><span class="font-icon icon iconfont icon-read" style=""></span><span class="title">Theory</span><span class="arrow down"></span></button><ul class="sidebar-links"><li><!--[--><a href="/notes/Theory/CompilePrinciple.html" class="nav-link sidebar-link sidebar-page" aria-label="Compiler Principle"><span class="font-icon icon iconfont icon-semantic" style=""></span>Compiler Principle<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/notes/Theory/CompositionPrinciple.html" class="nav-link sidebar-link sidebar-page" aria-label="Composition Principle"><span class="font-icon icon iconfont icon-process" style=""></span>Composition Principle<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/notes/Theory/ComputerNetwork.html" class="nav-link sidebar-link sidebar-page" aria-label="Computer Network"><span class="font-icon icon iconfont icon-network" style=""></span>Computer Network<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/notes/Theory/DataStructure.html" class="nav-link sidebar-link sidebar-page" aria-label="Data Structure &amp; Algorithm"><span class="font-icon icon iconfont icon-emmet" style=""></span>Data Structure &amp; Algorithm<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/notes/Theory/DatabaseSystem.html" class="nav-link sidebar-link sidebar-page" aria-label="Database System"><span class="font-icon icon iconfont icon-storage" style=""></span>Database System<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/notes/Theory/DesignPatterns.html" class="nav-link sidebar-link sidebar-page" aria-label="Design Patterns"><span class="font-icon icon iconfont icon-float" style=""></span>Design Patterns<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/notes/Theory/DistributedSystem.html" class="nav-link sidebar-link sidebar-page" aria-label="Distributed System"><span class="font-icon icon iconfont icon-OS" style=""></span>Distributed System<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-current="page" href="/notes/Theory/OperationSystem.html" class="router-link-active router-link-exact-active nav-link active sidebar-link sidebar-page active" aria-label="Operation System"><span class="font-icon icon iconfont icon-OS" style=""></span>Operation System<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/notes/Theory/OperationSystem.html#_1-操作系统概述" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1 操作系统概述"><!---->1 操作系统概述<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/notes/Theory/OperationSystem.html#_1-1-基本概念与功能" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.1 基本概念与功能"><!---->1.1 基本概念与功能<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/notes/Theory/OperationSystem.html#_1-2-基本特征" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.2 基本特征"><!---->1.2 基本特征<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/notes/Theory/OperationSystem.html#_1-3-发展与分类" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.3 发展与分类"><!---->1.3 发展与分类<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/notes/Theory/OperationSystem.html#_1-4-运行机制和体系结构" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.4 运行机制和体系结构"><!---->1.4 运行机制和体系结构<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/notes/Theory/OperationSystem.html#_1-5-中断和异常" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.5 中断和异常"><!---->1.5 中断和异常<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/notes/Theory/OperationSystem.html#_1-6-系统调用" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.6 系统调用"><!---->1.6 系统调用<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/notes/Theory/OperationSystem.html#_2-进程管理" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="2 进程管理"><!---->2 进程管理<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/notes/Theory/OperationSystem.html#_2-1-进程基础" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="2.1 进程基础"><!---->2.1 进程基础<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/notes/Theory/OperationSystem.html#_2-2-调度" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="2.2 调度"><!---->2.2 调度<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/notes/Theory/OperationSystem.html#_2-3-互斥与同步" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="2.3 互斥与同步"><!---->2.3 互斥与同步<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/notes/Theory/OperationSystem.html#_3-内存管理" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="3 内存管理"><!---->3 内存管理<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/notes/Theory/OperationSystem.html#_3-1-基本概念" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="3.1 基本概念"><!---->3.1 基本概念<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/notes/Theory/OperationSystem.html#_3-2-连续分配" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="3.2 连续分配"><!---->3.2 连续分配<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/notes/Theory/OperationSystem.html#_3-3-分段分页" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="3.3 分段分页"><!---->3.3 分段分页<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/notes/Theory/OperationSystem.html#_3-4-虚拟存储" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="3.4 虚拟存储"><!---->3.4 虚拟存储<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/notes/Theory/OperationSystem.html#_4-文件管理" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="4 文件管理"><!---->4 文件管理<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/notes/Theory/OperationSystem.html#_4-1-基本概念" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="4.1 基本概念"><!---->4.1 基本概念<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/notes/Theory/OperationSystem.html#_4-2-文件的结构" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="4.2 文件的结构"><!---->4.2 文件的结构<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/notes/Theory/OperationSystem.html#_4-3-文件空间管理与操作" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="4.3 文件空间管理与操作"><!---->4.3 文件空间管理与操作<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/notes/Theory/OperationSystem.html#_4-4-磁盘的结构与管理" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="4.4 磁盘的结构与管理"><!---->4.4 磁盘的结构与管理<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/notes/Theory/OperationSystem.html#_5-设备管理" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="5 设备管理"><!---->5 设备管理<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/notes/Theory/OperationSystem.html#_5-1-基本概念" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="5.1 基本概念"><!---->5.1 基本概念<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/notes/Theory/OperationSystem.html#_5-2-i-o控制" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="5.2 I/O控制"><!---->5.2 I/O控制<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/notes/Theory/OperationSystem.html#_5-3-i-o系统" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="5.3 I/O系统"><!---->5.3 I/O系统<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li></ul><!--]--></li><li><!--[--><a href="/notes/Theory/XV6LabSummary.html" class="nav-link sidebar-link sidebar-page" aria-label="XV6 Lab Summary"><span class="font-icon icon iconfont icon-OS" style=""></span>XV6 Lab Summary<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li></ul></section></li></ul><!--[--><!----><!--]--></aside><!--[--><main class="page" id="main-content"><!--[--><!----><nav class="breadcrumb disable"></nav><div class="page-title"><h1><span class="font-icon icon iconfont icon-OS" style=""></span>Operation System</h1><div class="page-info"><span class="page-author-info" aria-label="Author🖊" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon author-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="author icon"><path d="M649.6 633.6c86.4-48 147.2-144 147.2-249.6 0-160-128-288-288-288s-288 128-288 288c0 108.8 57.6 201.6 147.2 249.6-121.6 48-214.4 153.6-240 288-3.2 9.6 0 19.2 6.4 25.6 3.2 9.6 12.8 12.8 22.4 12.8h704c9.6 0 19.2-3.2 25.6-12.8 6.4-6.4 9.6-16 6.4-25.6-25.6-134.4-121.6-240-243.2-288z"></path></svg><span><a class="page-author-item" href="https://sundocker.online" target="_blank" rel="noopener noreferrer">Dominic Sun</a></span><span property="author" content="Dominic Sun"></span></span><!----><span class="page-date-info" aria-label="Writing Date📅" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon calendar-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="calendar icon"><path d="M716.4 110.137c0-18.753-14.72-33.473-33.472-33.473-18.753 0-33.473 14.72-33.473 33.473v33.473h66.993v-33.473zm-334.87 0c0-18.753-14.72-33.473-33.473-33.473s-33.52 14.72-33.52 33.473v33.473h66.993v-33.473zm468.81 33.52H716.4v100.465c0 18.753-14.72 33.473-33.472 33.473a33.145 33.145 0 01-33.473-33.473V143.657H381.53v100.465c0 18.753-14.72 33.473-33.473 33.473a33.145 33.145 0 01-33.473-33.473V143.657H180.6A134.314 134.314 0 0046.66 277.595v535.756A134.314 134.314 0 00180.6 947.289h669.74a134.36 134.36 0 00133.94-133.938V277.595a134.314 134.314 0 00-133.94-133.938zm33.473 267.877H147.126a33.145 33.145 0 01-33.473-33.473c0-18.752 14.72-33.473 33.473-33.473h736.687c18.752 0 33.472 14.72 33.472 33.473a33.145 33.145 0 01-33.472 33.473z"></path></svg><span><!----></span><meta property="datePublished" content="2023-02-19T00:00:00.000Z"></span><!----><span class="page-reading-time-info" aria-label="Reading Time⌛" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon timer-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="timer icon"><path d="M799.387 122.15c4.402-2.978 7.38-7.897 7.38-13.463v-1.165c0-8.933-7.38-16.312-16.312-16.312H256.33c-8.933 0-16.311 7.38-16.311 16.312v1.165c0 5.825 2.977 10.874 7.637 13.592 4.143 194.44 97.22 354.963 220.201 392.763-122.204 37.542-214.893 196.511-220.2 389.397-4.661 5.049-7.638 11.651-7.638 19.03v5.825h566.49v-5.825c0-7.379-2.849-13.981-7.509-18.9-5.049-193.016-97.867-351.985-220.2-389.527 123.24-37.67 216.446-198.453 220.588-392.892zM531.16 450.445v352.632c117.674 1.553 211.787 40.778 211.787 88.676H304.097c0-48.286 95.149-87.382 213.728-88.676V450.445c-93.077-3.107-167.901-81.297-167.901-177.093 0-8.803 6.99-15.793 15.793-15.793 8.803 0 15.794 6.99 15.794 15.793 0 80.261 63.69 145.635 142.01 145.635s142.011-65.374 142.011-145.635c0-8.803 6.99-15.793 15.794-15.793s15.793 6.99 15.793 15.793c0 95.019-73.789 172.82-165.96 177.093z"></path></svg><span>About 107 min</span><meta property="timeRequired" content="PT107M"></span><span class="page-category-info" aria-label="Category🌈" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon category-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="category icon"><path d="M148.41 106.992h282.176c22.263 0 40.31 18.048 40.31 40.31V429.48c0 22.263-18.047 40.31-40.31 40.31H148.41c-22.263 0-40.311-18.047-40.311-40.31V147.302c0-22.263 18.048-40.31 40.311-40.31zM147.556 553.478H429.73c22.263 0 40.311 18.048 40.311 40.31v282.176c0 22.263-18.048 40.312-40.31 40.312H147.555c-22.263 0-40.311-18.049-40.311-40.312V593.79c0-22.263 18.048-40.311 40.31-40.311zM593.927 106.992h282.176c22.263 0 40.31 18.048 40.31 40.31V429.48c0 22.263-18.047 40.31-40.31 40.31H593.927c-22.263 0-40.311-18.047-40.311-40.31V147.302c0-22.263 18.048-40.31 40.31-40.31zM730.22 920.502H623.926c-40.925 0-74.22-33.388-74.22-74.425V623.992c0-41.038 33.387-74.424 74.425-74.424h222.085c41.038 0 74.424 33.226 74.424 74.067v114.233c0 10.244-8.304 18.548-18.547 18.548s-18.548-8.304-18.548-18.548V623.635c0-20.388-16.746-36.974-37.33-36.974H624.13c-20.585 0-37.331 16.747-37.331 37.33v222.086c0 20.585 16.654 37.331 37.126 37.331H730.22c10.243 0 18.547 8.304 18.547 18.547 0 10.244-8.304 18.547-18.547 18.547z"></path></svg><span class="page-category-item category7 clickable" role="navigation">Computer Theory</span><meta property="articleSection" content="Computer Theory"></span><span class="page-tag-info" aria-label="Tag🏷" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon tag-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="tag icon"><path d="M939.902 458.563L910.17 144.567c-1.507-16.272-14.465-29.13-30.737-30.737L565.438 84.098h-.402c-3.215 0-5.726 1.005-7.634 2.913l-470.39 470.39a10.004 10.004 0 000 14.164l365.423 365.424c1.909 1.908 4.42 2.913 7.132 2.913s5.223-1.005 7.132-2.913l470.39-470.39c2.01-2.11 3.014-5.023 2.813-8.036zm-240.067-72.121c-35.458 0-64.286-28.828-64.286-64.286s28.828-64.285 64.286-64.285 64.286 28.828 64.286 64.285-28.829 64.286-64.286 64.286z"></path></svg><span class="page-tag-item tag3 clickable" role="navigation">Computer</span><span class="page-tag-item tag5 clickable" role="navigation">Operation System</span><meta property="keywords" content="Computer,Operation System"></span></div><hr></div><div class="toc-place-holder"><aside id="toc"><div class="toc-header">On This Page<button class="print-button" title="print"><svg xmlns="http://www.w3.org/2000/svg" class="icon print-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="print icon"><path d="M819.2 364.8h-44.8V128c0-17.067-14.933-32-32-32H281.6c-17.067 0-32 14.933-32 32v236.8h-44.8C145.067 364.8 96 413.867 96 473.6v192c0 59.733 49.067 108.8 108.8 108.8h44.8V896c0 17.067 14.933 32 32 32h460.8c17.067 0 32-14.933 32-32V774.4h44.8c59.733 0 108.8-49.067 108.8-108.8v-192c0-59.733-49.067-108.8-108.8-108.8zM313.6 160h396.8v204.8H313.6V160zm396.8 704H313.6V620.8h396.8V864zM864 665.6c0 25.6-19.2 44.8-44.8 44.8h-44.8V588.8c0-17.067-14.933-32-32-32H281.6c-17.067 0-32 14.933-32 32v121.6h-44.8c-25.6 0-44.8-19.2-44.8-44.8v-192c0-25.6 19.2-44.8 44.8-44.8h614.4c25.6 0 44.8 19.2 44.8 44.8v192z"></path></svg></button></div><div class="toc-wrapper"><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/notes/Theory/OperationSystem.html#_1-操作系统概述" class="router-link-active router-link-exact-active toc-link level2">1 操作系统概述</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/notes/Theory/OperationSystem.html#_1-1-基本概念与功能" class="router-link-active router-link-exact-active toc-link level3">1.1 基本概念与功能</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/notes/Theory/OperationSystem.html#_1-2-基本特征" class="router-link-active router-link-exact-active toc-link level3">1.2 基本特征</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/notes/Theory/OperationSystem.html#_1-3-发展与分类" class="router-link-active router-link-exact-active toc-link level3">1.3 发展与分类</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/notes/Theory/OperationSystem.html#_1-4-运行机制和体系结构" class="router-link-active router-link-exact-active toc-link level3">1.4 运行机制和体系结构</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/notes/Theory/OperationSystem.html#_1-5-中断和异常" class="router-link-active router-link-exact-active toc-link level3">1.5 中断和异常</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/notes/Theory/OperationSystem.html#_1-6-系统调用" class="router-link-active router-link-exact-active toc-link level3">1.6 系统调用</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/notes/Theory/OperationSystem.html#_2-进程管理" class="router-link-active router-link-exact-active toc-link level2">2 进程管理</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/notes/Theory/OperationSystem.html#_2-1-进程基础" class="router-link-active router-link-exact-active toc-link level3">2.1 进程基础</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/notes/Theory/OperationSystem.html#_2-2-调度" class="router-link-active router-link-exact-active toc-link level3">2.2 调度</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/notes/Theory/OperationSystem.html#_2-3-互斥与同步" class="router-link-active router-link-exact-active toc-link level3">2.3 互斥与同步</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/notes/Theory/OperationSystem.html#_3-内存管理" class="router-link-active router-link-exact-active toc-link level2">3 内存管理</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/notes/Theory/OperationSystem.html#_3-1-基本概念" class="router-link-active router-link-exact-active toc-link level3">3.1 基本概念</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/notes/Theory/OperationSystem.html#_3-2-连续分配" class="router-link-active router-link-exact-active toc-link level3">3.2 连续分配</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/notes/Theory/OperationSystem.html#_3-3-分段分页" class="router-link-active router-link-exact-active toc-link level3">3.3 分段分页</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/notes/Theory/OperationSystem.html#_3-4-虚拟存储" class="router-link-active router-link-exact-active toc-link level3">3.4 虚拟存储</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/notes/Theory/OperationSystem.html#_4-文件管理" class="router-link-active router-link-exact-active toc-link level2">4 文件管理</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/notes/Theory/OperationSystem.html#_4-1-基本概念" class="router-link-active router-link-exact-active toc-link level3">4.1 基本概念</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/notes/Theory/OperationSystem.html#_4-2-文件的结构" class="router-link-active router-link-exact-active toc-link level3">4.2 文件的结构</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/notes/Theory/OperationSystem.html#_4-3-文件空间管理与操作" class="router-link-active router-link-exact-active toc-link level3">4.3 文件空间管理与操作</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/notes/Theory/OperationSystem.html#_4-4-磁盘的结构与管理" class="router-link-active router-link-exact-active toc-link level3">4.4 磁盘的结构与管理</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/notes/Theory/OperationSystem.html#_5-设备管理" class="router-link-active router-link-exact-active toc-link level2">5 设备管理</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/notes/Theory/OperationSystem.html#_5-1-基本概念" class="router-link-active router-link-exact-active toc-link level3">5.1 基本概念</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/notes/Theory/OperationSystem.html#_5-2-i-o控制" class="router-link-active router-link-exact-active toc-link level3">5.2 I/O控制</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/notes/Theory/OperationSystem.html#_5-3-i-o系统" class="router-link-active router-link-exact-active toc-link level3">5.3 I/O系统</a></li><!----><!--]--></ul><!--]--></ul></div></aside></div><!----><div class="theme-hope-content"><h1 id="operation-system" tabindex="-1"><a class="header-anchor" href="#operation-system" aria-hidden="true">#</a> Operation System</h1><h2 id="_1-操作系统概述" tabindex="-1"><a class="header-anchor" href="#_1-操作系统概述" aria-hidden="true">#</a> 1 操作系统概述</h2><h3 id="_1-1-基本概念与功能" tabindex="-1"><a class="header-anchor" href="#_1-1-基本概念与功能" aria-hidden="true">#</a> 1.1 基本概念与功能</h3><ul><li><p><u>概念</u>：操作系统（Operating System，OS）是指</p><ul><li>控制和<strong>管理</strong>整个计算机系统的<strong>硬件和软件资源</strong>，并合理地<strong>组织调度计算机的工作</strong>和资源的分配，</li><li>以提供给用户和其他软件方便的<strong>接口调用和环境</strong>的系统软件，</li><li>它是计算机系统中<strong>最基本的系统软件</strong>。</li></ul><blockquote><p>简单来说，</p><ul><li>从程序的角度来讲，操作系统就是 <strong>对象+API（系统调用）</strong>；</li><li>从硬件的角度来讲，操作系统就是一个 <strong>C程序代码</strong></li></ul></blockquote></li><li><p><u>功能与目标</u></p><ul><li><p><strong>系统资源</strong>的管理者：安全高效</p><ul><li>进程管理</li><li>内存管理</li><li>文件管理</li><li>设备管理</li></ul></li><li><p>用户和计算机硬件之间的<strong>接口</strong>：方便使用</p><ul><li><p><strong>命令接口</strong>：允许用户<strong>直接使用</strong></p><ul><li><p><strong>联机</strong>命令接口/<strong>交互式</strong>命令接口</p><blockquote><p>比如 dos 窗口</p></blockquote></li><li><p><strong>脱机</strong>命令接口/<strong>批处理</strong>命令接口</p><blockquote><p>比如 .bat 文件</p></blockquote></li></ul></li><li><p><strong>程序接口</strong>：由一组<strong>系统调用</strong>组成，允许用户通过编程<strong>间接使用</strong></p><blockquote><p>比如 .dll 文件；</p><p>系统调用命令也称为<strong>广义指令</strong></p></blockquote></li><li><p>GUI：图形用户接口</p></li></ul></li><li><p>最<strong>接近硬件</strong>的层次</p></li></ul></li></ul><h3 id="_1-2-基本特征" tabindex="-1"><a class="header-anchor" href="#_1-2-基本特征" aria-hidden="true">#</a> 1.2 基本特征</h3><ul><li><p>两个最基本特征：<mark>并发</mark>和共享</p><ul><li><p><strong><u>并发</u></strong>：操作系统会<strong>协调多个程序交替执行</strong></p><blockquote><p>操作系统就是伴随着“多道程序技术”而出现的</p></blockquote></li><li><p><strong><u>共享</u></strong>：系统<strong>资源</strong>可供多个<strong>并发进程<u>互斥</u>地或<u>同时</u>地使用</strong></p><ul><li>互斥共享方式</li><li>同时共享方式</li></ul></li><li><p>并发和共享是操作系统<strong>最基本的两个特征</strong>，互为存在条件</p></li></ul></li><li><p>异步性：由于<strong>资源有限</strong>，<strong>多进程</strong>并发地<strong>以不可预知的速度推进</strong></p></li><li><p>虚拟：操作系统将<u>内存、处理器</u>等<strong>物理实体扩展映射为若干个逻辑对应物</strong></p></li></ul><h3 id="_1-3-发展与分类" tabindex="-1"><a class="header-anchor" href="#_1-3-发展与分类" aria-hidden="true">#</a> 1.3 发展与分类</h3><ol><li><p><u>手工操作阶段</u>时，<strong>人机速度矛盾</strong>突出，<strong>资源利用率</strong>低</p></li><li><p><u>批处理阶段</u></p><ol><li><p><u>单道批处理阶段</u>中，引入了<strong>脱机输入/输出</strong>技术，并有<strong>监督程序</strong>负责控制作业的输入、输出。但内存中仅有一道程序运行，且 CPU 大量时间在等待 I/O</p><blockquote><p>监督程序也是操作系统的原型</p></blockquote></li><li><p><u><mark>多道批处理阶段</mark></u>中，<strong>操作系统</strong>诞生，其中引入了<mark>中断</mark>技术，多个程序<mark>并发</mark>执行，资源利用率提高，但不能<strong>人机交互</strong></p><blockquote><p><strong>中断</strong>是<strong>操作系统</strong>必须提供的功能；<strong>时钟中断</strong>为多道程序设计模型的理论基础</p></blockquote></li></ol><blockquote><p>批处理系统的主要缺点就是<strong>交互性</strong>差</p></blockquote></li><li><p><u>分时操作系统</u>以<strong>时间片</strong>为单位轮流运行多个程序，解决了<strong>人机交互</strong>问题，允许<strong>多个用户同时使用</strong>一台计算机，但不能优先响应<strong>紧急</strong>任务</p><blockquote><p>通用操作系统使用时间片轮转调度算法</p></blockquote></li><li><p><u>实时操作系统</u>能<strong>优先响应紧急任务</strong>，具有及时性和可靠性</p><ul><li>硬实时系统：必须在绝对严格的规定时间内完成处理</li><li>软实时系统：能接受偶尔违反时间规定</li></ul></li><li><p>网络操作系统</p></li><li><p>分页式操作系统</p></li><li><p>个人计算机操作系统</p></li></ol><h3 id="_1-4-运行机制和体系结构" tabindex="-1"><a class="header-anchor" href="#_1-4-运行机制和体系结构" aria-hidden="true">#</a> 1.4 运行机制和体系结构</h3><ul><li><p><u>运行机制/两种处理器状态</u>：</p><ul><li><p>核心态（管态）</p><ul><li><p>可执行<strong>特权指令、非特权指令</strong></p><blockquote><p>特权指令只允许<strong>操作系统/内核</strong>使用，</p><p>如内存清零指令、置时钟指令、关中断指令</p></blockquote></li><li><p>运行<strong>内核程序</strong></p><blockquote><p>如普通的运算指令</p></blockquote></li></ul></li><li><p>用户态（目态）</p><ul><li>只能<strong>非特权指令</strong></li><li>运行<strong>用户程序</strong></li></ul></li><li><p>用户态与核心态切换：修改<strong>程序状态字 PSW</strong></p><ul><li><p>用户态下需要运行<strong>中断指令/访管指令/ trap 指令</strong>才能修改 PSW</p><blockquote><p><strong>中断</strong>是用户态进入内核态的唯一途径，<strong>中断指令</strong>是唯一运行在用户态但不会运行在内核态下的指令。</p></blockquote></li><li><p>核心态下可以<strong>直接修改PSW</strong>，运行<strong>中断返回用户程序</strong>即可转换回用户态</p></li></ul></li><li><p>区分执行态的目的：保护系统程序</p></li></ul></li><li><p><u>体系结构</u>：操作系统<strong>内核/内核程序</strong>可包含的功能</p><ul><li><p><strong>时钟</strong>管理</p></li><li><p><strong>中断</strong>处理</p></li><li><p><strong>原语</strong>（设备驱动、CPU切换）</p></li><li><p><strong>资源</strong>管理：进程管理、内存管理、文件管理、设备管理</p><blockquote><p>根据是否包含<strong>资源管理</strong>相关功能，可分类为<strong>宏内核、微内核</strong></p><ul><li>宏内核：高性能，但结构复杂难以维护、可能不稳定</li><li>微内核：结构清晰方便维护、稳定，但性能低</li></ul></blockquote></li></ul></li></ul><h3 id="_1-5-中断和异常" tabindex="-1"><a class="header-anchor" href="#_1-5-中断和异常" aria-hidden="true">#</a> 1.5 中断和异常</h3><ul><li><p><u>中断的概念/本质</u></p><ul><li><p>发生中断就意味着<strong>需要操作系统介入</strong>，进入<strong>核心态</strong>，开展管理工作。</p><ul><li>中断是使CPU从用户态进入核心态的唯一方式。</li></ul></li><li><p>本质是修改<strong>PSW</strong>，核心态下可以直接修改，用户态下只能通过中断修改。</p></li></ul></li><li><p><u>中断的分类</u></p><ul><li><p><em>内中断/软件中断/异常</em>（同步的）</p><ul><li><p><strong>陷入</strong>（trap），处理后<strong>继续执行</strong>下一条指令</p><blockquote><p>有意的中断，例如：系统调用</p></blockquote></li><li><p><strong>故障</strong>（fault），处理后<strong>重新执行</strong>当前指令或终止</p><blockquote><p>例如：缺页</p></blockquote></li><li><p><strong>终止</strong>（abort）</p><blockquote><p>例如：除0</p></blockquote></li></ul></li><li><p><em>外中断/硬件中断</em>：<strong>狭义的中断</strong>（异步的）</p><ul><li><p>时钟中断</p><blockquote><p>例如：进程上下文切换的调度</p></blockquote></li><li><p>外设请求</p><blockquote><p>例如：I/O 操作完成</p></blockquote></li><li><p>人工干预</p><blockquote><p>例如：用户强行终止一个进程</p></blockquote></li></ul></li></ul></li><li><p><u>中断的处理</u>：中断由<strong>中断隐指令</strong>与核心态下的<strong>中断处理程序</strong>处理</p><ul><li><p>检测：<strong>内中断</strong>由 CPU 检测，不能被屏蔽，一旦出现立即处理</p><blockquote><p>因为是来自程序自己的中断，需要自己处理</p></blockquote></li><li><p><em>中断隐指令</em>：<strong>硬件</strong>自动完成的、不存在于<strong>指令系统</strong>中的、处理中断的指令</p><ol><li><p>关中断</p></li><li><p>设置 PSW 从用户态到核心态</p></li><li><p>保存断点（PC）</p></li><li><p>引出中断服务程序（将中断向量送入 PC）</p><blockquote><p>也可以理解成是跳转到中断处理器，例如<code>trap</code>指令的<code>trap handler</code></p></blockquote></li></ol><blockquote><p>中断由硬件保护并更新 PC ，主要是保证系统运行可靠、正确</p></blockquote></li><li><p>运行环境：</p><ul><li>从用户态到核心态的转换是由<strong>硬件中断机制/中断隐指令</strong>完成的</li><li><strong>进入中断处理</strong>的程序、<strong>中断处理</strong>程序、<strong>中断返回</strong>程序均运行在内核态</li></ul></li></ul></li><li><p><u>Use of interrupts:</u></p><ul><li><strong>Multiprogramming</strong> technology</li></ul></li></ul><h3 id="_1-6-系统调用" tabindex="-1"><a class="header-anchor" href="#_1-6-系统调用" aria-hidden="true">#</a> 1.6 系统调用</h3><ul><li><p><u>系统调用的概念</u></p><ul><li><p>系统调用是<strong>操作系统提供给应用程序调用的特殊函数/接口</strong></p></li><li><p>系统调用命令也叫<strong>广义指令</strong>，在<strong>用户态下调用</strong>，在<strong>内核态下执行</strong></p><blockquote><p>注意区分：</p><ul><li>系统调用命令/广义指令</li><li>中断指令/访管指令/trap指令</li></ul></blockquote></li></ul></li><li><p><u>系统调用的功能 / 类型</u>：用来获得<strong>操作系统的服务</strong>，在一情况下保证系统的<strong>稳定性和安全性</strong></p><ul><li>进程管理 <ul><li>进程控制</li><li>进程通信</li></ul></li><li>内存管理</li><li>文件管理</li><li>设备管理</li><li>信息维护、通信</li></ul></li><li><p><u>系统调用与中断</u>：</p><ul><li>系统调用命令编译后会形成参数和<strong>陷入指令</strong>，引发陷入类型的<strong>内中断</strong>，从而使CPU从用户态进入<strong>核心态</strong>，执行系统调用相应服务程序。</li><li><strong>陷入指令是在用户态执行的</strong>，该指令会引发<strong>内中断</strong>，然后由<strong>硬件</strong>跳转至<strong>陷阱处理器</strong>（trap handler），切换至<strong>内核模式</strong>，处理陷阱（handle trap），执行系统调用</li></ul></li><li><p><u>库函数</u></p><ul><li><p>库函数是语言或应用程序的一部分，可以运行在<strong>用户空间</strong>中</p></li><li><p>库函数可以<strong>封装系统调用</strong>，也可以不封装</p><blockquote><p>未封装系统调用的库函数执行效率通常更高；</p><p>应用程序可以直接使用系统调用，也可以使用封装了系统调用的库函数</p></blockquote></li></ul></li></ul><h2 id="_2-进程管理" tabindex="-1"><a class="header-anchor" href="#_2-进程管理" aria-hidden="true">#</a> 2 进程管理</h2><h3 id="_2-1-进程基础" tabindex="-1"><a class="header-anchor" href="#_2-1-进程基础" aria-hidden="true">#</a> 2.1 进程基础</h3><div class="hint-container info"><p class="hint-container-title">进程基础</p><ul><li><a href="#%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%BB%93%E6%9E%84">概念与结构</a></li><li><a href="#%E7%8A%B6%E6%80%81%E8%B0%83%E5%BA%A6">状态</a></li><li><a href="#%E9%80%9A%E4%BF%A1">通信</a></li><li><a href="#%E7%BA%BF%E7%A8%8B">线程</a></li></ul></div><hr><h4 id="概念与结构" tabindex="-1"><a class="header-anchor" href="#概念与结构" aria-hidden="true">#</a> <em>概念与结构：</em></h4><ul><li><p><u>进程的<strong>概念</strong></u></p><ul><li><p>进程是<strong>程序的一次执行过程</strong>，是系统进行<strong>资源分配</strong>（和调度）的<strong>基本单位</strong></p><blockquote><p>程序：指令序列。</p><p>程序是“静态”的概念，进程是“动态”的概念。</p><p>在多道程序并发中引入进程，更好地表述<strong>程序动态轮换执行</strong>的过程。</p></blockquote></li></ul></li><li><p><u><strong>进程实体/进程映像</strong>的<strong>组成</strong></u></p><ul><li>程序段</li><li>数据段</li><li><strong>PCB</strong><ul><li>进程<strong>描述/标志</strong>信息：进程标识符（<strong>PID</strong>）、用户标识符（<strong>UID</strong>）</li><li>进程<strong>控制和管理</strong>信息：；进程当前<strong>状态</strong>、进程当前<strong>优先级</strong></li><li><strong>资源分配</strong>清单：程序段和数据段的<strong>指针</strong>、系统内核栈、页表、打开文件表、键盘鼠标</li><li><strong>处理机</strong>相关信息：各种<strong>寄存器</strong>值、CPU状态</li></ul></li></ul><blockquote><p>C 语言程序的主要组成 / 进程虚拟地址空间的主要内容：</p><ul><li><p>内核区</p><ul><li>PCB</li></ul></li><li><p>用户区</p><ul><li><p>正文段：ELF 段，Linux 下<strong>可执行</strong>文件格式</p><ul><li>.text：代码段</li><li>.rodata：常量</li><li>.data：已初始化的全局变量</li><li>.bss段：未初始化的全局变量</li></ul></li><li><p>数据堆段：<strong>动态分配</strong>空间</p></li><li><p>数据栈段：<strong>函数调用</strong>相关的临时变量</p><blockquote><p>包括未赋值局部变量、实参传递等</p></blockquote></li></ul></li></ul></blockquote></li><li><p><u>进程的<strong>组织方式</strong></u></p><ul><li><strong>链接</strong>方式：按照进程<strong>状态</strong>将PCB组织为多个<strong>队列</strong></li><li><strong>索引</strong>方式：按照进程<strong>状态</strong>将进程组织为多张<strong>索引表</strong></li></ul></li><li><p><u>进程的特征</u></p><ul><li><p><strong>动态性</strong>（最基本）：程序的运行过程</p></li><li><p><strong>独立性</strong>：资源分配（和接受调度）的基本单位，提供了 <strong>私有地址空间(Private address space)</strong> 这种抽象</p><ul><li><strong>虚拟内存</strong>机制（进程上下文）</li></ul><blockquote><p>进程有自己独立的地址空间，有PCB；</p><p>并发进程可能因共享变量而失去独立性</p></blockquote></li><li><p><strong>并发性</strong>：提供了 <strong>逻辑控制流(Logical control flow)</strong> 这种抽象</p><ul><li><strong>上下文切换</strong>机制（调度）</li></ul></li><li><p>异步性</p></li><li><p>结构性：进程 = 程序 + 数据 + PCB</p></li><li><p>封闭性：进程的执行速度不影响执行结果</p><blockquote><p>在<strong>并发进程共享</strong>时，可能失去封闭性</p></blockquote></li></ul></li></ul><hr><h4 id="状态" tabindex="-1"><a class="header-anchor" href="#状态" aria-hidden="true">#</a> <em>状态：</em></h4><ul><li><p><u>状态划分</u>：为了<strong>方便对各个进程的管理</strong>，操作系统将进程合理地划分为几种<strong>状态</strong></p><ul><li><p>三种基本状态</p><ul><li><p>运行态：占有CPU并<strong>在CPU上运行</strong></p><blockquote><p>单处理系统并非任何时刻都有进程在运行，因为可能出现<strong>死锁</strong></p></blockquote></li><li><p>就绪态：<strong>具备运行条件</strong>，等待运行，但不占有CPU，从而不能运行</p></li><li><p>阻塞态：因等待某一事件而暂时不能运行，不占有 CPU，被唤醒后回到就绪态</p><blockquote><p>可能引起阻塞的事件：系统调用、I/O</p></blockquote><blockquote><p>可能所有进程都处于<strong>阻塞态</strong>（例如死锁），但不可能所有进程都处于<strong>就绪态</strong></p></blockquote></li></ul></li><li><p>两种始末状态</p><ul><li>创建态：正在被<strong>创建</strong>并<strong>分配资源</strong></li><li>终止态：正在从系统中<strong>撤销</strong>并<strong>回归资源</strong></li></ul></li><li><p>两种内存<strong>调度</strong>的挂起状态</p><ul><li>就绪挂起</li><li>阻塞挂起</li></ul></li></ul></li><li><p><u>进程控制</u>：进程的状态转换称为<strong>进程控制</strong>，进程控制用<strong>原语</strong>实现</p><blockquote><p>原语的本质是<strong>关中断</strong>、执行某些操作、<strong>开中断</strong></p></blockquote><ul><li>创建：分配<strong>资源</strong>，申请并初始化<strong>PCB</strong>（设置为<strong>就绪态</strong>）并将其加入<strong>就绪队列</strong></li><li>撤销：找到对应<strong>PCB</strong>，剥夺<strong>CPU</strong>，<strong>终止进程</strong>（和子进程），归还<strong>资源</strong>，<strong>删除PCB</strong></li><li>阻塞：找到对应<strong>PCB</strong>，<strong>保持运行现场</strong>，<strong>暂停</strong>进程运行，将PCB设置为“<strong>阻塞态</strong>”并插入相应<strong>阻塞队列</strong></li><li>唤醒：在<strong>阻塞队列</strong>中找到对应<strong>PCB</strong>，将PCB从中移除并设置为“<strong>就绪态</strong>”、加入<strong>就绪队列</strong></li><li>切换：将当前进程<strong>运行环境</strong>信息存入PCB，移入相应队列，选择另一个进程，更新其PCB并恢复其运行环境</li></ul></li></ul><hr><h4 id="通信" tabindex="-1"><a class="header-anchor" href="#通信" aria-hidden="true">#</a> <em>通信：</em></h4><ul><li><p>进程通信的概念</p><ul><li>进程通信就是指<strong>进程之间的信息交换</strong></li><li>进程是分配系统资源的单位（包括内存地址空间），因此各进程拥有的<strong>内存地址空间相互独立</strong>，但进程之间也需要<strong>通信</strong>。</li></ul></li><li><p>进程通信的方法：</p><ul><li><p><u>共享存储</u>：在内存中划分出一块<strong>共享存储区</strong>，由两个进程<strong>互斥访问</strong></p><ul><li>基于数据结构的共享：数据结构固定，速度慢，限制多，是低级通信</li><li>基于存储区的共享：数据结构灵活，速度快，是高级通信</li></ul></li><li><p><u>消息传递</u>：进程间以“<strong>消息(Message)</strong>”这种数据结构为单位，通过操作系统提供的**“发送消息、接收消息”两个原语**进行数据交换</p><ul><li>直接通信：消息直接挂到接收进程的<strong>消息缓冲队列</strong>上</li><li>间接通信：消息要先发送到**中间实体（信箱）**中，因此也称”信箱通信方式“</li></ul></li><li><p><u>管道通信</u>：开辟<strong>内存缓冲</strong>区进行<strong>半双工通信</strong>，互斥访问，</p><ul><li>数据一旦读出，直接从管道中消失</li><li>管道满时写阻塞，管道空时读阻塞</li></ul><blockquote><p>可分为父子进程间通信的<strong>普通管道 <code>pipe</code></strong> 和 任意进程间通信的<strong>命名管道 <code>mkfifo</code></strong></p></blockquote></li><li><p><u>共享文件</u>：利用操作系统提供的文件共享功能实现进程通信</p></li></ul></li></ul><hr><h4 id="线程" tabindex="-1"><a class="header-anchor" href="#线程" aria-hidden="true">#</a> <em>线程：</em></h4><ul><li><p><u>线程的概念与特点</u></p><ul><li><p>线程是一个<strong>基本的CPU执行单元</strong>，是<mark>CPU调度</mark><strong>的基本单位</strong></p><blockquote><p>进程不再是<strong>CPU调度的基本单位</strong>了，但依然是<strong>操作系统资源分配的基本单位</strong></p></blockquote><blockquote><p>Linux 系统的线程就是 LWP(light weight process)，与 Windows 对线程的实现有较大差别</p></blockquote></li><li><p>线程<strong>提升了系统的并发度</strong>，并发所带来的<strong>系统开销减少</strong>，<strong>数据通信和共享</strong>方便</p><blockquote><p>因为线程是得到CPU时间片的基本单位，一个进程有更多的线程，得到CPU时间片的概率就会变大</p></blockquote></li></ul></li><li><p><u>线程与进程的联系：</u>多线程进程</p><ul><li>进程不再是<strong>CPU调度的基本单位</strong>了，但依然是<strong>操作系统资源分配的基本单位</strong></li><li>同一个进程的多线程共享地址空间中的许多资源（页表、打开文件表、...），遵循“<strong>写时复制</strong>”原则。但线程可以有独立的正文段、数据堆段、数据栈段</li><li>每个进程都是作为一个单一线程启动的，也被称为<strong>主线程</strong>。在之后的某个时间点，主线程创建了<strong>对等线程</strong>，然后两个线程并发的执行</li></ul></li><li><p><u>线程的属性</u></p><ul><li><p>地位：<strong>CPU调度的基本单位</strong>，有自己的ID、<strong>线程控制块</strong>（TCB）</p><blockquote><p>注意，线程和进程都有<strong>控制块</strong>，线程也有自己的<strong>栈</strong>，但线程<strong>没有独立地址空间</strong>；线程包含CPU现场，可以独立执行程序</p></blockquote></li><li><p>状态：三种基本状态和两种始末状态</p></li><li><p>共享：同一进程的多个线程<strong>共享进程资源（包括地址空间）</strong></p><blockquote><p>TCB 中指向内存资源的<strong>三级页表是相同的</strong></p></blockquote></li><li><p>切换：不同进程的线程切换可以引起进程切换，开销较大；同一进程的线程切换开销较小</p></li></ul></li><li><p><u>线程的实现方式</u></p><ul><li><p>用户级线程：由应用程序通过<strong>线程库</strong>实现，由<strong>应用程序负责管理</strong>，在<strong>用户态</strong>下即可切换，<strong>对操作系统透明</strong></p></li><li><p>内核级线程：由<strong>操作系统直接管理</strong>，线程调度、切换需要在<strong>核心态</strong>下完成；只有内核级线程才是<strong>处理机分配的基本单位</strong>。</p><blockquote><p>对于 Linux 操作系统，线程对于<strong>内核</strong>来说其实就是<strong>进程</strong>，只不过是轻量级的，所谓 TCB 其实也是一种 PCB 。内核通过 <strong>LWP 线程号</strong>区分线程。</p></blockquote></li></ul></li><li><p><u>多线程模型</u>：用户线程与内核线程的关系</p><ul><li><p>多对一：多个用户级线程映射到一个内核级线程。</p><ul><li>开销小，<strong>效率高</strong></li><li><strong>并发度低</strong>。多线程不能运行在多处理核上，不能并行</li></ul><blockquote><p>这种情况下一个线程被阻塞，则其所在进程也阻塞</p></blockquote></li><li><p>一对一：一个用户级线程映射到一个内核级线程。</p><ul><li><strong>并发能力强</strong></li><li>成本高，开销大</li></ul></li><li><p>多对多模型：n用户及线程映射到m个内核级线程(n&gt;=m)。平衡了<strong>并发度</strong>与<strong>系统开销</strong></p></li></ul></li></ul><h3 id="_2-2-调度" tabindex="-1"><a class="header-anchor" href="#_2-2-调度" aria-hidden="true">#</a> 2.2 调度</h3><div class="hint-container info"><p class="hint-container-title">调度</p><ul><li><a href="#%E8%BF%9B%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E5%8F%8A%E5%88%87%E6%8D%A2">进程上下文及切换</a></li><li><a href="#%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6%E6%A6%82%E8%BF%B0">处理机调度概述</a></li><li><a href="#%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87">调度算法评价指标</a></li><li><a href="#%E6%B3%A8%E9%87%8D%E5%91%A8%E8%BD%AC%E6%97%B6%E9%97%B4%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95">注重周转时间调度算法</a></li><li><a href="#%E6%B3%A8%E9%87%8D%E5%93%8D%E5%BA%94%E6%97%B6%E9%97%B4%E7%9A%84%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95">注重响应时间的调度算法</a></li></ul></div><h4 id="进程上下文及切换" tabindex="-1"><a class="header-anchor" href="#进程上下文及切换" aria-hidden="true">#</a> <em>进程上下文及切换：</em></h4><ul><li><p><u>进程上下文：</u></p><p>进程物理实体（代码和数据）和支持运行环境的合称</p><ul><li><p>用户级上下文（用户空间）：进程的程序块、数据块、用户堆栈 等</p></li><li><p>系统级上下文（内核空间）：进程标识信息、进程现场信息、进程控制信息（进程表、<strong>页表</strong>、打开文件表等）、系统内核栈 等（<strong>PCB</strong>）</p><ul><li><p>进程现场信息 / 寄存器上下文 / 硬件上下文：处理器中各<strong>寄存器</strong>的内容</p><blockquote><p>在进行进程上下文切换时，操作系统把换下进程的寄存器上下文 保存到系统级上下文中的现场信息位置</p></blockquote></li></ul><blockquote><p>用户级上下文地址空间和系统级上下文地址空间一起构成了一个进程的整个存储器映像，也是<strong>虚拟地址空间</strong></p></blockquote></li></ul></li><li><p><u>进程上下文切换：</u></p><ul><li><p>切换过程：</p><ol><li><p>当前进程的寄存器数据保存至<strong>寄存器上下文</strong></p></li><li><p>换下当前进程<strong>系统级上下文</strong>（PCB），移入至相应队列</p></li><li><p>调度，装入新进程的<strong>系统级上下文</strong>（PCB）</p></li><li><p>更新内存管理的数据结构，切换地址空间</p><blockquote><p>匹配<strong>用户级上下文</strong></p></blockquote></li><li><p>装入新进程<strong>寄存器上下文</strong>，转移至新进程执行</p><blockquote><p>重点在于 PC 的切换</p></blockquote></li></ol></li><li><p>切换开销</p><ul><li>直接开销：内核完成切换所用的 CPU 时间 <ul><li>保存和恢复寄存器</li><li>切换地址空间</li></ul></li><li>间接开销：切换高速缓存、缓冲区、快表等</li></ul></li></ul></li></ul><hr><h4 id="处理机调度概述" tabindex="-1"><a class="header-anchor" href="#处理机调度概述" aria-hidden="true">#</a> <em>处理机调度概述：</em></h4><ul><li><p><u>处理机调度的概念</u>：</p><ul><li>从进程<strong>队列</strong>中按照一定的算法选择一个进程并将<strong>处理机分配</strong>给它运行</li></ul></li><li><p><u>处理机调度的层次</u>：</p><ul><li><p><strong>作业</strong>调度/高级调度（后备队列）：</p><blockquote><p>只调入和调出一次</p></blockquote><ul><li>调入：从外存后备队列中挑选作业分配资源，并建立相应进程（PCB）</li><li>调出：作业运行结束后调出，撤销PCB</li></ul></li><li><p><strong>内存</strong>调度/中级调度（挂起队列）：</p><ul><li>调出：将暂时不能运行的进程调至<strong>外存</strong>，进入挂起状态；PCB仍在内存，记录进程数据位置，加入<strong>挂起队列</strong></li><li>调入：将处于挂起状态并具备运行条件的进程重新调入内存</li></ul></li><li><p><strong>进程</strong>调度/低级调度（就绪队列）：从<strong>就绪队列</strong>中选取<strong>进程</strong>将处理机分配给它，是最基本的调度，频率很高</p></li></ul></li><li><p><u>处理机调度的方式与时机</u>：</p><ul><li>进程（调度）切换主要包括对<strong>原进程数据的保存</strong>和<strong>新进程数据的恢复</strong></li><li>需要考虑调度问题的时机： <ul><li>当前运行的进程<strong>放弃</strong>处理机（非抢占式和抢占式调度） <ul><li>运行完（非抢占式）</li><li>时间片用完（抢占式）</li></ul></li><li><strong>新的进程进入</strong>就绪队列（抢占式调度）</li></ul></li><li>不能调度与切换的时机： <ul><li>处理<strong>中断</strong></li><li><strong>内核程序临界区</strong></li><li><strong>原子操作</strong></li></ul></li></ul></li></ul><hr><h4 id="调度算法评价指标" tabindex="-1"><a class="header-anchor" href="#调度算法评价指标" aria-hidden="true">#</a> <em>调度算法评价指标：</em></h4><ul><li><p><u>CPU利用率</u>：CPU“<strong>忙碌</strong>”的时间占<strong>总时间</strong>的比例</p></li><li><p><u>系统吞吐量</u>：单位时间内完成作业的数量</p></li><li><p><u>周转时间</u>：</p><ul><li>从<strong>作业被提交给系统</strong>开始，到<strong>作业完成</strong>为止的时间间隔</li><li>带权周转时间：<strong>周转时间</strong>除以作业实际<strong>运行时间</strong></li></ul></li><li><p><u>等待时间</u>：进程/作业处于<strong>等待处理机</strong>状态时间之和</p></li><li><p><u>响应时间</u>：从用户提交请求到<strong>首次产生响应</strong>所用的时间</p></li><li><p>公平性：合理设置优先级</p><ul><li><p><strong>系统</strong>进程高于用户进程</p></li><li><p><strong>前台</strong>进程高于后台进程</p></li><li><p><strong>I/O繁忙</strong>型（I/O密集型）进程高于计算型（CPU密集型）进程</p><blockquote><p>I/O 设备和 CPU 可以并行，优先让 I/O 繁忙设备运行，可以让 I/O 设备更早投入工作，提升资源利用率和系统吞吐量</p></blockquote></li><li><p><strong>等待时间长</strong>或<strong>刚运行不久</strong>的进程优先级较高</p><blockquote><p>需要防止抢占式调度将刚运行不久的进程换下</p></blockquote></li><li><p>运行时间长的进程或刚运行完的进程优先级较低</p></li></ul></li></ul><hr><h4 id="注重周转时间调度算法" tabindex="-1"><a class="header-anchor" href="#注重周转时间调度算法" aria-hidden="true">#</a> <em>注重周转时间调度算法：</em></h4><ul><li><p><u>先来先服务（FCFS）</u>：按照作业/进程<strong>到达的先后顺序</strong>进行服务（非抢占）</p><blockquote><p><strong>等待时间</strong>最长的优先得到服务</p></blockquote><ul><li><p>优点：公平、算法实现简单</p></li><li><p>缺点：对长作业/进程后面的短作业/进程不利</p><blockquote><p>FCFS算法<strong>对长作业有利</strong>，对短作业不利</p><blockquote><p>注意，这里的长指的是<strong>CPU计算的时间长</strong>，即<strong>CPU密集型</strong>，而不是指I/O时间很长（即<strong>I/O密集型</strong>），毕竟I/O阻塞的时候是会放弃CPU的，不算 CPU 时间</p></blockquote></blockquote></li></ul></li><li><p><u>短作业/进程优先（SJF/SPF）</u>：<strong>最短</strong>的作业/进程优先得到服务（抢占、非抢占）</p><blockquote><p><strong>（剩余）运行时间</strong>最短的优先得到服务，注意不包括 I/O 时间</p><p>抢占式版本的又称“最短剩余时间优先算法（SRTN）”</p></blockquote><ul><li><p>优点：平均等待时间和平均周转时间较短</p><blockquote><p>在注重响应时间的三个算法中是最短的</p></blockquote></li><li><p>缺点：不公平。对短作业有利，对长作业不利。可能产生饥饿现象。</p></li></ul></li><li><p><u>高响应比优先（HRRN）</u>：<strong>响应比</strong>最高的作业/进程优先得到服务（非抢占）</p><blockquote><p><strong>等待时间</strong>长、<strong>运行时间</strong>短的优先得到服务</p></blockquote><blockquote><p><code>响应比 =等待时间/要求服务时间 + 1</code></p></blockquote><ul><li>优点：综合考虑了等待时间和运行时间，避免短作业长时间等待和长作业饥饿的问题</li></ul></li></ul><hr><h4 id="注重响应时间的调度算法" tabindex="-1"><a class="header-anchor" href="#注重响应时间的调度算法" aria-hidden="true">#</a> <em>注重响应时间的调度算法：</em></h4><blockquote><p>更适应于交互式系统</p></blockquote><ul><li><p><u>时间片轮转调度算法/轮询法（Round-Robin）</u>：按照到达顺序（就绪队列）<strong>轮流</strong>让<strong>各进程</strong>执行一个时间片，未执行完则重新放到队列尾排队（抢占）</p><ul><li><p>优点：公平；<strong>响应快</strong>，适用于<strong>分时操作系统</strong></p></li><li><p>缺点：高频率进程切换，开销较大；无法区分任务<strong>紧急程度</strong></p></li><li><p>时间片大小问题：</p><ul><li>时间片过大：增大进程<strong>响应时间</strong>，可能退化为 FCFS</li><li>时间片过小：进程切换过于频繁，增大开销</li></ul></li></ul></li><li><p><u>优先级调度算法</u>：选择<strong>优先级最高</strong>的作业/进程（抢占、非抢占）</p><ul><li>优点：可区分紧急程度和重要程度，适用于<strong>实时操作系统</strong>。</li><li>缺点：低优先级可能饥饿</li></ul></li><li><p><u>多级多反馈队列调度算法(Multilevel Feedback Queue Scheduling)</u>：（抢占）</p><ul><li>算法规则 <ul><li>设置多级就绪队列，<strong>优先级</strong>从高到低，<strong>时间片</strong>从小到大</li><li>新进程先进入<strong>高优先级</strong>队列，用完时间片进入<strong>次高优先级</strong>队列，若已经是最低优先级则回到队尾</li><li>高优先级队列为空时才会给次高优先级分配时间片</li></ul></li><li>优点： <ul><li>公平（FCFS的优点）</li><li>短进程周转时间小（SPF的优点）</li><li>响应快（RR的优点）</li><li>可设置优先级</li></ul></li><li>缺点：会导致饥饿</li></ul></li></ul><blockquote><p>注重 CPU 分配比例（公平）的算法：</p><ul><li>彩票算法： <ul><li>进程设定： <ul><li><strong>彩票数</strong>表示了任务应该接受到的资源份额（CPU时间）</li><li><strong>彩票数百分比</strong>表示了其所占有的系统资源份额（CPU时间</li></ul></li><li>调度规则： <ul><li>调度器随机选择彩票中奖号码</li><li>加载中奖进程并运行它</li></ul></li><li>评价： <ul><li>随着运行时间的增加，两者得到的CPU时间比例会越接近期望</li></ul></li></ul></li></ul></blockquote><blockquote><p><strong>进程调度时间计算</strong>类问题通用解法：<strong>广义甘特图</strong></p><ul><li>横轴：时间</li><li>纵轴：各进程</li></ul></blockquote><h3 id="_2-3-互斥与同步" tabindex="-1"><a class="header-anchor" href="#_2-3-互斥与同步" aria-hidden="true">#</a> 2.3 互斥与同步</h3><div class="hint-container info"><p class="hint-container-title">互斥与同步</p><ul><li><a href="#%E4%BA%92%E6%96%A5%E5%90%8C%E6%AD%A5%E7%9A%84%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%AE%9E%E7%8E%B0">互斥同步的概念与实现</a></li><li><a href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%9C%BA%E5%88%B6%E4%B8%8E%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98">信号量机制与经典问题</a></li><li><a href="#%E7%AE%A1%E7%A8%8B">管程</a></li><li><a href="#Deadlock">死锁</a></li></ul></div><h4 id="互斥同步的概念与实现" tabindex="-1"><a class="header-anchor" href="#互斥同步的概念与实现" aria-hidden="true">#</a> <em>互斥同步的概念与实现：</em></h4><ul><li><p><u>概念</u></p><ul><li><p><u>临界资源</u>：一次仅允许有一个进程使用的<strong>共享</strong>资源</p><blockquote><p>例如打印机、共享变量、共享缓冲区、公用队列；</p><p>临界资源与其他<strong>共享资源</strong>的区别在于，同一时间内是否允许<strong>多进程并发访问</strong></p></blockquote></li><li><p><u>临界区(critical section)</u>：并发进程访问<strong>临界资源</strong>的<strong>代码段</strong></p><blockquote><p>多个进程临界区的交集称为<strong>不安全区(unsafe regions)</strong></p></blockquote></li><li><p>线程安全函数：一个函数被称为线程安全的，当且仅当<strong>被多个并发线程反复调用</strong>时，它会一直产生正确的结果</p><ul><li>四类线程不安全的函数及其修正： <ul><li>不保护共享变量的函数</li><li>保持跨越多个调用的状态的函数</li><li>返回指向静态变量的指针的函数</li><li>调用线程不安全函数的函数</li></ul></li><li><u>Reentry code / Pure code</u>: The code allowing <strong>multiple process to access</strong> at the same time, which <strong>can’t be modified</strong> and its result isn’t affected by any interrupt when executing</li></ul></li><li><p><u>同步</u>：亦称<strong>直接制约</strong>关系，是指多个进程需要<strong>协调工作次序</strong>而产生制约关系</p></li><li><p><u>互斥</u>：亦称<strong>间接制约</strong>关系，是指多个进程<strong>对临界资源的访问是互相排斥</strong>的</p></li></ul></li><li><p><u>实现原则</u></p><ul><li>空闲让进</li><li>忙则等待</li><li>有限等待</li><li>让权等待</li></ul></li><li><p><u>软件实现</u></p><ul><li><p><u>单标志法</u>：</p><ul><li>思想：每个进程进入临界区的权限由<strong>其他进程在使用完临界区后</strong>赋予</li><li>缺点：可能违反“<strong>空闲让进</strong>”和“<strong>有限等待</strong>”，原因在于<strong>给其他进程赋予权限</strong>的进程可能长期不使用临界区；违反“让权等待”</li></ul></li><li><p><u>双标志先检查法</u>：</p><ul><li>思想：先<strong>通过标记检查其他进程</strong>是否要进入临界区，如果要则<strong>循环等待</strong>，之后再<strong>标记自己</strong>想进入临界区</li><li>缺点：可能违反“<strong>忙则等待</strong>”，原因在于**“检查”和“上锁”**不是原子操作；违反“让权等待”</li></ul></li><li><p><u>双标志后检查法</u>：</p><ul><li>思想：先<strong>标记自己</strong>想进入临界区，再<strong>通过标记检查其他进程</strong>是否要进入临界区，如果要则<strong>循环等待</strong></li><li>缺点：可能违反“<strong>空闲让进</strong>”和“<strong>有限等待</strong>”，从而导致饥饿，原因在于**“上锁”和“检查”**不是原子操作；违反“让权等待”</li></ul></li><li><p><u>Peterson 算法</u></p><ul><li><p>思想：</p><ol><li><p>标记自己<strong>想进入</strong>临界区</p><blockquote><p>因为接下来要“谦让”，也就是执行权的一部分要由其他进程“谦让”给予，但需其他进程可能长时间不访问临界区，所以要提前给自己”留后手“</p></blockquote></li><li><p>表示“<strong>谦让</strong>”：将<code>turn</code><strong>轮流标记</strong>设置为其他进程</p></li><li><p>通过标记检查，如果有<strong>其他进程想进</strong>且<strong>轮流标记</strong>没有到自己，则等待</p></li><li><p>访问完临界区后标记自己<strong>不想进入</strong>临界区</p></li></ol></li><li><p>优点：符合“空闲让进”、“忙则等待”、“有限等待”</p></li><li><p>缺点：违反“让权等待”</p></li></ul></li></ul></li><li><p><u>硬件实现</u></p><ul><li><u>中断屏蔽</u>： <ul><li>思想：在访问临界区前后<strong>关开中断</strong>，避免<strong>进程切换</strong></li><li>优点：简单高效</li><li>缺点：不适用于多处理机；需要开关中断指令需要运行在<strong>内核态</strong></li></ul></li><li><u>TestAndSet 指令（TS、TSL）</u>： <ul><li>思想：访问临界区前**“上锁”并”检查“之前是否已经有锁**（这个操作由硬件完成，不可中断），若有则循环 TSL 等待；<strong>访问临界区后”解锁“</strong></li><li>优点：实现简单；适用于多处理机（涉及到总线相关知识）</li><li>缺点：违反“让权等待”，循环等待时会占用 CPU 循环执行 TSL 指令</li></ul></li><li><u>Swap 指令（Exchange、XCHG）</u>： <ul><li>思想：将当前锁的状态<code>lock</code>交换到自己手上（<code>old</code>），同时<code>lock</code>状态被设置为**“上锁”**，看<code>old</code>是否无锁，若有则循环 XCHG 等待；<strong>访问临界区后设置<code>lock</code>状态为”解锁“</strong></li><li>优点：实现简单；适用于多处理机</li><li>缺点：违反“让权等待”，循环等待时会占用 CPU 循环执行 XCHG 指令</li></ul></li></ul></li></ul><hr><h4 id="信号量机制与经典问题" tabindex="-1"><a class="header-anchor" href="#信号量机制与经典问题" aria-hidden="true">#</a> <em>信号量机制与经典问题：</em></h4><ul><li><p>信号量基础知识</p><ul><li><p><u>信号量</u>：<strong>表示某种系统资源数量</strong>的变量，用于保证关键代码段不被<strong>并发调用</strong></p><ul><li>等于 0 代表当前无可用资源</li><li>小于 0 代表有进程因申请当前空缺的资源而<strong>让权等待</strong></li></ul></li><li><p><u>原语</u>：<strong>执行时不可被中断</strong>的特殊程序 / 指令序列（由开中断、关中断实现，但这<strong>不是系统调用</strong>）</p><ul><li><p>wait 原语（P 操作）：“申请”资源。即让信号量<strong>减 1</strong> ，若减 1 后<strong>大于等于 0</strong>，则进入临界区，否则<strong>让权等待</strong>，直到被 signal 操作选中<strong>唤醒</strong>再进入临界区</p><blockquote><p>被唤醒后不必让信号量再加 1</p></blockquote></li><li><p>signal 原语（V 操作）：“释放”资源。即让信号量<strong>加 1</strong> ，并唤醒同一信号量上<strong>让权等待</strong>的一个进程</p></li></ul><blockquote><p>记录型信号量的wait原语内部有block原语，signal原语内部有wakeup原语；</p><p>PV 操作是一种低级的<strong>进程通信原语</strong></p></blockquote></li><li><p>用于实现<strong>进程互斥</strong>：设置<strong>互斥信号量</strong>（mutex），初值为 1 ，<strong>同一个进程</strong>在临界前后执行PV操作</p></li><li><p>用于实现<strong>进程同步</strong>：设置<strong>同步信号量</strong>，初值由具体情况确定，分别在<strong>不同的进程</strong>中前V后P</p></li></ul></li><li><p>经典问题及其解决思路</p><ul><li><p><u>生产者与消费者问题</u></p><ul><li>互斥：缓冲区</li><li>同步：缓冲区空时生产者先消费者后；缓冲区满时消费者先生产者后</li></ul></li><li><p><u>多生产者与多消费者问题</u></p><ul><li>互斥：缓冲区</li><li>同步：缓冲区空时先生产某种产品对应消费者才能消费；缓冲区满时先消费才能生产</li></ul></li><li><p><u>吸烟者问题</u></p><ul><li>特点：可以生产<strong>多种产品</strong>的<strong>单生产者-多消费者</strong>、有“<strong>轮流</strong>”的要求</li><li>互斥：桌子（可以不设置）</li><li>同步：桌子空时先放才能拿；桌子满时先拿才能放</li></ul></li><li><p><u>读者-写者问题</u></p><ul><li><p>特点：读写互斥但读之间不互斥</p></li><li><p>写-写互斥：<strong><code>rw</code>同步信号量</strong></p></li><li><p>写-读互斥：<strong><code>rw</code>同步信号量</strong></p></li><li><p>读-读不互斥：第一个来读的加<code>rw</code>锁，最后一个读完的解<code>rw</code>锁；设置<strong>计数器变量</strong>实现这一点，通过<code>mutex</code><strong>互斥信号量</strong>保证读进程对计数器的<strong>判断和更改</strong>是不可中断的</p><blockquote><p>但这样是<strong>约束不对等的加锁</strong>，源源不断的读进程会使<strong>写进程饥饿</strong></p></blockquote></li><li><p>读-写公平：设置**<code>w</code>同步信号量<strong>约束读写进程的</strong><code>P(rw)</code>操作**，对于读进程，是约束包<strong>判断和更改计数器</strong>在内的整个过程</p></li></ul></li><li><p><u>哲学家进餐</u> ♂</p><ul><li>特点：构造出了经典的<strong>循环等待</strong>（死锁）场景</li><li>互斥：同一根筷子</li><li>防止死锁：一对相邻的哲学家有一方能拿起两支筷子 <ul><li>奇数先拿左边，偶数先拿右边</li><li>限制一名哲学家不能行动</li></ul></li></ul></li></ul></li></ul><hr><h4 id="管程" tabindex="-1"><a class="header-anchor" href="#管程" aria-hidden="true">#</a> <em>管程：</em></h4><ul><li><p>管程的<u>概念与组成</u></p><ul><li>管程是一种特殊的<strong>软件模块</strong>，由以下三部分组成： <ul><li><strong>共享数据结构 / 共享变量说明</strong></li><li><strong>对数据结构的操作（函数）</strong></li><li>对共享数据的<strong>初始化</strong>操作</li></ul></li></ul></li><li><p>管程的<u>特点</u></p><ul><li>互斥：管程<strong>每次只允许一个进程</strong>执行对数据结构进行<strong>操作</strong></li><li>特定入口：只能通过<strong>管程内部定义的过程/函数</strong>来操作</li><li>存在形式：管程是被进程调用的语法范围，<strong>无法创建和撤销</strong></li></ul></li><li><p>管程的<u>实现</u></p><ul><li>互斥特性由<strong>编译器</strong>负责实现</li><li>同步特性由<strong>条件变量</strong>和<strong>等待唤醒操作</strong>实现</li></ul></li></ul><hr><h4 id="deadlock" tabindex="-1"><a class="header-anchor" href="#deadlock" aria-hidden="true">#</a> <em>Deadlock</em>：</h4><ul><li><p><u>Concept</u>: A phenomenon where processes wait to <strong>compete for resources</strong> held by other processes each other causing all processes <strong>block</strong> in <strong>concurrent</strong> context</p><ul><li><p>Deadlock: at least two processes, blocking</p></li><li><p>Hunger: maybe only one process, blocking or runnable</p></li><li><p>Infinite loop: maybe only one process</p><blockquote><p>Deadlock and hunger is the problem of <strong>OS(manager)</strong>, but infinite loop is the problem of the one <strong>being managed</strong></p></blockquote></li></ul></li><li><p><u>Generation of deadlock</u>:</p><ul><li><p>Necessary <strong>condition</strong>:</p><ul><li><p><em><strong>Mutual exclusion</strong></em>: compete for exclusively used resources</p></li><li><p><em><strong>No preemption</strong></em>: Resources <strong>held</strong> by a process shouldn’t be deprived by other processed until <strong>finishing</strong> use</p></li><li><p><em><strong>Hold and wait</strong></em>: A process doesn’t release held resources while requesting new resources</p></li><li><p><em><strong>Circular wait</strong></em>: A chain for loop awaiting resources exists</p><blockquote><p>The top three conditions are easily satisfied in many contexts, so the fourth condition is key</p></blockquote></li></ul></li><li><p><strong>Timing</strong>:</p><ul><li>Compete for <strong>system resources</strong>, improper allocation of exclusive resources</li><li>Wrong <strong>sequence</strong> of processes executing</li><li>Misuse of <strong>semaphore</strong></li></ul><blockquote><p>Unreasonable <strong>allocation</strong> of inalienable resources</p></blockquote></li></ul></li><li><p><u>Handling strategies of deadlock</u>: (sorted by system <strong>concurrency</strong> in <strong>descending</strong> order)</p><ul><li><p><em><strong>Ignore</strong></em>: When deadlock occurs, reboot the system</p></li><li><p><em><strong>Detect</strong></em> and <strong>resolve</strong>:</p><ul><li>能检测的<strong>前提</strong>： <ul><li>有某种<strong>数据结构</strong>保存资源的<strong>请求和分配信息</strong></li><li>有一种检测系统是否进入死锁状态的<strong>算法</strong></li></ul></li><li>数据结构：<em>资源分配图</em><ul><li><strong>进程</strong>结点：圆形，对应一个进程</li><li><strong>资源</strong>结点：矩形，对应一类资源，结点中可以记录该类资源<strong>总量</strong></li><li><strong>进程</strong>结点指向<strong>资源</strong>结点的边：进程<strong>还需要</strong>申请的资源（每条边代表一个）</li><li><strong>资源</strong>结点指向<strong>进程</strong>结点的边：已经分配给进程的资源（每条边代表一个）</li></ul></li><li><em>死锁定理</em> / 算法：如果某时刻系统的资源分配图是<strong>不可完全简化</strong>的，那么此时系统死锁（死锁定理） <ul><li><strong>能执行</strong>的进程（已申请到<strong>所有所需资源</strong>）或能<strong>分配现有资源</strong>使之<strong>能执行</strong>的进程先执行，执行完后<strong>归还</strong>系统资源，消除相应的边</li><li>继续寻找能执行的进程，直到不再能找到或消除了所有的边</li><li>如果能消除所有边，就称该资源分配图是可完全简化的</li></ul></li><li>Resolve: <ul><li>资源<strong>剥夺</strong></li><li><strong>撤销</strong>进程</li><li>进程<strong>回退</strong></li></ul></li></ul></li><li><p><em><strong>Avoid</strong></em>: a <strong>dynamic</strong> strategy</p><ul><li><p>银行家算法思想：在进程申请资源时，预判这次分配后会不会进入<strong>不安全状态</strong>，如果会则阻塞进程</p><ul><li><p>不安全状态：找不到安全序列</p><blockquote><p>Deadlock belongs to unsafety status</p></blockquote></li><li><p>安全序列：系统按照这个序列分配资源，则每个进程都能顺利完成</p></li></ul></li><li><p>银行家算法步骤</p><ol><li><p>检查此次申请<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mi>e</mi><mi>q</mi><mi>u</mi><mi>e</mi><mi>s</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">Request</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mord mathnormal">u</span><span class="mord mathnormal">es</span><span class="mord mathnormal">t</span></span></span></span>是否超过之前声明的<strong>最大需求数</strong><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mi>e</mi><mi>e</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">Need</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mord mathnormal">ee</span><span class="mord mathnormal">d</span></span></span></span>，如果超过认为<strong>出错</strong></p><blockquote><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mi>e</mi><mi>e</mi><mi>d</mi><mo>=</mo><mi>M</mi><mi>a</mi><mi>x</mi><mo>−</mo><mi>A</mi><mi>l</mi><mi>l</mi><mi>o</mi><mi>c</mi><mi>a</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">Need=Max-Allocation</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mord mathnormal">ee</span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mord mathnormal">a</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.01968em;">ll</span><span class="mord mathnormal">oc</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal">i</span><span class="mord mathnormal">o</span><span class="mord mathnormal">n</span></span></span></span></p></blockquote></li><li><p>检查系统剩余可用资源<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mi>v</mi><mi>a</mi><mi>i</mi><mi>l</mi><mi>a</mi><mi>b</mi><mi>l</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">Available</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord mathnormal">ai</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">ab</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">e</span></span></span></span>是否能<strong>满足这次请求</strong><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mi>e</mi><mi>q</mi><mi>u</mi><mi>e</mi><mi>s</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">Request</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mord mathnormal">u</span><span class="mord mathnormal">es</span><span class="mord mathnormal">t</span></span></span></span>，不能则<strong>阻塞进程</strong></p></li><li><p><strong>试探分配</strong>，更改数据结构</p></li><li><p>用<strong>安全性算法</strong>检查分配后是否会导致系统进入不安全状态</p></li></ol></li><li><p>安全性算法步骤</p><ul><li>检查当前剩余可用资源<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>W</mi><mi>o</mi><mi>r</mi><mi>k</mi></mrow><annotation encoding="application/x-tex">Work</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="mord mathnormal" style="margin-right:0.02778em;">or</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>是否能满足某个（某些）进程的最大需求，如果可以则将该进程（这些进程）加入<strong>安全序列</strong>，并回收其全部资源</li><li>重复上述过程，直至找到完整的<strong>安全序列</strong>或<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>W</mi><mi>o</mi><mi>r</mi><mi>k</mi></mrow><annotation encoding="application/x-tex">Work</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="mord mathnormal" style="margin-right:0.02778em;">or</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>无法满足现有的任何进程</li></ul></li></ul></li><li><p><em><strong>Prevent</strong></em>: a <strong>static</strong> strategy</p><ul><li><p><em>Prevent <strong>mutex</strong>:</em> Transform mutex into <strong>concurrently shared resource</strong></p><ul><li>Disadvantages: Poor <strong>feasibility</strong>. Mutex can’t be destroyed most of time</li></ul><blockquote><p>For example: <strong>SPOOLing</strong> technology</p></blockquote></li><li><p><em>Prevent no <strong>preemption</strong>:</em></p><ul><li><p>Plan one: <strong>Release</strong> all held resources immediately when requesting for resources can’t be satisfied</p></li><li><p>Plan two: <strong>Deprive</strong> required resources held by other processes with the assistance of OS when requesting for held resources</p><blockquote><p>In this way, <strong>priority</strong> of process will be taken into account</p></blockquote></li><li><p>Disadvantages: complex <strong>implementation</strong>; disabling <strong>original work</strong>; more <strong>cost</strong> to require and release; <strong>hunger</strong></p></li></ul></li><li><p><em>Prevent <strong>hold</strong> and <strong>wait</strong>:</em> Hold all required resources <strong>before running</strong> until over</p><ul><li>Disadvantages: low resource <strong>utilization</strong>; hunger.</li></ul></li><li><p><em>Prevent <strong>circular</strong> wait:</em> Number resources. Each process require resources by ascending order of resource number. (Sequential resource allocation)</p><ul><li>Disadvantages: inconvenient to add <strong>new devices</strong>; different <strong>orders</strong> between resource number and process using resources, causing a <strong>waste</strong> of resources; troublesome for user <strong>programming</strong>, poor <strong>portability</strong> (having to follow resource number order to require resources)</li></ul><blockquote><p>Principle: <strong>Anytime</strong> there is a <strong>secure sequence</strong> beginning from the process holding the <strong>biggest</strong>-numbered resource. (There is no chance for process <strong>holding bigger</strong>-numbered resource to <strong>require smaller</strong>-numbered resource)</p></blockquote></li></ul></li></ul></li></ul><h2 id="_3-内存管理" tabindex="-1"><a class="header-anchor" href="#_3-内存管理" aria-hidden="true">#</a> 3 内存管理</h2><h3 id="_3-1-基本概念" tabindex="-1"><a class="header-anchor" href="#_3-1-基本概念" aria-hidden="true">#</a> 3.1 基本概念</h3><div class="hint-container info"><p class="hint-container-title">基本概念</p><ul><li><a href="#%E5%86%85%E5%AD%98%E5%92%8C%E5%9C%B0%E5%9D%80%E6%A6%82%E8%BF%B0">内存和地址概述</a></li><li><a href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E4%B8%BB%E8%A6%81%E5%86%85%E5%AE%B9">内存管理的主要内容</a></li></ul></div><h4 id="内存和地址概述" tabindex="-1"><a class="header-anchor" href="#内存和地址概述" aria-hidden="true">#</a> <em>内存和地址概述：</em></h4><ul><li><p><u>内存概述</u></p><ul><li><p>概念：内存是用于<strong>存放数据的硬件</strong>。</p></li><li><p>主要应用：程序要放到<strong>内存</strong>中才能被<strong>CPU</strong>直接执行。</p></li><li><p>组织形式：内存通常从0开始顺序编址，每号地址对应一个存储单元</p><ul><li><p>按字节编址：每个存储单元大小为1字节</p></li><li><p>按字编址：每个存储单元大小为1个字</p><blockquote><p>字长由计算机决定</p></blockquote></li></ul></li></ul></li><li><p><u>地址与地址空间概述</u></p><ul><li><p>虚拟地址/ <em>Linear Address</em>：用户编程时使用的地址，一般指<strong>段名+段内相对地址</strong></p></li><li><p>逻辑地址/相对地址：用户编程时使用的地址，一般指<strong>段内相对地址</strong></p></li><li><p>物理地址/绝对地址：实际物理内存的地址</p></li><li><p>逻辑地址空间 / Linear address space：一般指各<strong>程序段</strong>所有<strong>逻辑地址</strong>的集合</p><blockquote><p>实际应用中，虚拟地址与逻辑地址常常不加区分</p></blockquote></li><li><p>物理地址空间：实际可访问/ <em>CPU address bus</em> 的<strong>物理内存地址</strong>集合</p></li></ul></li><li><p><u>编译、链接、装入</u></p><ul><li><p>概念</p><ul><li><p>编译：<u>编译程序</u>将<strong>用户源代码</strong>编译成若干个<strong>目标模块</strong></p><blockquote><p>编译时会形成相对该模块的<strong>逻辑地址</strong></p></blockquote></li><li><p>链接：<u>链接程序</u>将各目标模块、<strong>库函数</strong>链接在一起，形成的<strong>装入模块</strong></p><blockquote><p>装入模块就是一种<strong>可执行模块/文件</strong></p><p>链接器完成重定位，形成整个程序完整的<strong>逻辑地址空间</strong></p></blockquote></li><li><p>装入：<u>装入程序</u>将装入模块装入内存运行</p></li></ul></li><li><p>链接的三种方式</p><ul><li><p>静态链接：在<strong>程序运行前</strong>将各目标模块、库函数链接成<strong>完整的装入模块</strong></p></li><li><p>装入时动态链接：在各目标模块<strong>装入内存时</strong>链接库函数</p></li><li><p>运行时动态链接：程序<strong>运行时需要</strong>目标模块再链接库函数</p><blockquote><p>便于库函数的<strong>修改和更新</strong>，便于目标模块的<strong>共享</strong></p></blockquote></li></ul></li><li><p>装入的三种方式</p><ul><li><p><strong>绝对</strong>装入：直接按照编译时产生的<strong>绝对地址</strong>将程序和数据装入内存</p><blockquote><p>绝对装入只适用于<strong>单道程序环境</strong></p></blockquote></li><li><p><strong>静态</strong>重定位：又称<strong>可重定位</strong>装入，指令和数据使用<strong>逻辑地址</strong>，由<strong>装入程序</strong>在装入时完成逻辑地址到<strong>物理地址</strong>的转换</p><blockquote><p>静态重定位装入时必须分配<strong>全部连续空间</strong>，模块装入内存后，运行期间<strong>无法申请其他内存、无法移动</strong></p></blockquote><blockquote><p>用于早期<strong>多道批处理系统</strong>，只适用于固定分区分配（和单一连续分配）</p></blockquote></li><li><p><strong>动态</strong>重定位：又称<strong>动态运行时</strong>装入，指令和数据使用<strong>逻辑地址</strong>，在程序<strong>运行时</strong>借助<strong>重定位寄存器</strong>完成逻辑地址到<strong>物理地址</strong>的转换</p><blockquote><p>重定位寄存器/基址寄存器：存放装入模块的<strong>起始物理地址</strong></p><p>整个系统中<strong>只有一个</strong>，硬件支持加快<strong>地址转换</strong>速度</p></blockquote><blockquote><p>动态重定位允许<strong>分配不连续内存</strong>，允许动态地<strong>部分装入和申请内存</strong>，允许模块<strong>在内存中移动</strong>，便于<strong>共享和虚拟内存</strong>的实现</p></blockquote></li></ul></li></ul></li></ul><hr><h4 id="内存管理的主要内容" tabindex="-1"><a class="header-anchor" href="#内存管理的主要内容" aria-hidden="true">#</a> <em>内存管理的主要内容：</em></h4><ul><li><p><u>内存的分配与回收</u>：操作系统负责<strong>内存空间的分配与回收</strong></p><ul><li><p>连续分配</p><ul><li>单一连续分配</li><li>固定分区分配</li><li>动态分区分配</li></ul></li><li><p>非连续分配</p><ul><li>基本分页存储管理</li><li>基本分段存储管理</li><li>基本段页式存储管理</li></ul></li></ul></li><li><p><u>内存空间的扩充</u>：操作系统需要提供某种技术从逻辑上<strong>对内存空间进行扩充</strong></p><ul><li>覆盖技术</li><li>交换技术</li><li>虚拟存储技术</li></ul></li><li><p><u>地址转换</u>：操作系统需要提供<strong>地址转换功能</strong>，负责程序的<strong>逻辑地址</strong>与<strong>物理地址</strong>的转换</p></li><li><p><u>存储保护</u>：操作系统需要提供<strong>内存保护</strong>功能，保证各进程在各自存储空间内运行，互不干扰</p><ul><li><p>采用<strong>上下限寄存器</strong>，存放进程的<strong>上下限地址</strong></p></li><li><p>采用<strong>基址寄存器和界地址寄存器</strong>，分别存放<strong>起始物理地址</strong>和<strong>最大逻辑地址</strong></p><blockquote><p>基址寄存器也称<strong>重定位寄存器</strong>，界地址寄存器也称<strong>限长寄存器</strong></p></blockquote></li></ul></li></ul><h3 id="_3-2-连续分配" tabindex="-1"><a class="header-anchor" href="#_3-2-连续分配" aria-hidden="true">#</a> 3.2 连续分配</h3><blockquote><p>连续分配：为用户进程分配的只能是<strong>连续的内存空间</strong></p></blockquote><div class="hint-container info"><p class="hint-container-title">连续分配</p><ul><li><a href="#%E5%8D%95%E4%B8%80%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D">单一连续分配</a></li><li><a href="#%E5%9B%BA%E5%AE%9A%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D">固定分区分配</a></li><li><a href="#%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D">动态分区分配</a></li></ul></div><hr><h4 id="单一连续分配" tabindex="-1"><a class="header-anchor" href="#单一连续分配" aria-hidden="true">#</a> <em>单一连续分配：</em></h4><ul><li><p><u>内存划分</u>：单一连续分配方式中内存被分为<strong>系统区和用户区</strong></p><ul><li>系统区：位于内存的低地址部分，存放<strong>操作系统相关数据</strong></li><li>用户区：存放<strong>用户进程相关数据</strong>，只允许<strong>一道用户程序独占</strong>整个用户空间</li></ul></li><li><p><u>单一连续分配的优点</u>：</p><ul><li>实现简单</li><li>无外部碎片</li><li>可以用覆盖技术扩充内存</li><li>不一定需要内存保护</li></ul></li><li><p><u>单一连续分配的缺点</u>：</p><ul><li><p>只能用于单用户、单任务操作系统</p></li><li><p>有内部碎片</p><blockquote><p>内部碎片：分配给进程的内存空间中没有被利用的部分</p></blockquote></li><li><p>存储器利用率极低</p></li></ul></li></ul><hr><h4 id="固定分区分配" tabindex="-1"><a class="header-anchor" href="#固定分区分配" aria-hidden="true">#</a> <em>固定分区分配：</em></h4><ul><li>将整个用户空间划分为若干个<strong>固定大小的分区</strong>，每个分区中装入一道作业，支持<strong>多道程序</strong>并发</li><li><u>分区<strong>策略</strong></u>： <ul><li>分区大小相等：缺乏灵活性，适合用于一台计算机控制多个相同对象的场合</li><li>分区大小不等：增加了灵活性，可以根据不同大小的进程需求划分空间</li></ul></li><li><u><strong>分区说明表</strong></u>：用于管理分区，记录各分区的分配与回收 <ul><li>字段：分区号、分区大小、起始地址、状态（已分配和未分配）</li></ul></li><li><u>固定分区分配<strong>优缺点</strong></u>： <ul><li>优点：实现简单，无<strong>外部碎片</strong></li><li>缺点： <ul><li>可能无法满足<strong>大进程</strong>需求，不得不采用低性能的<strong>覆盖</strong>技术</li><li>会产生<strong>内部碎片</strong>，内存利用率低</li></ul></li></ul></li></ul><hr><h4 id="动态分区分配" tabindex="-1"><a class="header-anchor" href="#动态分区分配" aria-hidden="true">#</a> <em>动态分区分配：</em></h4><ul><li><p>又称为<strong>可变分区分配</strong>，不预先划分内存分区，而是在进程装入内存时<strong>根据进程大小动态建立分区</strong>，因此系统分区的<strong>大小和数目是可变的</strong>。</p></li><li><p><u>分区分配中的<strong>数据结构</strong></u></p><ul><li>空闲分区表： <ul><li>字段：分区号、分区大小、起始地址、状态（已分配和未分配）</li></ul></li><li>空闲分区链： <ul><li>将每个单独的内存分区视作链表的一个结点</li><li>结点的起始部分：前向指针、分区大小等信息</li><li>结点的末尾部分：后向指针</li></ul></li></ul></li><li><p><u>分配与回收的<strong>具体操作</strong></u></p><ul><li>分配：根据分配算法选择空闲区，再<strong>更新空闲分配表</strong><ul><li>只<strong>占用部分</strong>空闲区：<strong>修改</strong>表项</li><li>刚好<strong>填满</strong>空闲区：<strong>删除</strong>表项</li></ul></li><li>回收：回收进程并<strong>更新空闲分配表</strong><ul><li>有相邻空闲分区： <ul><li>只有前面有或只有后面有：修改表项</li><li>前后均有：合并表项</li></ul></li><li>无相邻空闲分区： <ul><li>新增表项</li></ul></li></ul></li></ul></li><li><p><strong><u>动态分区分配算法</u></strong>：</p><ul><li><p>首次适应算法（First Fit）</p><ul><li>思想：从<strong>低地址向高地址</strong>查找第一个满足大小的空闲分区</li><li>实现：空闲分区表以<strong>地址递增</strong>次序排列，每次分配时顺序查表</li><li>优点：综合性能好；对空闲分区表操作简单，<strong>算法开销小</strong>；可以保留高地址部分大空闲区</li><li>缺点：低地址部分易产生<strong>外部碎片</strong></li></ul></li><li><p>最佳适应算法（Best Fit）</p><ul><li>思想：优先使用<strong>更小的空闲区</strong>分配</li><li>实现：空闲分区表按<strong>容量递增</strong>次序链接，每次分配时顺序查表</li><li>优点：保留更多<strong>大空闲区</strong>，满足大进程需求</li><li>缺点：容易残留更多<strong>外部碎片</strong>；回收分区后要<strong>排序</strong>空闲分区表，<strong>算法开销大</strong></li></ul></li><li><p>最坏适应算法（Worst Fit）</p><ul><li>思想：优先使用<strong>更大的空闲区</strong>分配</li><li>实现：空闲分区表按<strong>容量递减</strong>次序链接，每次分配时顺序查表</li><li>优点：可以减少<strong>外部碎片</strong></li><li>缺点：难以保留<strong>大空闲区</strong>，不利于大进程需求；回收分区后要<strong>排序</strong>空闲分区表，<strong>算法开销大</strong></li></ul></li><li><p>邻近适应算法（Next Fit）</p><ul><li>思想：在<strong>首次适应</strong>算法的基础上，每次从<strong>上次查找结束</strong>位置开始<strong>循环查找</strong></li><li>实现：空闲分区表以<strong>地址递增</strong>次序排列成<strong>循环表</strong>，每次分配时<strong>从上一次位置开始循环查表</strong></li><li>优点：对空闲分区表操作简单，<strong>算法开销小</strong>；减少低地址部分的<strong>外部碎片</strong></li><li>缺点：难以保留<strong>大空闲区</strong>，不利于大进程需求</li></ul></li></ul></li><li><p><u>动态分区分配的<strong>优缺点</strong></u></p><ul><li><p>优点：无<strong>内部碎片</strong>，分配出的内存利用率高</p></li><li><p>缺点：有<strong>外部碎片</strong>，会产生过小的空闲分区而难以分配</p><blockquote><p>可以通过<strong>紧凑（拼凑，Compaction）<strong>技术解决外部碎片，这需要结合</strong>动态重定位装入</strong>移动进程块位置，并修改PCB中的进程起始地址，以及重定位寄存器/基址寄存器</p></blockquote></li></ul></li></ul><h3 id="_3-3-分段分页" tabindex="-1"><a class="header-anchor" href="#_3-3-分段分页" aria-hidden="true">#</a> 3.3 分段分页</h3><blockquote><p>离散分配：为用户进程分配的可以是<strong>分散的内存空间</strong></p></blockquote><div class="hint-container info"><p class="hint-container-title">分段分页</p><ul><li><a href="#%E5%9F%BA%E6%9C%AC%E5%88%86%E9%A1%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86">基本分页存储管理</a></li><li><a href="#%E5%9F%BA%E6%9C%AC%E5%88%86%E6%AE%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86">基本分段存储管理</a></li><li><a href="#%E6%AE%B5%E9%A1%B5%E5%BC%8F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86">段页式存储管理</a></li></ul></div><hr><h4 id="基本分页存储管理" tabindex="-1"><a class="header-anchor" href="#基本分页存储管理" aria-hidden="true">#</a> <em>基本分页存储管理：</em></h4><ul><li><p><u>基本思想</u>：把<strong>内存</strong>划分成相等的<strong>分区</strong>，再按照同样大小将<strong>进程</strong>拆分成<strong>进程块</strong></p><ul><li><p>划分出的内存分区称为<strong>页框</strong>，或页帧、内存块、物理块；</p><p>每个页框都有编号，称为<strong>页框号</strong>，或页帧号、内存块号、物理块号</p></li><li><p>与页框大小相等的进程块称为<strong>页</strong>或页面；</p><p>每个页都有编号，称为<strong>页号</strong></p></li></ul><blockquote><p>进程被拆分的最后一个页面可能小于页框大小，因此页框不能太大，否则会产生过大的<strong>内部碎片</strong>。但这种方式一定不会产生<strong>外部碎片</strong>。</p></blockquote></li><li><p><u>页表与地址结构</u></p><ul><li><p>页表：操作系统为每个进程建立一张页表，记录<strong>进程每个页面在物理内存中的内存块号</strong></p><blockquote><p>页表本身也存储于内存，单级页表<strong>顺序存储</strong>，多级页表可以<strong>离散存储</strong></p></blockquote></li><li><p>页表项：每个页表项<strong>长度相等</strong>，由页号和块号组成</p><ul><li>页号：进程页号，隐含的，相当于逻辑上的数组<strong>索引</strong></li><li>块号：进程页实际存放到的<strong>内存块号</strong>。其位数由<strong>内存块的数量</strong>决定</li></ul><blockquote><p><strong>页表项的大小</strong>尽量能整除页框大小，这样存放页表时可以减少<strong>内部碎片</strong></p></blockquote></li><li><p>逻辑地址结构：</p><ul><li><p><strong>页号P</strong>：逻辑地址所在页的<strong>页号</strong>。<code>页号=逻辑地址/页面长度</code></p><p>利用<strong>页表</strong>，以页号作为<strong>索引</strong>，查寻块号，计算出进程页在内存中的<strong>起始地址</strong></p><p>页号P的位数对应于进程的<strong>最大页面数</strong></p></li><li><p><strong>页内偏移量W</strong>：逻辑地址在页内的<strong>偏移量</strong>。<code>页内偏移量=逻辑地址%页面长度</code></p><p>页内偏移量W的位数对应于<strong>页面大小</strong></p></li></ul><blockquote><p>页式管理中地址是<strong>一维</strong>的，程序员只要给出<strong>一个逻辑地址助记符</strong>就可以自动计算出<strong>物理地址</strong></p></blockquote></li><li><p><strong>多级</strong>页表/页目录表：将页表<strong>拆分并离散存放</strong>至内存，并用页目录表统计</p><blockquote><p>单级页表需要整体<strong>连续存储</strong>至内存，不符合离散分配的思想</p></blockquote><ul><li><p>页目录表的表项：</p><p>页号：某级页号</p><p>块号：“页表块”存放到的内存块号</p><blockquote><p>多级页表的<strong>最高级页表</strong>也不能超出一页大小，否则违背了分级的初衷</p></blockquote></li><li><p>对应的<strong>逻辑地址结构</strong>：</p><p>页号：可被拆分成<strong>多级页号</strong></p><p>页内偏移量：与单级页表相同</p></li><li><p>多级页表的思想在虚拟存储技术中有所应用</p></li></ul></li><li><p><strong>快表</strong>：又称联想寄存器（TLB, Translation Look-aside Buffers），是一种<strong>高速缓存</strong>，用于存放最<strong>近访问过的若干页表项</strong>，以加速地址变换。相对而言，内存中的页表常称为<strong>慢表</strong></p><blockquote><p>单级页表记录了所有页的信息，没有考虑<strong>局部性原理</strong></p></blockquote><blockquote><p>快表具体的结构与算法参见计算机组成原理</p></blockquote></li></ul></li><li><p><u>地址变换机构</u></p><ul><li><p>页表寄存器（PTR）</p><ul><li>存放页表在内存中的<strong>起始地址F和页表长度M</strong></li><li>F和M会存放于PCB中，在进程执行时存入PTR</li></ul></li><li><p>地址变换过程</p><ol><li><p>根据逻辑地址算出<strong>页号P、页内偏移量W</strong></p></li><li><p>根据<strong>页号</strong>得到<strong>块号/进程页起始地址</strong></p><ol start="0"><li><p>（<strong>匹配快表</strong>：若命中快表表项，可直接得到<strong>进程页起始地址</strong>，若未命中则需<strong>访存</strong>）</p></li><li><p><strong>越界检查</strong>：将<strong>页号</strong>与PTR中的<strong>页表长度</strong>对比，检查是否合法</p></li><li><p><strong>索引计算</strong>：根据<strong>页表起始地址、页表项长度、页号</strong>计算出<strong>页表项地址</strong></p><blockquote><p>这也是<strong>数组</strong>索引访问的计算原理</p></blockquote></li><li><p><strong>得到始址</strong>：由页表项得到进程页所在<strong>内存号块</strong>，进而计算出<strong>进程页起始地址</strong></p></li><li><p>（<strong>更新快表</strong>：将页表项存入快表）</p></li></ol></li><li><p>根据<strong>进程页起始地址和页内偏移量</strong>计算出<strong>物理地址</strong></p></li></ol></li><li><p>页表与访存：</p><ul><li><p>在没有命中快表的情况下：n 级页表的访存次数为 n+1 次，前n次是查找页表，最后一次是访问数据</p><blockquote><p>不考虑多级快表</p></blockquote></li><li><p>在命中快表的情况下：只需一次访问内存数据（查询快表访问的是缓存）</p></li></ul></li></ul></li></ul><hr><h4 id="基本分段存储管理" tabindex="-1"><a class="header-anchor" href="#基本分段存储管理" aria-hidden="true">#</a> <em>基本分段存储管理：</em></h4><ul><li><p><u>基本思想</u>：</p><ul><li><p>进程按<strong>逻辑</strong>关系划分为若干个大小可以不相等的<strong>段</strong>，每段都有一个<strong>段名和段号</strong>，从0开始编址</p><blockquote><p>编程更方便，程序可读性更高</p></blockquote></li><li><p>以段为单位分配内存，段内连续，各段之间可以离散</p></li></ul></li><li><p><u>段表与地址结构</u>：</p><ul><li><p>段表：操作系统为每个进程建立一张段映射表，记录各<strong>逻辑段在物理内存中存放位置</strong></p></li><li><p>段表项</p><ul><li>段号：进程逻辑段的段号，隐含的，相当于逻辑上的数组<strong>索引</strong></li><li>段长：逻辑段的长度。位数与<strong>段内地址</strong>位数相同。</li><li>逻辑段基址：逻辑段在物理内存中存放的<strong>起始位置</strong>。位数由物理内存<strong>存储单元个数</strong>决定</li></ul></li><li><p>逻辑地址结构：段号+段内地址</p><ul><li><p>段号：逻辑地址所在段的段号。段号=逻辑地址/最大段长</p><p>段号的位数对应于进程最多可以分几个段</p></li><li><p>段内地址：逻辑地址在段内的偏移量。段内地址=逻辑地址%最大段长</p><p><strong>段内地址</strong>位数决定了最大<strong>段长</strong></p></li></ul><blockquote><p>段式管理中地址是<strong>二维</strong>的，程序员要同时给出<strong>段名和段内地址</strong>才可以计算出<strong>物理地址</strong></p></blockquote></li></ul></li><li><p><u>地址变换机构</u>：</p><ul><li>段表寄存器： <ul><li>存放段表在内存中的<strong>起始地址F和段表长度M</strong></li><li>F和M会存放于PCB中，在进程执行时存入段表寄存器</li></ul></li><li>地址变换过程： <ol><li>根据逻辑地址算出<strong>段号、段内地址</strong></li><li>根据<strong>段号</strong>得到<strong>进程逻辑段起始地址</strong><ol><li><strong>越界检查</strong>：将<strong>段号</strong>与段表寄存器中的<strong>段长度</strong>对比，检查是否合法</li><li><strong>索引计算</strong>：根据段表起始地址、段表项长度、段号计算出<strong>段表项地址</strong></li><li><strong>越界检查</strong>：由段表项得到<strong>段长</strong>，检查<strong>段内地址</strong>是否合法</li><li>得到始址：由段表项<strong>进程逻辑段起始地址</strong></li></ol></li><li>根据<strong>进程逻辑段起始地址和段内地址</strong>计算出<strong>物理地址</strong></li></ol></li><li>段表与访存： <ul><li>一次访存查段表，一次访存目标数据</li><li>也可以引入快表减少访存</li></ul></li></ul></li><li><p><u>分段分页对比</u>：</p><ul><li>从地址空间的角度对比： <ul><li>页是信息的<strong>物理单位</strong>，对用户不可见，分页进程的地址空间是一维的。页长固定，由系统决定。</li><li>段是信息的<strong>逻辑单位</strong>，对用户可见，分段进程的地址空间是二维的。段长不固定，由程序员决定。</li><li>对于不同进程，系统总空间大小不变，但<strong>页表或段表的大小可能变化</strong>，所以进程地址空间可能变化</li></ul></li><li>从目的的角度对比： <ul><li>分页目的是实现<strong>离散分配</strong>，提高内存利用率，是系统管理的需要。没有外部碎片，会产生少量页内碎片。</li><li>分段目的是将进程划分为逻辑段，方便程序员<strong>编程</strong>。会产生外部碎片，且段长过大不方便分配</li></ul></li><li>从共享的角度对比： <ul><li>分段可以拆分逻辑模块，比分页更容易实现<strong>信息的共享和保护</strong>，更有利于<strong>动态链接</strong></li><li>分段可以灵活拆分<strong>可重入代码和不可重入代码</strong>，保证<strong>数据一致性</strong>，实现安全共享。分页则不够灵活。</li></ul></li></ul></li></ul><hr><h4 id="段页式存储管理" tabindex="-1"><a class="header-anchor" href="#段页式存储管理" aria-hidden="true">#</a> <em>段页式存储管理：</em></h4><ul><li><p><u>基本思想</u>：</p><ul><li>先将进程拆分成<strong>逻辑段</strong>，再将各<strong>逻辑段分页</strong>，也就是一段包含若干页。分段对用户可见，分页对用户不可见。</li><li>在<strong>用户进程</strong>这边，保留<strong>段的逻辑划分</strong>；在<strong>系统内存</strong>这边，保留<strong>页的管理方式</strong>。</li></ul></li><li><p><u>段表、页表与地址结构</u>：</p><ul><li><p>逻辑地址结构：</p><ul><li><p>段号：逻辑地址所在段的段号。<code>段号=逻辑地址/最大段长</code></p><p>段号的位数对应于进程<strong>最多可以分几个段</strong></p><blockquote><p>保留分段存储管理的<strong>段号</strong>，将<strong>段内地址</strong>拆分成页号和页内偏移量。</p><p>段内地址=逻辑地址%最大段长</p></blockquote></li><li><p>(段内)页号：逻辑地址在<strong>段内所在页</strong>的页号。<code>(段内)页号=段内地址/页面长度</code></p><p>(段内)页号的位数对应于<strong>每个段最多有多少页</strong></p></li><li><p>页内偏移量：逻辑地址在<strong>段内所在页</strong>中的偏移量。<code>页内偏移量=段内地址%页面长度</code></p><p>页内偏移量的位数对应于<strong>页面大小</strong></p></li></ul><blockquote><p>段页式管理中地址是<strong>二维</strong>的，程序员要同时给出<strong>段名和段内地址</strong>才可以计算出<strong>物理地址</strong></p></blockquote></li><li><p>段表与页表结合：</p><ul><li><p>段表项：段表项的内容是<strong>页表信息</strong></p><p>段号：逻辑地址所在段号，隐含的，相当于逻辑上的数组索引</p><p>页表长度：逻辑段的页表的长度。位数与(段内)页号的位数相同</p><p>页表块号：逻辑段的页表实际存放到的内存块号，其位数由<strong>内存块的数量</strong>决定</p></li><li><p>页表项：页表变化不大，一个段对应一张页表，一个进程可以有多张页表</p><p>页号：逻辑段页号，隐含的，相当于逻辑上的数组<strong>索引</strong></p><p>块号：逻辑段页实际存放到的<strong>内存块号</strong>。其位数由<strong>内存块的数量</strong>决定</p></li></ul></li><li><p>段页表与访存</p></li></ul></li><li><p><u>地址变换机构</u>：</p><div class="mermaid-wrapper"><div class="loading-icon-wrapper mermaid-loading" style="display:flex;align-items:center;justify-content:center;height:96px;"><svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" preserveAspectRatio="xMidYMid" viewBox="25 25 50 50"><animateTransform attributeName="transform" type="rotate" dur="2s" keyTimes="0;1" repeatCount="indefinite" values="0;360"></animateTransform><circle cx="50" cy="50" r="20" fill="none" stroke="currentColor" stroke-width="4" stroke-linecap="round"><animate attributeName="stroke-dasharray" dur="1.5s" keyTimes="0;0.5;1" repeatCount="indefinite" values="1,200;90,200;1,200"></animate><animate attributeName="stroke-dashoffset" dur="1.5s" keyTimes="0;0.5;1" repeatCount="indefinite" values="0;-35px;-125px"></animate></circle></svg></div></div><ul><li>段表寄存器 <ul><li>存放段表在内存中的<strong>起始地址F和段表长度M</strong></li><li>F和M会存放于PCB中，在进程执行时存入段表寄存器</li></ul></li><li>地址变换过程 <ol><li>根据逻辑地址算出<strong>段号、页号、页内偏移量</strong></li><li>根据<strong>段号、页号</strong>得到<strong>进程逻辑段页起始地址</strong><ol><li><strong>段号越界检查</strong>：将<strong>段号</strong>与段表寄存器中的<strong>段长度</strong>对比，检查是否合法</li><li><strong>段表项索引计算</strong>：根据段表起始地址、段表项长度、段号计算出<strong>段表项地址</strong></li><li><strong>页号越界检查</strong>：由段表项得到<strong>页表长度</strong>，检查**(段内)页号**是否合法</li><li><strong>得到逻辑段页表始址</strong>：由段表项得到逻辑段页表所在<strong>内存块号</strong>，进而计算出逻辑段页表起始地址</li><li><strong>页表项索引计算</strong>：由逻辑<strong>段页表起始地址、页表项长度、逻辑段页号</strong>计算出<strong>页表项地址</strong></li><li><strong>得到逻辑段页始址</strong>：由页表项得到逻辑段页所在<strong>内存号块</strong>，进而计算出<strong>逻辑段页起始地址</strong></li></ol></li><li>根据<strong>进程逻辑段页起始地址和页内偏移量</strong>计算出<strong>物理地址</strong></li></ol></li><li>段页表与访存 <ul><li>一次查段表，一次查页表，一次访问目标单元</li><li>可引入快表减少访存</li></ul></li></ul></li></ul><h3 id="_3-4-虚拟存储" tabindex="-1"><a class="header-anchor" href="#_3-4-虚拟存储" aria-hidden="true">#</a> 3.4 虚拟存储</h3><div class="hint-container info"><p class="hint-container-title">虚拟存储</p><ul><li><a href="#%E8%A6%86%E7%9B%96%E5%92%8C%E4%BA%A4%E6%8D%A2%E6%8A%80%E6%9C%AF">覆盖和交换技术</a></li><li><a href="#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%9A%84%E6%80%9D%E6%83%B3">虚拟内存的思想</a></li><li><a href="#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%9A%84%E5%AE%9E%E7%8E%B0">虚拟内存的实现</a></li></ul></div><hr><h4 id="覆盖和交换技术" tabindex="-1"><a class="header-anchor" href="#覆盖和交换技术" aria-hidden="true">#</a> <em>覆盖和交换技术：</em></h4><ul><li><p><u>覆盖技术</u>：</p><ul><li><p>基本思想：将程序分为多个<strong>段</strong>，<strong>常用的段常驻内存</strong>，不常用的段在需要时调入内存且<strong>互相覆盖</strong></p></li><li><p>实现方式：将内存分为固定区和覆盖区，并合理划分程序的<strong>调用结构</strong></p><ul><li><p><strong>固定区</strong>：常驻内存的段放在固定区，调入后直接程序结束才调出。</p><p>在调用结构中位于顶层的模块<strong>独占固定区</strong></p><blockquote><p><strong>可重入程序段</strong>可以固定在此，由多个进程共享，减少对程序段的调入调出</p></blockquote></li><li><p><strong>覆盖区</strong>：不常用的段在用到时调入覆盖区，用不到时调出</p><p>在调用结构中位于同一层次但不会同时调用的模块<strong>共享覆盖区</strong></p></li></ul></li><li><p>适用范围：</p><ul><li>单一连续分配</li><li>固定分区分配</li></ul></li><li><p>优缺点：</p><ul><li>优点：实现了内存扩充，提高内存利用率和运行效率</li><li>缺点：必须由程序员<strong>声明覆盖结构</strong>，操作系统完成自动覆盖，对用户不透明，增加编程负担</li></ul></li></ul></li><li><p><u>交换技术</u>：</p><ul><li><p>基本思想：<strong>进程的中级调度/内存调度</strong>，将内存中暂时无法运行的进程<strong>换至外存</strong>，把外存中具备运行条件的进程<strong>换入内存</strong></p></li><li><p>实现方式：</p><ul><li><p>磁盘分为文件区和对换区：</p><p><strong>文件区</strong>存放文件，追求<strong>存储空间的利用率</strong>，因而采用<strong>离散分配</strong>；</p><p><strong>对换区</strong>只占磁盘空间的小部分，用于存放换出的进程数据，追求<strong>换入换出速度</strong>，因而采用<strong>连续分配</strong></p><blockquote><p>如果换入换出速度太慢，覆盖和交换技术就失去了意义</p></blockquote></li><li><p>交换调度策略：</p><p><strong>交换时机</strong>：系统负荷大、内存空闲不足时，例如进程经常发生缺页现象时</p><p><strong>调度策略</strong>：可换出阻塞进程、优先级低的进程，为防止抖动，还可以考虑进程在内存驻中的留时间……</p></li></ul><blockquote><p>注：进程的<strong>PCB一定常驻内存</strong>，内存调度时不会被换出</p></blockquote></li><li><p>覆盖与交换的区别</p><ul><li>覆盖是在<strong>同一个进程</strong>中的</li><li>交换是在**不同进程(或作业)**中的</li></ul></li></ul></li></ul><hr><h4 id="虚拟内存的思想" tabindex="-1"><a class="header-anchor" href="#虚拟内存的思想" aria-hidden="true">#</a> <em>虚拟内存的思想：</em></h4><ul><li><p><u>传统存储管理方式的特点</u>：</p><ul><li><p><strong>一次性</strong>：作业必须<strong>一次性全部装入</strong>内存才开始运行</p><ul><li>容易导致<strong>大作业无法运行</strong></li><li>内存无法容纳太多作业，<strong>多道程序并发度下降</strong></li></ul></li><li><p><strong>驻留性</strong>：作业装入内存后会<strong>一起驻留直到运行结束</strong></p><ul><li><p>内存中会驻留许多暂时用不到的数据，<strong>降低内存的利用率</strong></p><blockquote><p>事实上只要访问一小部分数据就可以正常运行</p></blockquote></li></ul></li></ul></li><li><p><u>虚拟内存的定义和特征</u>:</p><ul><li><p>虚拟内存的概念：程序装入内存时，可以只装入运行<strong>需要用到的模块</strong>，暂时用不到的模块可以换出至外存，待需要时再调入内存，这样在用户看来就似乎有一个比实际内存更大的内存</p><ul><li>是内存在逻辑上的扩充，其基础是<strong>操作系统的虚拟性</strong>和<strong>程序的局部性</strong></li><li>这需要部分装入和换入换出，就要求离散分配</li></ul></li><li><p>虚拟内存的特征：</p><ul><li><p><strong>多次</strong>性：允许作业分多次调入内存</p></li><li><p><strong>对换</strong>性：作业无需常驻内存，允许根据需求换入换出</p></li><li><p><strong>虚拟</strong>性：从逻辑上扩充了内存容量，<strong>最大容量</strong>由计算机的<strong>地址结构</strong>决定</p><blockquote><p>最大容量与主存和外存容量无直接联系，但实际容量受到主存和外存的限制</p></blockquote></li></ul></li></ul></li></ul><hr><h4 id="虚拟内存的实现" tabindex="-1"><a class="header-anchor" href="#虚拟内存的实现" aria-hidden="true">#</a> <em>虚拟内存的实现：</em></h4><blockquote><p>虚拟内存的要在<strong>离散分配</strong>方式的基础上实现，分页分段均可，下面以分页为例</p></blockquote><ul><li><p><u>请求调页机制</u>：</p><ul><li><p><u>页表机制</u></p><blockquote><p>在基本分页存储管理页表的基础上，添加四个新的字段</p></blockquote><ul><li><strong>状态位</strong>：是否已经调入内存</li><li><strong>访问字段</strong>：可记录最近被访问的次数，或上次访问的时间，供置换算法参考</li><li><strong>修改位</strong>：页面调入内存后是否被修改过</li><li><strong>外存地址</strong>：页面在外存中的存放位置</li></ul></li><li><p><u>缺页中断机构</u></p><ul><li><p>缺页中断的概念：进程当前指令<strong>访问的目标页未调入内存</strong>而产生的中断</p><blockquote><p>属于<strong>内中断</strong>中的故障（fault）</p><p>缺页不是越界错误</p></blockquote></li><li><p>工作流程：</p><ol><li>找到页表项后检查<strong>状态位</strong>，若页面未调入内存则产生<strong>缺页中断</strong>，阻塞当前进程</li><li>运行操作系统的<strong>缺页中断处理程序</strong>，将目标页面调入内存并更新<strong>页表</strong><ol><li>保留CPU现场</li><li>从外存中找到缺页</li><li>若内存中没有空闲块，则需要运行<strong>页面置换</strong>算法淘汰一个页面；若被调出的页面修改过，还需要<strong>写回外存</strong></li><li>CPU读入缺页，将缺页调入内存</li><li>更新页表和快表</li></ol></li><li><strong>唤醒</strong>因缺页中断阻塞的进程，放入<strong>就绪队列</strong>，让其重新执行当前指令查表</li></ol></li></ul></li><li><p><u>地址变换机构</u>：总体上与基本分页存储管理相同，增加了几个步骤</p><ul><li>请求调页：查页表项时若发现页不在内存，要产生缺页中断请求调页</li><li>页面置换：调入前若发现内存没有空闲块，需要进行页面置换</li><li>修改页表：调入缺页后修改页表，并即时增加或删除快表</li></ul></li></ul></li><li><p><u>页面置换算法</u></p><ul><li><p>最佳置换算法（OPT，Optimal）</p><ul><li>算法思想：每次淘汰<strong>之后最长时间内不再被访问</strong>的页面</li><li>算法实现：需要提前知道<strong>页面访问序列</strong>，淘汰时计算内存中各页面下一次出现的位置，最后一个出现的被淘汰</li><li>算法评价：可以保证最低的缺页率。但该算法无法实现，因为操作系统无法预判<strong>页面访问序列</strong></li></ul></li><li><p>先进先出置换算法（FIFO）</p><ul><li><p>算法思想：每次淘汰<strong>最早调入内存</strong>的页面</p></li><li><p>算法实现：将调入内存的页面按调入顺序排成队列，每次淘汰队头页面</p><blockquote><p>队列的最大长度取决于操作系统为进程分配了多少个内存块</p></blockquote></li><li><p>算法评价：实现简单；会产生 Belady 异常（四种算法中只有 FIFO 会这样），没考虑<strong>局部性原理</strong>，性能差</p><blockquote><p>Belady 异常：为进程分配的内存块数增加时，<strong>缺页次数不减反增</strong></p></blockquote></li></ul></li><li><p>最近最久未使用置换算法（LRU，least Recently Used）</p><ul><li><p>算法思想：每次淘汰最近最久未使用的页面</p></li><li><p>算法实现：用页表项的访问字段记录<strong>自上次被访问以来所经历的时间t</strong>，每次淘汰t值最大的页面</p><blockquote><p>做题时可以从当前访问页开始逆向检查访问序列，最后一个出现的就是要淘汰的</p></blockquote></li><li><p>算法评价：性能好；实现困难，需要<strong>排序</strong>，因而要专门的硬件支持，开销大</p><blockquote><p>性能最接近OPT</p></blockquote></li></ul></li><li><p>时钟置换算法/最近未用算法（NRU，Not Recently Used）/ CLOCK算法</p><ul><li><p>简单CLOCK算法的实现：</p><p>将内存中的页面链接成一个循环队列，某页被访问时，将其页表项的访问位置1；</p><p>需要淘汰页面时，从上一次淘汰的位置或其下一个位置开始，遍历队列循环检查访问位，若为0则直接换出，若为1则将其置为0；</p><p>这样最多两轮扫描，就可以淘汰一个页面</p></li><li><p>改进CLOCK算法的实现：</p><blockquote><p>思想：在近期访问情况相近的情况下，优先淘汰<strong>没有修改</strong>的页面，以减少IO次数</p></blockquote><p>将内存中的页面链接成一个循环队列，某页被访问时，将其页表项的访问位置1，某页被修改时，将其页表项的修改位置1，初始为0，用<code>(访问位,修改位)</code>表示各页面状态。</p><p>需要淘汰页面时，从上一次淘汰的位置或其下一个位置开始，遍历队列循环检查<code>(访问位,修改位)</code>：</p><p>第一轮寻找第一个<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(0,0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">0</span><span class="mclose">)</span></span></span></span>，找到则替换，不修改标志位；</p><p>第二轮寻找第一个<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(0,1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，找到则替换，将扫描过的访问位置为0；</p><p>第三轮寻找第一个<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(0,0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">0</span><span class="mclose">)</span></span></span></span>，找到则替换，不修改标志位；</p><p>第四轮寻找第一个<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(0,1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，找到则替换。</p><p>这样最多四轮扫描，就可以淘汰一个页面</p></li><li><p>算法评价：开销小，性能不错</p></li></ul></li></ul></li><li><p><u>页面置换策略</u></p><ul><li><p><strong>驻留集</strong>：请求分页存储管理中给进程分配的物理块的集合</p><ul><li>在虚拟存储中，驻留集大小一般小于进程总大小</li><li>若驻留集太小，会导致缺页频繁；若驻留集太大，会降低多道程序并发度</li></ul></li><li><p>页面分配与置换方式</p><ul><li><strong>固定分配</strong>：进程运行期间<strong>驻留集</strong>大小不变</li><li><strong>可变分配</strong>：进程运行期间<strong>驻留集</strong>大小可变</li><li><strong>局部置换</strong>：进程缺页时只能置换属于自己的物理块（由<strong>操作系统分配</strong>的）</li><li><strong>全局置换</strong>：进程缺页时可以利用操作系统的<strong>空闲块</strong>，也可以窃取<strong>其他进程</strong>的物理块</li></ul></li><li><p>三种置换<strong>策略</strong></p><ul><li><p><strong>固定分配局部置换</strong></p><p>可以根据<strong>进程优先级</strong>等信息分配内存块数</p><blockquote><p>缺点：很难确定合理的分配数</p></blockquote></li><li><p><strong>可变分配全局置换</strong></p><p>操作系统维护一个<strong>空闲物理块队列</strong>，进程缺页时可分配。</p><p>空闲物理块不足时，只能窃取其他进程<strong>未锁定</strong>的物理块</p></li><li><p><strong>可变分配局部置换</strong></p><p>若进程频繁缺页，操作系统可以为该进程分配更多物理块，直至<strong>缺页率</strong>适当；</p><p>若进程几乎不缺页，操作系统可以剥夺该进程的物理块</p></li></ul></li><li><p>调入页面的<strong>时机</strong></p><ul><li><p>预调页：根据局部性原理，在进程首次调入时预测其他可能访问到的页面</p><blockquote><p>目前的技术预测成功率只有50%左右</p></blockquote><blockquote><p><strong>运行前</strong>调入</p></blockquote></li><li><p>请求调页：进程运行期间缺页时才调入，或操作系统检查到进程缺页率较高时调入</p><blockquote><p><strong>运行时</strong>调入</p></blockquote></li></ul></li><li><p>调入页面的<strong>地点</strong></p><ul><li><p>系统有足够<strong>对换区</strong>：提前将数据从文件区复制到对换区，内存与对换区之间调入调出页面</p><blockquote><p>保证调入调出速度快</p></blockquote></li><li><p>系统对换区不充足：不会被修改的数据直接从<strong>文件区</strong>调入内存，可能会修改的数据从对换区调入调出</p></li><li><p>UNIX方式：<strong>未使用过</strong>的页面都从文件区调入，<strong>使用过</strong>后从对换区调入调出</p></li></ul></li><li><p>抖动现象与工作集：</p><ul><li><p>抖动现象描述：刚换出内存的页面马上又要换入，或刚换入内存的页面马上又要换出</p><blockquote><p>所有页面转换算法都不能完全避免抖动</p></blockquote></li><li><p>抖动现象产生原因：驻留集小于工作集</p></li><li><p>工作集：在某段时间内，进程实际访问过的<strong>页面集合</strong></p><blockquote><p>可以通过“窗口尺寸”来确定一段时间，即从页面访问序列的当前位置向前看“窗口尺寸”个页面（包括多次访问相同的页面）。这符合局部性原理，也可以据此设计一种页面置换算法</p></blockquote></li><li><p>抖动现象解决方案：保证<strong>驻留集大于工作集</strong>，即增大驻留集或减小工作集</p></li></ul></li></ul></li></ul><h2 id="_4-文件管理" tabindex="-1"><a class="header-anchor" href="#_4-文件管理" aria-hidden="true">#</a> 4 文件管理</h2><h3 id="_4-1-基本概念" tabindex="-1"><a class="header-anchor" href="#_4-1-基本概念" aria-hidden="true">#</a> 4.1 基本概念</h3><div class="hint-container info"><p class="hint-container-title">基本概念</p><ul><li><a href="#%E6%96%87%E4%BB%B6%E6%A6%82%E8%BF%B0">文件概述</a></li><li><a href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%E6%A6%82%E8%BF%B0">操作系统文件管理概述</a></li><li><a href="#%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95">文件目录</a></li><li><a href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84">文件系统层次结构</a></li></ul></div><hr><h4 id="文件概述" tabindex="-1"><a class="header-anchor" href="#文件概述" aria-hidden="true">#</a> <em>文件概述：</em></h4><ul><li><u>文件的概念</u>：文件就是一组<strong>有意义的信息/数据</strong>集合</li><li><u>文件的属性</u>：记录在**文件控制块(FCB)**中的文件属性信息 <ul><li>文件名：用户创建文件时决定的文件名，主要为了<strong>方便用户找到文件</strong>。<strong>同一目录下不允许有重名文件</strong></li><li>标识符：<strong>操作系统</strong>用于区分各个文件的内部名称。一个系统内各文件标识符唯一</li><li>类型：指明文件的<strong>类型</strong></li><li>位置：文件存放的<strong>路径</strong>（让<strong>用户</strong>使用）；文件在<strong>外存中的地址</strong>（<strong>操作系统</strong>使用，对用户不可见）</li><li>大小：指明文件的<strong>大小</strong></li><li>时间相关：创建时间、上次修改时间</li><li>保护控制相关：文件所有者信息、保护信息（对文件进行保护的访问控制信息）</li></ul></li><li><u>文件的组织（逻辑结构）</u>： <ul><li><p><strong>无结构</strong>文件：由一些<strong>二进制或字符流</strong>组成，又称”<strong>流式</strong>文件“</p></li><li><p><strong>有结构</strong>文件：由一组<strong>相似的记录</strong>组成，又称”<strong>记录式</strong>文件“</p><ul><li><strong>数据项</strong>是文件系统中最基本的数据单位</li><li><strong>记录</strong>是一组相关数据项的集合，<strong>各记录间的组织问题</strong>就是<strong>文件的逻辑结构</strong>问题</li></ul></li><li><p><strong>文件之间的组织问题</strong>就是<strong>文件目录</strong>要探讨的问题</p></li></ul></li></ul><hr><h4 id="操作系统文件管理概述" tabindex="-1"><a class="header-anchor" href="#操作系统文件管理概述" aria-hidden="true">#</a> <em>操作系统文件管理概述：</em></h4><ul><li><p><u>操作系统向上提供的<strong>API</strong></u>：</p><ul><li>创建文件：<code>create</code>系统调用，在<strong>外存</strong>中创建文件</li><li>读文件：<code>read</code>系统调用，将文件数据从<strong>外存</strong>读入<strong>内存</strong>，由<strong>CPU</strong>处理</li><li>写文件：<code>write</code>系统调用，将文件数据从<strong>内存</strong>写回<strong>外存</strong></li><li>删除文件：<code>delete</code>系统调用，将文件数据从<strong>外存</strong>中删除</li><li>打开文件：<code>open</code>系统调用，将文件控制块从外存读入内存，<strong>读/写文件之前</strong>需要做的操作</li><li>关闭文件：<code>close</code>系统调用，将文件控制块从内存写回外存，<strong>读/写文件之后</strong>需要做的操作</li></ul></li><li><p><u>操作系统向下对<strong>磁盘的管理</strong></u>：磁盘块的存储与管理</p><ul><li><p>操作以”<strong>块</strong>“为单位为<strong>文件</strong>分配存储空间，以”<strong>块</strong>“为单位划分<strong>外存</strong></p><blockquote><p>”<strong>块</strong>“的大小通常与内存页大小相同，通常为4KB</p></blockquote></li><li><p>文件也具有<strong>逻辑地址</strong>，包括<code>&lt;逻辑块号,块内地址&gt;</code>，访问外存时需要转换为<strong>物理地址</strong>，即<code>&lt;物理块号,块内地址&gt;</code></p></li><li><p>文件在磁盘块上的存储问题就是<strong>文件的物理结构</strong>问题</p></li></ul></li><li><p><u>文件共享与保护</u>：</p><ul><li>文件共享：使多个用户可以<strong>共享使用一个文件</strong></li><li>文件保护：如何保证不同的用户对文件有不同的<strong>操作权限</strong></li></ul></li></ul><hr><h4 id="文件目录" tabindex="-1"><a class="header-anchor" href="#文件目录" aria-hidden="true">#</a> <em>文件目录：</em></h4><ul><li><p><u>文件目录的概念</u>：</p><ul><li>文件目录就是<strong>文件控制块</strong>的有序集合，其本身也是一种有结构文件</li><li>文件控制块（FCB）：FCB 也是文件<strong>目录项</strong>，一个文件对应一个FCB，记录了各种文件信息 <ul><li>基本信息：<strong>文件名</strong>、<strong>物理地址</strong>、结构、类型、...</li><li>存储控制信息：是否可读写、用户访问权限</li><li>使用信息：建立时间、修改时间</li></ul></li><li>目录的操作 <ul><li><strong>搜索目录</strong>：搜索目录中的文件，即目录项FCB</li><li><strong>增加目录项</strong>：创建新文件时需要在所属目录创建目录项</li><li><strong>删除目录项</strong>：删除文件时需要在所属目录删除目录项</li><li><strong>显示目录</strong>：显示目录内容，例如其中所有文件的属性</li><li><strong>修改目录</strong>：文件属性变化时需要修改相应目录项</li></ul></li></ul></li><li><p><u>目录结构</u>：</p><ul><li><p><strong>单级</strong>目录结构</p><ul><li>特点：整个系统只有一级目录表；实现<strong>按名存取</strong>；不允许任何文件重名</li><li>缺点：不适用于多用户操作系统</li></ul></li><li><p><strong>两级</strong>目录结构</p><ul><li>特点：分为<strong>主文件</strong>目录（MFD，Master File Directory）和<strong>用户文件</strong>目录（UFD，User File Directory）；主文件目录记录<strong>用户名</strong>及用户文件目录<strong>存储位置</strong>；用户文件目录记录该用户的文件FCB；允许不同用户的文件重名</li><li>优点：在目录上实现<strong>用户访问限制</strong></li><li>缺点：缺乏灵活性，用户不能对自己的文件<strong>分类</strong></li></ul></li><li><p><strong>多级/树形</strong>目录结构</p><ul><li><p>特点：</p><p>用<strong>斜杠分隔的文件路径</strong>标识文件，各级目录用斜杠隔开；</p><p><strong>绝对路径</strong>查找文件：从外存读入<strong>根目录表</strong>和其他涉及的<strong>目录表</strong>，需要多次磁盘I/O操作；</p><p><strong>相对路径</strong>查找文件：可以设置一个“<strong>当前目录</strong>”作为查找文件的起点，减少磁盘I/O操作</p><blockquote><p>为什么能减少？因为用户很可能<strong>连续访问同一目录</strong>的多个文件，此时<strong>不必再次调入上级目录</strong>就能直接访问</p></blockquote></li><li><p>优点：层次结构清晰，可以对文件灵活分类管理</p></li><li><p>缺点：不方便文件共享</p></li></ul></li><li><p><strong>无环图</strong>目录结构</p><ul><li>特点：在<strong>树形</strong>目录结构的基础上，可以让<strong>不同文件名指向同一个文件结点</strong>（有向无环图）；为每个文件结点设置<strong>共享计数器</strong>，减为0时才删除结点</li><li>优点：方便地实现多用户间的文件共享</li></ul></li></ul></li><li><p><u>索引结点</u>：</p><ul><li><p>每个文件对应一个<strong>索引结点</strong>，存放除<strong>文件名</strong>之外的描述信息，包括文件在外存中的<strong>存放位置</strong> / <strong>地址结构</strong></p></li><li><p><strong>目录项 / FCB</strong> 只包含文件名、索引结点指针；目录项长度减少，占用的磁盘块减少，检索文件时磁盘 I/O 次数减少</p></li><li><p><strong>硬盘</strong>索引结点与<strong>内存</strong>索引结点</p><ul><li>硬盘索引结点：存放在<strong>外存</strong>中的索引结点，在通过<strong>目录项</strong>索引到时才<strong>调入内存</strong></li><li>内存索引结点：调入内存的索引结点，相比于硬盘索引结点，需要增加一些信息（例如是否被修改，有几个进程正在访问）</li></ul><blockquote><p>FAT 文件系统并没有这种索引结点，而 Ext 文件系统有这种<code>inode</code></p></blockquote></li></ul></li></ul><hr><h4 id="文件系统层次结构" tabindex="-1"><a class="header-anchor" href="#文件系统层次结构" aria-hidden="true">#</a> <em>文件系统层次结构：</em></h4><blockquote><p>从“用户/应用程序”的调用开始，自顶向下：</p></blockquote><ul><li>用户接口：向上层用户提供功能接口，处理相关<strong>系统调用</strong>请求</li><li>文件目录系统：解析用户的文件路径，找到相应的<strong>FCB或索引结点</strong>。管理目录和目录项</li><li>存取控制系统：验证用户权限，完成<strong>文件保护</strong>相关功能</li><li>逻辑文件系统与文件信息缓冲区：将用户要访问的<strong>文件记录号</strong>转换为对应的<strong>逻辑地址</strong><ul><li>文件信息缓冲区可用于存放调入内存的索引表</li></ul></li><li>物理文件系统：将文件逻辑地址转换为<strong>物理地址</strong></li><li>辅助分配模块和设备管理模块 <ul><li>辅助分配模块：负责分配和回收<strong>存储空间</strong></li><li>设备管理模块：与<strong>硬件</strong>直接交互，负责硬件设备相关的管理工作</li></ul></li></ul><h3 id="_4-2-文件的结构" tabindex="-1"><a class="header-anchor" href="#_4-2-文件的结构" aria-hidden="true">#</a> 4.2 文件的结构</h3><div class="hint-container info"><p class="hint-container-title">文件的结构</p><ul><li><a href="#%E6%96%87%E4%BB%B6%E7%9A%84%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84">文件的逻辑结构</a></li><li><a href="#%E6%96%87%E4%BB%B6%E7%9A%84%E7%89%A9%E7%90%86%E7%BB%93%E6%9E%84">文件的物理结构</a></li></ul></div><hr><h4 id="文件的逻辑结构" tabindex="-1"><a class="header-anchor" href="#文件的逻辑结构" aria-hidden="true">#</a> <em>文件的逻辑结构：</em></h4><ul><li><p><u>文件逻辑结构概述</u></p><ul><li>文件逻辑结构的含义：在<strong>用户</strong>看来文件的数据是如何组织的</li><li>文件逻辑结构的分类： <ul><li>无结构文件：由<strong>二进制或字符流</strong>组成，无明显逻辑结构</li><li>有结构文件：由<strong>记录</strong>组成，又称“记录式文件”，每条记录由若干<strong>数据项/字段</strong>组成。分为<strong>定长</strong>记录、<strong>可变长</strong>记录 <ul><li><strong>顺序</strong>文件</li><li><strong>索引</strong>文件</li><li><strong>索引</strong>顺序</li></ul></li></ul></li></ul></li><li><p><u>顺序文件</u></p><ul><li><p><strong>逻辑结构</strong>定义：</p><ul><li><p>文件中的<strong>记录</strong>在逻辑上相邻，<strong>顺序排列</strong></p></li><li><p><strong>串</strong>结构：记录之间的顺序与关键字无关</p><blockquote><p>通常按照<strong>存入的时间</strong>决定记录的顺序</p></blockquote></li><li><p><strong>顺序</strong>结构：记录之间的顺序与关键字有关</p></li></ul></li><li><p><strong>存取</strong>方式：</p><ul><li><strong>链式</strong>存储：<strong>无法实现随机存取</strong>，只能从第一个记录依次查找</li><li><strong>顺序</strong>存储 <ul><li><strong>可变长</strong>记录的顺序存储：<strong>无法实现随机存取</strong>，只能从第一个记录依次查找</li><li><strong>定长</strong>记录的顺序存储：<strong>可以实现随机存取</strong>；串结构无法根据关键字快速索引；顺序结构可以根据关键字<strong>快速索引</strong></li></ul></li></ul></li><li><p>特点：</p><ul><li><p>“顺序文件”一般指<strong>顺序存储</strong>的顺序文件</p></li><li><p>缺点：增删记录较麻烦</p><blockquote><p>如果是串结构不保证顺序，则增加会相对简单</p></blockquote></li></ul></li></ul></li><li><p><u>索引文件</u></p><ul><li><strong>逻辑结构</strong>定义： <ul><li>文件记录通过<strong>索引表</strong>组织起来，每个记录对应一个表项</li><li>索引表：一种<strong>定长记录的顺序文件</strong>，可以随机存取，按关键字排序还可以<strong>快速索引</strong>；表项中包括<strong>索引号</strong>（key）、<strong>记录长度</strong>、<strong>记录指针</strong>等信息，可以根据索引号快速查询表项</li></ul></li><li><strong>存取</strong>方式： <ul><li>由索引表项的<strong>指针</strong>指向<strong>逻辑文件记录</strong>，文件记录可以在<strong>离散</strong>存放</li></ul></li><li>特点： <ul><li>主要用于对<strong>信息处理的及时性</strong>要求比较高的场合</li><li>可以用不同数据项为索引号（key）建立<strong>多张索引表</strong></li><li>方便<strong>增删</strong>，实现定长和可变长记录的<strong>随机存取</strong></li><li>缺点：索引表可能占用较大空间</li></ul></li></ul></li><li><p><u>索引顺序文件</u></p><ul><li><strong>逻辑</strong>结构定义： <ul><li>文件记录<strong>分组</strong>后通过<strong>索引表</strong>组织起来，每个记录对应一个表项组</li><li>索引表不必按关键字排序，顺序插入即可</li></ul></li><li><strong>存取</strong>方式： <ul><li>由索引表项的<strong>指针</strong>指向<strong>逻辑文件记录组</strong>，每组文件记录可以<strong>离散</strong>存放</li><li>每组内文件记录<strong>顺序</strong>存放</li></ul></li><li>特点： <ul><li>检索时先<strong>顺序查索引表</strong>找到分组，再<strong>顺序查找分组</strong>内记录</li><li>记录过多时可以建立多级索引表</li><li>最佳分组数是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msqrt><mrow><mi>r</mi><mi>e</mi><mi>c</mi><mi>o</mi><mi>r</mi><mi>d</mi><mi>C</mi><mi>o</mi><mi>u</mi><mi>n</mi><mi>t</mi><mi>s</mi></mrow></msqrt></mrow><annotation encoding="application/x-tex">\sqrt{recordCounts}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.04em;vertical-align:-0.1078em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9322em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord mathnormal" style="margin-right:0.02778em;">recor</span><span class="mord mathnormal">d</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal">o</span><span class="mord mathnormal">u</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mord mathnormal">s</span></span></span><span style="top:-2.8922em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg xmlns="http://www.w3.org/2000/svg" width="400em" height="1.08em" viewBox="0 0 400000 1080" preserveAspectRatio="xMinYMin slice"><path d="M95,702
c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14
c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54
c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10
s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429
c69,-144,104.5,-217.7,106.5,-221
l0 -0
c5.3,-9.3,12,-14,20,-14
H400000v40H845.2724
s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7
c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z
M834 80h400000v40h-400000z"></path></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1078em;"><span></span></span></span></span></span></span></span></span></li></ul></li></ul></li></ul><hr><h4 id="文件的物理结构" tabindex="-1"><a class="header-anchor" href="#文件的物理结构" aria-hidden="true">#</a> <em>文件的物理结构：</em></h4><ul><li><p><u>文件物理结构概述</u></p><ul><li><p>文件物理结构的含义：在<strong>操作系统</strong>看来文件的数据是如何存放在<strong>外存</strong>的，是操作系统对<strong>非空闲磁盘块</strong>的管理分配方式，也是<strong>文件分配方式</strong></p><blockquote><p>绝大多数操作系统为改善磁盘访问时间，会<strong>以簇（多个磁盘块整体）为单位</strong>进行分配</p></blockquote></li><li><p>文件物理结构的分类</p><ul><li>连续分配</li><li>链接分配 <ul><li>隐式链接</li><li>显式链接</li></ul></li><li>索引分配</li></ul></li></ul></li><li><p><u>文件块与磁盘块</u></p><ul><li><p>磁盘块：<strong>磁盘</strong>中的所有存储单元以“块”为单位，称之为磁盘块</p><ul><li>磁盘块的大小与<strong>页面</strong>的大小相同</li><li>内存与磁盘间的<strong>数据交换</strong>也是以“块”为单位</li></ul></li><li><p>文件块：文件的<strong>逻辑地址空间</strong>以“块”为单位，称之为文件块</p><ul><li><p>文件的逻辑地址可以表示为：<code>(逻辑块号, 块内地址)</code></p><blockquote><p>文件的逻辑地址就是逻辑上该文件连续存储，从第 0 块开始，直到最后一块</p></blockquote></li><li><p>操作系统<strong>以块为单位</strong>为文件<strong>分配</strong>存储空间，负责实现文件逻辑地址到物理地址的映射</p><blockquote><p>“映射”本质是<strong>逻辑块号</strong>到<strong>物理块号</strong>的映射</p></blockquote></li></ul></li></ul></li><li><p><u>连续分配</u></p><ul><li>存储方式：每个文件在磁盘上占有<strong>一组连续的块</strong></li><li>访问方式 <ul><li><p>目录项：记录<strong>起始块号</strong>与<strong>文件长度</strong></p></li><li><p>通过<code>物理块号=起始块号+逻辑块号</code>计算，支持顺序访问与随机访问</p><blockquote><p>当然还需要检查逻辑块号是否合法：<code>逻辑块号&lt;长度</code></p></blockquote></li></ul></li><li>优缺点 <ul><li>优点：<strong>顺序存取</strong>速度最快；支持<strong>随机访问</strong></li><li>缺点：产生<strong>碎片</strong>，外存利用率低；不利于文件<strong>拓展</strong></li></ul></li></ul></li><li><p><u>链接分配-隐式链接</u></p><ul><li><p>存储方式：离散分配，每个磁盘块都有指向下一个磁盘块的指针</p><blockquote><p>这些<strong>指针对用户透明</strong>，且指针的大小不算在文件大小内</p></blockquote></li><li><p>访问方式</p><ul><li><p>目录项：记录<strong>起始</strong>块号与<strong>结束</strong>块号</p></li><li><p>从<strong>起始块号</strong>开始，将磁盘块<strong>读入内存</strong>，进而通过指针找到下一块并读入内存，直到结束</p><blockquote><p>读入i号逻辑块需要i+1次磁盘I/O（从0号块开始）</p></blockquote></li></ul></li><li><p>优缺点</p><ul><li>优点：不产生碎片，外存利用率高；方便文件拓展</li><li>缺点：只支持**顺序访问，**不能随机访问</li></ul></li></ul></li><li><p><u>链接分配-显式链接</u></p><ul><li><p>存储方式：离散分配，通过文件分配表(FAT)记录各<strong>磁盘块</strong>指向下一块的<strong>指针/块号</strong></p><ul><li><p>一个<strong>磁盘</strong>仅设置一张<strong>FAT</strong>，开机时FAT读入<strong>内存</strong>并<strong>常驻</strong></p></li><li><p>FAT表项：物理块号+下一块指针/块号</p><blockquote><p>FAT各表项物理上连续存储且表项长度相等，所以物理块号其实可以隐含</p></blockquote></li></ul></li><li><p>访问方式：</p><ul><li>目录项：记录<strong>起始块号</strong></li><li>从<strong>起始块号</strong>开始，查<strong>FAT</strong>得到下一磁盘块指针/块号，直到找到需要的块号或下一块号为-1</li></ul></li><li><p>优缺点：</p><ul><li><p>优点：支持顺序访问，也支持<strong>随机访问</strong>，相比于隐式连接访问速度更块；不会产生碎片；方便拓展</p><blockquote><p>注意，随机访问指的是<strong>访问第i块不需要依次访问前i-1块</strong>，只需要查询<strong>内存</strong>中的FAT即可</p></blockquote></li><li><p>缺点：FAT 需要占用一定空间</p></li></ul><blockquote><p>FAT 是 Windows 系统早期使用的方式，没有<strong>索引结点</strong></p></blockquote></li></ul></li><li><p><u>索引分配</u></p><ul><li><p>存储方式：为每个文件建立<strong>索引表</strong></p><ul><li><p><strong>索引表</strong>记录文件各<strong>逻辑块</strong>对应的<strong>物理块</strong></p><ul><li><p>索引表存放的磁盘块称为<strong>索引块</strong></p></li><li><p>文件数据存放的磁盘块称为<strong>数据块</strong></p><blockquote><p>若文件过大，可以采用链接方案、多层索引、混合索引；</p><p>链接方案就是只使用一级索引，但索引表长度超过一个磁盘块大小则不得不<strong>链接存储</strong>；</p><p>多层索引、混合索引的索引表长度不能超过一个磁盘块</p></blockquote></li></ul></li><li><p>多层索引：多级索引表</p><blockquote><p>会涉及到文件最大长度计算、访存次数计算的问题</p></blockquote></li><li><p>混合索引：顶级索引表中部分表项是<strong>直接地址索引</strong>，部分表项是<strong>一级间接</strong>索引、<strong>二级间接</strong>索引等</p><blockquote><p>会涉及到文件最大长度计算、访存次数计算的问题</p></blockquote></li></ul></li><li><p>访问方式：</p><ul><li>链接方案的目录项：记录(顶级)<strong>索引块块号</strong></li><li>通过 FCB 找到各级索引表<strong>读入内存</strong>，查索引表得出逻辑块在外存中的磁盘块号</li></ul></li><li><p>优缺点：</p><ul><li>优点：支持<strong>随机</strong>访问，方便<strong>拓展</strong>；混合索引可以兼容大文件与小文件</li><li>缺点：索引表需要占用存储空间；对于大文件，链接方案可能需要多次读取索引块；对于小文件，多层索引依然需要读入各级索引表</li></ul><blockquote><p>索引分配是 Linux 常用的方式（Ext 文件系统），有<strong>索引结点</strong>（<code>Inode</code>），一部分保存<code>MetaData</code>，一部分保存索引分配的结构</p></blockquote></li></ul></li></ul><h3 id="_4-3-文件空间管理与操作" tabindex="-1"><a class="header-anchor" href="#_4-3-文件空间管理与操作" aria-hidden="true">#</a> 4.3 文件空间管理与操作</h3><div class="hint-container info"><p class="hint-container-title">文件空间管理与操作</p><ul><li><a href="#%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E7%A9%BA%E9%97%B4%E7%AE%A1%E7%90%86">文件存储空间管理</a></li><li><a href="#%E6%96%87%E4%BB%B6%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C">文件基本操作</a></li><li><a href="#%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB%E4%B8%8E%E4%BF%9D%E6%8A%A4">文件共享与保护</a></li></ul></div><h4 id="文件存储空间管理" tabindex="-1"><a class="header-anchor" href="#文件存储空间管理" aria-hidden="true">#</a> <em>文件存储空间管理：</em></h4><ul><li><p><u>存储空间划分与初始化</u></p><ul><li><p>存储空间划分：将<strong>物理磁盘</strong>划分成一个个<strong>文件卷</strong></p><ul><li>文件卷也叫逻辑卷、逻辑盘</li></ul><blockquote><p>有的文件系统也可以将多个物理磁盘组成一个文件卷</p></blockquote></li><li><p>存储空间初始化：将各个<strong>文件卷</strong>划分为<strong>目录区和文件区</strong></p><ul><li><p>目录区：存放文件目录信息（<strong>FCB、索引结点</strong>）、磁盘存储空间<strong>管理信息</strong>等</p><blockquote><p>管理信息包括空闲表、位示图、超级块等</p></blockquote></li><li><p>文件区：存放<strong>文件数据</strong></p></li></ul></li></ul></li><li><p><u>存储空间管理方法</u></p><ul><li><p><strong>空闲表法</strong></p><ul><li>记录与组织空闲磁盘块：用空闲盘块表记录每个空闲盘块区的<strong>起始盘块号和盘块数</strong><ul><li>表项：起始盘块号、盘块数</li></ul></li><li>分配磁盘块：使用<strong>动态分区分配算法</strong>，为文件分配<strong>连续</strong>的存储空间，并<strong>修改表项</strong></li><li>回收磁盘块：回收并根据前后空闲分区情况<strong>修改表项</strong></li><li>适用情况：连续分配</li></ul></li><li><p><strong>空闲链表法-空闲盘块链</strong></p><ul><li><strong>记录与组织</strong>空闲磁盘块：以<strong>盘块</strong>为单位组成链表 <ul><li>空闲盘块中存储下一个空闲盘块的指针</li><li>操作系统保存着<strong>链头、链尾指针</strong></li></ul></li><li><strong>分配</strong>磁盘块：从<strong>链头</strong>开始摘下若干个盘块分配，并修改<strong>链头指针</strong></li><li><strong>回收</strong>磁盘块：将回收的盘块挂到<strong>链尾</strong>，并修改<strong>链尾指针</strong></li><li>适用情况：离散分配。为文件分配多个磁盘块时效率较低，要重复多次操作</li></ul></li><li><p><strong>空闲链表法-空闲盘区链</strong></p><ul><li><strong>记录与组织</strong>空闲磁盘块：以<strong>盘区</strong>为单位组成链表 <ul><li>盘区由连续的空闲盘块组成</li><li>盘区的第一个盘块记录长度和指针</li><li>操作系统保存着<strong>链头、链尾指针</strong></li></ul></li><li><strong>分配</strong>磁盘块：使用<strong>动态分区分配算法</strong>，从<strong>链头</strong>检索合适的空闲盘区。若没有合适的盘区，可以分配不同盘区的盘块，并注意修改<strong>链指针和盘区大小</strong></li><li><strong>回收</strong>磁盘块：若回收区刚好与某一空闲区<strong>相邻</strong>，则<strong>合并</strong>；若<strong>无相邻</strong>，则将回收区作为单独的新空闲区挂到<strong>链尾</strong>。注意修改<strong>链指针和盘区大小</strong></li><li>适用情况：离散与连续分配均可。为文件分配多个磁盘块时效率更高</li></ul></li><li><p><strong>位示图法</strong></p><ul><li><p><strong>记录与组织</strong>磁盘块：</p><ul><li><p>用连续的“字”表示。一个“字”作为一<strong>行</strong>，“字”中的每个二进制位（一<strong>列</strong>）对应一个盘块，构成<strong>位示图</strong></p><blockquote><p>例如“0”代表空闲、“1”代表分配</p></blockquote></li><li><p>用<code>(字号, 位号)</code>对应<strong>盘块号</strong>，结合<strong>字长</strong>可以得出两者之间的数学关系</p></li></ul></li><li><p><strong>分配</strong>磁盘块：<strong>顺序扫描</strong>位示图，找到若干个<strong>空闲块</strong>的<code>(字号, 位号)</code>，算出<strong>盘块号</strong>，分配，并<strong>修改相应位</strong></p></li><li><p><strong>回收</strong>磁盘块：根据回收的<strong>盘块号</strong>计算<code>(字号, 位号)</code>，<strong>修改相应位</strong></p></li><li><p>适用情况：离散与连续分配均可</p></li></ul></li><li><p><strong>成组链接法</strong></p><ul><li><p><strong>记录与组织</strong>空闲磁盘块：</p><ul><li>空闲盘块以组为单位，可以不连续</li><li>每组盘块的<strong>第一块</strong>要记录下一组的空闲盘块数和各空闲盘块号（指针），其他盘块就是不记录信息的空闲块 <ul><li>“第一个”这样的块就是<strong>超级块</strong>，它自成一组</li><li>“最后一个”这样的块会将<strong>第一个空闲盘块号设为-1</strong>，代表没有再下一组了</li></ul></li></ul></li><li><p><strong>分配</strong>磁盘块：检查<strong>超级块指向的分组</strong>块数是否足够，足够则分配并修改信息，不足则先分配分组内所有块，并将<strong>分组第一块信息</strong>复制到<strong>超级块</strong>中，再从<strong>下一组</strong>中分配</p><blockquote><p>超级块就像一个<code>dummyHead</code></p></blockquote></li><li><p><strong>回收</strong>磁盘块：检查<strong>超级块指向的分组</strong>是否足够容纳，足够则插入该分组，不足则把回收的作为<strong>新分组</strong>，复制<strong>超级块</strong>内容至<strong>新分组第一盘块</strong>，并让超级块中记录新分组信息，直到回收所有块</p><blockquote><p>有点类似头插法</p></blockquote></li><li><p>适用：离散与连续分配均可</p></li></ul></li></ul></li></ul><hr><h4 id="文件基本操作" tabindex="-1"><a class="header-anchor" href="#文件基本操作" aria-hidden="true">#</a> <em>文件基本操作：</em></h4><ul><li><p><u>创建文件</u></p><ul><li>参数： <ul><li>所需外存<strong>空间大小</strong></li><li>存放<strong>路径</strong></li><li>文件<strong>名</strong></li></ul></li><li>系统调用<code>create</code><ul><li>分配<strong>外存空间</strong></li><li>创建<strong>目录项</strong></li></ul></li></ul></li><li><p><u>删除文件</u></p><ul><li>参数： <ul><li>存放<strong>路径</strong></li><li>文件<strong>名</strong></li></ul></li><li>系统调用<code>delete</code>： <ol><li>找到目录项</li><li>回收<strong>外存空间</strong></li><li>删除目录项</li></ol></li></ul></li><li><p><u>打开文件</u></p><ul><li><p>参数：</p><ul><li>存放路径</li><li>文件名</li><li>对文件的操作类型</li></ul></li><li><p>系统调用<code>open</code>：</p><ul><li><p>目录项：找到<strong>目录项</strong>并复制进<strong>内存</strong>的打开文件表中，检查操作权限</p><blockquote><p>只复制<strong>目录项</strong>而不复制<strong>文件数据</strong></p></blockquote></li><li><p>打开文件表：</p><ul><li><p><strong>系统打开文件表</strong>中的打开计数器加 1</p></li><li><p>返回<strong>用户打开文件表</strong>的索引号，用户使用该编号指明要操作的文件</p><blockquote><p>文件描述符</p></blockquote></li></ul></li></ul></li><li><p>打开文件表：</p><ul><li>系统的打开文件表 <ul><li><strong>打开计数器</strong>记录此时有多少进程打开了此文件</li><li>方便系统实现某些文件管理功能</li></ul></li><li>用户进程的打开文件表 <ul><li><strong>读写指针</strong>记录进程对文件读/写操作进行到的位置</li><li><strong>访问权限</strong>记录用户进程对文件的访问权限</li></ul></li></ul></li></ul></li><li><p><u>关闭文件</u></p><ul><li>参数：打开文件表的编号</li><li>系统调用<code>close</code><ul><li>删除用户进程<strong>打开文件表项</strong></li><li>回收该文件的进程<strong>内存空间</strong>等资源</li><li>系统打开文件表打开计数器减 1，如果减到 0 则删除表项</li></ul></li></ul></li><li><p><u>读文件</u></p><ul><li><p>参数：</p><ul><li>打开文件表的<strong>编号</strong></li><li>读入的<strong>数据量</strong></li><li>读入到的<strong>内存位置</strong></li></ul></li><li><p>系统调用<code>read</code>：</p><ul><li><p>根据读写指针指向的<strong>外存</strong>空间<strong>读入</strong>指定数据，存放至指定<strong>内存</strong>位置</p><blockquote><p>从外存读入内存。如果所读数据文件不在内存，会产生中断（<strong>缺页中断</strong>），阻塞进程，直到所需数据从外存调入内存。</p></blockquote></li></ul></li></ul></li><li><p><u>写文件</u></p><ul><li><p>参数：</p><ul><li>打开文件表的<strong>编号</strong></li><li>写回的<strong>数据量</strong></li><li>被写回数据的<strong>内存位置</strong></li></ul></li><li><p>系统调用<code>write</code></p><ul><li><p>从<strong>内存</strong>指定位置<strong>读出</strong>指定数据，写回读写指针指向的<strong>外存</strong>空间</p><blockquote><p>从内存写回外存</p></blockquote></li></ul></li></ul></li></ul><hr><h4 id="文件共享与保护" tabindex="-1"><a class="header-anchor" href="#文件共享与保护" aria-hidden="true">#</a> <em>文件共享与保护：</em></h4><ul><li><p><u>文件共享</u></p><ul><li><p><strong>硬链接</strong>/基于<strong>索引结点</strong>的共享方式</p><ul><li><p>不同<strong>目录项</strong>指向同一个<strong>索引结点</strong>，索引结点上设置<strong>链接计数变量</strong></p></li><li><p>用户删除文件时只删除目录项，并将链接计数变量减 1，若减为 0 则删除索引结点和文件数据</p><blockquote><p>否则会导致指针悬空</p></blockquote></li></ul></li><li><p><strong>软链接</strong>/基于<strong>符号链</strong>的共享方式</p><ul><li><p>创建 <strong>Link 类型文件</strong>来记录文件存放路径</p><blockquote><p>例如 Windows 的快捷方式，是一种独立的文件</p></blockquote></li><li><p>源文件被删除会导致 Link 文件的链接失效，但 Link 文件本身依然存在</p></li><li><p>可能涉及到查询多级目录，多次I/O操作</p></li></ul></li></ul></li><li><p><u>文件保护</u></p><ul><li><p>口令保护</p><ul><li>保护方式：为文件<strong>设置口令</strong>，用户访问时需要<strong>提供口令</strong>，系统验证是否正确</li><li>评价：开销小，但口令一般存放在<strong>FCB或索引结点</strong>中，不太安全</li></ul></li><li><p>加密保护</p><ul><li>保护方式：用密码<strong>加密</strong>文件，用户访问时需要<strong>提供密码</strong>才能<strong>解密</strong>文件</li><li>评价：<strong>安全性</strong>高，但加密解密需要一定开销</li></ul></li><li><p>访问控制</p><ul><li><p>保护方式：在<strong>FCB或索引结点</strong>中增加<strong>访问控制列表</strong>(Access-Control List, ACL)，记录各（组）用户对文件的<strong>访问权限</strong></p><blockquote><p>文件本身也有访问相关的属性，所以对一个文件的访问，常由<strong>用户访问权限和文件属性</strong>共同限制</p></blockquote></li><li><p>访问类型：</p><ul><li>读、写、删除</li><li>执行：将文件装入内存并执行</li><li>追加：在文件结尾添加新信息</li><li>列表清单：列出<strong>文件名和属性</strong>信息</li></ul></li><li><p>评价：<strong>灵活</strong>，可实现复杂文件保护功能；必须由<strong>系统</strong>支持实现</p></li></ul></li><li><p>存取控制矩阵</p><ul><li><p>行是所有文件，列是所有用户，表项是相关权限</p><blockquote><p>用户进入系统时需注册，是<strong>系统级</strong>的管理</p></blockquote></li><li><p>优点：权限规定细致</p></li><li><p>缺点：过于繁琐，占用较多存储空间</p></li></ul></li></ul></li></ul><h3 id="_4-4-磁盘的结构与管理" tabindex="-1"><a class="header-anchor" href="#_4-4-磁盘的结构与管理" aria-hidden="true">#</a> 4.4 磁盘的结构与管理</h3><div class="hint-container info"><p class="hint-container-title">磁盘的结构与管理</p><ul><li><a href="#%E7%A3%81%E7%9B%98%E7%9A%84%E7%BB%93%E6%9E%84%E4%B8%8E%E8%AF%BB%E5%86%99">磁盘的结构与读写</a></li><li><a href="#%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95">磁盘调度算法</a></li><li><a href="#%E7%A3%81%E7%9B%98%E7%9A%84%E7%AE%A1%E7%90%86">磁盘的管理</a></li></ul></div><h4 id="磁盘的结构与读写" tabindex="-1"><a class="header-anchor" href="#磁盘的结构与读写" aria-hidden="true">#</a> <em>磁盘的结构与读写：</em></h4><ul><li><p><u>磁盘结构</u></p><ul><li><p>磁盘与<strong>盘面</strong>：磁盘由表面涂有磁性物质的圆形盘片组成，用于记录二进制数据</p></li><li><p>磁道与<strong>柱面</strong>：</p><ul><li>盘面被划分成若干圆环，每个圆环就是一条<strong>磁道</strong></li><li>若干<strong>盘面垂直放置</strong>，同一铅锤线上（相对位置相同）的磁道构成一个<strong>柱面</strong></li></ul></li><li><p><strong>扇区</strong>与磁盘块</p><ul><li><p><strong>一个磁道</strong>被划分成若干扇区，一个扇区也是一个磁盘块</p></li><li><p>各扇区（包括不同磁道上的）存储的<strong>数据量相同</strong></p><blockquote><p>最内侧磁道扇区面积最小，数据<strong>密度</strong>最大</p></blockquote></li></ul></li></ul></li><li><p><u>磁盘读写</u></p><ul><li>磁盘的物理地址：<code>(柱面号, 盘面号, 扇区号)</code></li><li>磁盘的读写过程 <ol><li>根据<strong>柱面</strong>号移动磁臂，将<strong>磁头</strong>移动到指定柱面</li><li>激活<strong>盘面</strong>对应磁头</li><li>磁盘旋转，指定<strong>扇区</strong>从磁头下划过时，完成读写</li></ol></li><li>地址结构的设计 <ul><li>若采用<code>(盘面号, 柱面号, 扇区号)</code>，读取连续物理地址时，很可能经常<strong>启动磁头臂，切换柱面</strong>，效率较低</li><li>若采用<code>(柱面号, 盘面号, 扇区号)</code>，读取连续物理地址时，很可能经常切换<strong>盘面</strong>，但这<strong>不需要移动磁头臂</strong>，这需要激活相邻盘面的<strong>磁头</strong></li></ul></li></ul></li><li><p><u>磁盘分类</u></p><ul><li>按磁头是否可移动 <ul><li>移动头/活动头磁盘：每个盘面只有一个磁头，磁臂可以来回伸缩带动磁头定位磁道</li><li>固定头磁盘：每个磁道均有一个磁头</li></ul></li><li>按磁盘片是否可更换 <ul><li>固定盘磁盘</li><li>可换盘磁盘</li></ul></li></ul></li></ul><hr><h4 id="磁盘调度算法" tabindex="-1"><a class="header-anchor" href="#磁盘调度算法" aria-hidden="true">#</a> <em>磁盘调度算法：</em></h4><ul><li><p><u>时间衡量指标</u></p><ul><li><p>寻找时间/寻道时间 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mi>s</mi></msub></mrow><annotation encoding="application/x-tex">T_s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>：在读/写数据前，启动磁臂，<strong>移动磁头到指定磁道</strong>所花的时间</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mi>s</mi></msub><mo>=</mo><mi>s</mi><mo>+</mo><mi>m</mi><mo>×</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">T_s=s+m\times n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span></p><ul><li>启动磁头臂耗时：s</li><li>移动磁盘耗时：匀速移动，每跨域一个磁道耗时m，共需跨越n条磁道</li></ul><blockquote><p>现代硬盘 s 约为 2ms，m*n 约为 0.2ms；</p><p>受磁盘调度算法影响，操作系统可以通过磁盘调度算法控制</p></blockquote></li><li><p>延迟时间 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mi>R</mi></msub></mrow><annotation encoding="application/x-tex">T_R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.00773em;">R</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>：<strong>旋转磁盘</strong>，使磁头定位到目标扇区所需时间</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mi>R</mi></msub><mo>=</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mo>×</mo><mfrac><mn>1</mn><mi>r</mi></mfrac><mo>=</mo><mfrac><mn>1</mn><mrow><mn>2</mn><mi>r</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">T_R=\frac12\times\frac1r=\frac1{2r}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.00773em;">R</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.1901em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.1901em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.1901em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p><ul><li>r：磁盘转速</li></ul><blockquote><p>硬盘典型转速为5400转/分或7200转/分；</p></blockquote></li><li><p>传输时间 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">T_t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>：对磁盘<strong>读写数据</strong>经历的时间</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mi>t</mi></msub><mo>=</mo><mfrac><mn>1</mn><mi>r</mi></mfrac><mo>×</mo><mfrac><mi>b</mi><mi>N</mi></mfrac><mo>=</mo><mfrac><mi>b</mi><mrow><mi>r</mi><mi>N</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">T_t=\frac1r\times\frac bN=\frac b{rN}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.1901em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.2251em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">b</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2251em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">b</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p><ul><li>b：此次读写的字节数</li><li>N：每个<strong>磁道</strong>上的字节数</li></ul><blockquote><p>转速r是<strong>硬件固有属性</strong>，操作系统不可控</p></blockquote></li><li><p>减少<strong>延迟时间</strong>的方法：</p><ul><li>交替编号：编号相邻的<strong>扇区</strong>在<strong>物理上不相邻</strong><ul><li>原理：访问完一个扇区需要<strong>处理一段时间</strong>才能访问下一扇区，而磁盘是<strong>不停旋转</strong>的</li></ul></li><li>错位命名：相邻<strong>盘面</strong>扇区<strong>编号错位</strong><ul><li>原理：与“交替编号”原理相同，此处是跨了一个<strong>盘面</strong>。可以<strong>减少延迟时间</strong></li></ul></li></ul></li></ul></li><li><p><u>先来先服务(FCFS)</u></p><ul><li>思想：按访问请求到达的<strong>先后顺序</strong>进行处理</li><li>优点： <ul><li>公平</li><li>若磁道访问比较集中，性能尚可</li></ul></li><li>缺点： <ul><li>若磁道访问分散，则性能差，寻道时间长</li></ul></li></ul></li><li><p><u>最短寻找时间优先(SSTF)</u></p><ul><li><p>思想：每次都优先响应<strong>距离磁头最近</strong>的磁道访问请求</p><blockquote><p>贪心算法的思想</p></blockquote></li><li><p>优点：性能好，<strong>平均寻道时间较短</strong></p></li><li><p>缺点：</p><ul><li>可能导致<strong>饥饿</strong></li><li>磁头可能在小区域来回移动</li></ul></li></ul></li><li><p><u>扫描算法/电梯算法(SCAN)</u></p><ul><li><p>思想：只有<strong>磁头移动到最边缘</strong>才能改变磁头移动方向，移动途中响应请求</p><blockquote><p>为了防止SSTF中磁头在小区域来回移动的情况</p></blockquote></li><li><p>优点：</p><ul><li>性能好，<strong>平均寻道时间较短</strong></li><li>不会产生<strong>饥饿现象</strong></li></ul></li><li><p>缺点：</p><ul><li>只有到达最边缘才能改变磁头方向</li><li>对各位置磁道<strong>响应频率不均匀</strong></li></ul></li></ul></li><li><p><u>循环扫描算法(C-SCAN)</u></p><ul><li>思想：磁头移动到最边缘时<strong>立即返回另一边</strong>，返回途中不响应请求，移动途中响应请求</li><li>优点：基于SCAN，比SCAN响应各位置磁道更平均</li><li>缺点： <ul><li>只有到达最边缘才能改变磁头方向，且返回时必须返回到另一边缘</li><li>平均寻道时间比SCAN更长</li></ul></li></ul></li><li><p><u>LOOK算法</u></p><ul><li><p>思想：基于SCAN算法，只要在磁头移动方向上<strong>不再有请求</strong>，就立即改变磁头方向</p><blockquote><p>若题目中无特别说明，SCAN算法指的就是LOOK算法</p></blockquote></li><li><p>优点：基于SCAN算法，寻道时间进一步缩短</p></li></ul></li><li><p><u>C-LOOK算法</u></p><ul><li><p>思想：基于C-SCAN算法，只要在磁头移动方向上<strong>不再有请求</strong>，就立即让磁头返回另一边，且只需要<strong>返回到有磁道访问请求</strong>处</p><blockquote><p>若题目中无特别说明，C-SCAN算法指的就是C-LOOK算法</p></blockquote></li><li><p>优点：基于C-SCAN算法，寻道时间进一步缩短</p></li></ul></li></ul><hr><h4 id="磁盘的管理" tabindex="-1"><a class="header-anchor" href="#磁盘的管理" aria-hidden="true">#</a> <em>磁盘的管理：</em></h4><ul><li><p><u>磁盘初始化</u></p><ol><li><p>低级格式化/物理格式化：将磁盘和各个磁道划分为<strong>扇区</strong></p><ul><li><p>一个扇区可分为<strong>头、数据区域、尾</strong>三个部分</p></li><li><p>头和尾可存放<strong>扇区管理信息</strong></p><blockquote><p>扇区校验码等</p></blockquote></li></ul></li><li><p>磁盘分区：每个分区由若干柱面组成</p><blockquote><p>这是为了<strong>操作系统</strong>能将自己的数据结构记录在磁盘上</p></blockquote></li><li><p>逻辑格式化：建立<strong>文件系统</strong></p><ul><li><p>建立<strong>根目录</strong>文件</p></li><li><p>建立用于<strong>存储空间管理</strong>的数据结构</p><blockquote><p>位示图、空闲分区表等</p></blockquote></li></ul></li></ol></li><li><p><u>引导块的管理</u></p><ul><li><p><strong>初始化程序/自举程序</strong>：完成计算机启动时的初始化工作</p><ul><li>若将整个初始化程序存放于ROM中，则无法修改，灵活性差</li></ul></li><li><p><strong>引导块/启动块/启动分区</strong>：位于磁盘的固定位置，存放完整的初始化程序</p><ul><li><p>拥有启动分区的磁盘称为<strong>启动磁盘</strong>或<strong>系统磁盘</strong></p><blockquote><p>例如Windows中的C盘</p></blockquote></li></ul></li><li><p>自举装入程序：<strong>ROM</strong>中存放的较小的装入程序，计算机启动时运行，从而找到引导块，读入完整的<strong>自举程序</strong>到<strong>内存</strong>，完成初始化</p></li></ul></li><li><p><u>坏块的管理</u></p><ul><li><p>坏块的概念：无法正常使用的<strong>扇区</strong></p><ul><li>属于<strong>硬件故障</strong>，操作系统无法修复</li><li>应当将<strong>坏块标记</strong>，以免错误使用</li></ul></li><li><p>坏块的标记：</p><ul><li><p><strong>对操作系统不透明</strong>的方法：<strong>逻辑格式化</strong>时将坏块标记出来</p><blockquote><p>例如：在FAT上标明</p><p>适用于简单的磁盘</p></blockquote></li><li><p><strong>对操作系统透明</strong>的方法：<strong>物理格式化</strong>时，<strong>磁盘控制器</strong>就开始维护一个<strong>坏块链</strong>，并管理<strong>备用扇区</strong>，替换坏块</p><blockquote><p>磁盘控制器是是磁盘内部的硬件部件；</p><p>这种方式也叫<strong>扇区备用方案</strong>，适用于复杂磁盘</p></blockquote></li></ul></li></ul></li></ul><h2 id="_5-设备管理" tabindex="-1"><a class="header-anchor" href="#_5-设备管理" aria-hidden="true">#</a> 5 设备管理</h2><h3 id="_5-1-基本概念" tabindex="-1"><a class="header-anchor" href="#_5-1-基本概念" aria-hidden="true">#</a> 5.1 基本概念</h3><div class="hint-container info"><p class="hint-container-title">基本概念</p><ul><li><a href="#I/O%E8%AE%BE%E5%A4%87%E7%9A%84%E6%A6%82%E5%BF%B5">I/O设备的概念</a></li><li><a href="#I/O%E8%AE%BE%E5%A4%87%E7%9A%84%E5%88%86%E7%B1%BB">I/O设备的分类</a></li></ul></div><hr><h4 id="i-o设备的概念" tabindex="-1"><a class="header-anchor" href="#i-o设备的概念" aria-hidden="true">#</a> <em>I/O设备的概念：</em></h4><ul><li><p>将<strong>数据输入/输出</strong>计算机的外部设备</p><blockquote><p>UNIX系统将外部设备抽象为一种<strong>特殊文件</strong>，用户可以使用与文件操作相同的方式对外部设备进行操作</p></blockquote></li><li><p>属于计算机中的硬件部件</p></li></ul><hr><h4 id="i-o设备的分类" tabindex="-1"><a class="header-anchor" href="#i-o设备的分类" aria-hidden="true">#</a> <em>I/O设备的分类：</em></h4><ul><li><p><u>按<strong>使用特性</strong>分类</u></p><ul><li><p><strong>人机交互</strong>类外部设备</p><blockquote><p>如键盘、鼠标、打印机等；</p><p>数据传输速度慢</p></blockquote></li><li><p><strong>存储</strong>设备</p><blockquote><p>如移动硬盘、光盘等；</p><p>数据传输速度快</p></blockquote></li><li><p><strong>网络通信</strong>设备</p><blockquote><p>如调制解调器等；</p><p>数据传输速度介于二者之间</p></blockquote></li></ul></li><li><p><u>按<strong>传输速率</strong>分类</u></p><ul><li><p>低速设备</p><blockquote><p>如鼠标、键盘等；</p><p>传输速率为每秒几个到几百个字节</p></blockquote></li><li><p>中速设备</p><blockquote><p>如激光打印机等；</p><p>传输速率为每秒数千到上万个字节</p></blockquote></li><li><p>高速设备</p><blockquote><p>如磁盘等；</p><p>传输速率为每秒数千到千兆个字节</p></blockquote></li></ul></li><li><p><u>按<strong>信息交换</strong>的单位分类</u></p><ul><li><p>块设备</p><ul><li>传输速率较高</li><li>可寻址：可以随机读/写任一块</li></ul><blockquote><p>如磁盘等；</p><p>数据传输的<strong>基本单位是“块”</strong></p></blockquote></li><li><p>字符设备</p><ul><li>传输速率较低</li><li><strong>不可寻址</strong></li><li>在输入/输出时常采用<strong>中断</strong>驱动方式</li></ul><blockquote><p>如鼠标、键盘等；</p><p>数据传输的<strong>基本单位是字符或字节</strong></p></blockquote></li></ul></li></ul><h3 id="_5-2-i-o控制" tabindex="-1"><a class="header-anchor" href="#_5-2-i-o控制" aria-hidden="true">#</a> 5.2 I/O控制</h3><div class="hint-container info"><p class="hint-container-title">I/O 控制</p><ul><li><a href="#I/O%E6%8E%A7%E5%88%B6%E5%99%A8">I/O控制器</a></li><li><a href="#I/O%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F">I/O控制方式</a></li></ul></div><h4 id="i-o控制器" tabindex="-1"><a class="header-anchor" href="#i-o控制器" aria-hidden="true">#</a> <em>I/O控制器：</em></h4><ul><li><p><u>I/O设备的构成</u></p><ul><li><p>机械部件：用于<strong>执行具体I/O操作</strong>的部分</p><blockquote><p>例如鼠标和键盘的按钮、显示器的LED屏、移动硬盘的磁臂、移动硬盘的磁盘盘面等</p></blockquote></li><li><p><strong>电子部件/IO控制器/设备控制器</strong>：一块插入主板扩充槽的印刷电路板，操作系统通过电子部件间接控制机械部件</p></li></ul></li><li><p><u>I/O控制器主要功能(对外)</u></p><ul><li><p><strong>控制</strong>：接受和识别CPU发出的命令</p></li><li><p><strong>状态</strong>：向CPU报告设备的状态</p></li><li><p><strong>数据</strong>：数据交换</p></li><li><p><strong>地址</strong>：地址识别</p><ul><li>I/O控制器为上述各寄存器设置特定“地址”，通过CPU提供的地址判断要读/写的寄存器</li></ul></li></ul><blockquote><p>一个 I/O 控制器可以控制多个设备</p></blockquote></li><li><p><u>I/O控制器的内部组成与功能</u></p><ul><li><p>CPU与控制器的接口</p><ul><li><p>功能：在CPU与控制器之间<strong>传输信号</strong></p></li><li><p>组成部分：</p><ul><li><p><strong>控制寄存器</strong>：存放命令和参数</p><blockquote><p>如CPU发来的read/write命令</p></blockquote></li><li><p><strong>状态寄存器</strong>：记录I/O设备当前状态</p><blockquote><p>如1表示空闲，0表示忙碌</p></blockquote></li><li><p><strong>数据寄存器</strong>：在输入/输出时暂存数据，CPU通过数据线取出和放入数据</p></li></ul><blockquote><p>不存在“地址寄存器”，因为有地址总线</p></blockquote></li></ul></li><li><p>I/O逻辑：</p><ul><li><p>功能：识别CPU发出的命令，并向设备发出命令，实现<strong>对设备的控制</strong></p><blockquote><p>CPU 在设备面前的“代理”</p></blockquote></li><li><p>重要接口</p><ul><li><strong>地址线</strong>：CPU通过地址线指明要操作的<strong>设备</strong></li><li><strong>控制线</strong>：CPU通过控制线发出<strong>命令</strong></li><li>连接控制、状态、数据三个寄存器与设备的接口</li></ul></li></ul></li><li><p>控制器与设备的接口</p><ul><li><p>功能：在控制器与设备之间<strong>传输信号</strong></p><blockquote><p>注意，该接口主要用于传输信号，实际用于控制设备的是 I/O 逻辑</p></blockquote></li><li><p>组成部分</p><ul><li><p><strong>数据</strong>部分：传送要输入/输出的数据</p></li><li><p><strong>状态</strong>部分：设备向控制器反馈状态</p><blockquote><p>忙碌或空闲</p></blockquote></li><li><p><strong>控制</strong>部分：控制器向设备发出控制信息</p></li></ul></li></ul></li></ul></li><li><p><u>两种设备编址方式</u></p><blockquote><p>一个I/O控制器可以控制多个设备。数据寄存器、控制寄存器、状态寄存器可以有多个，这些寄存器都要有相应的<strong>地址</strong></p></blockquote><ul><li><strong>内存映像I/O</strong><ul><li>编址方式：控制器中的寄存器与内存<strong>统一编址</strong></li><li>优点：可以采用<strong>对内存操作的指令</strong>来对控制器进行操作</li><li>缺点：占用内存地址空间</li></ul></li><li><strong>寄存器独立编址</strong><ul><li>编址方式：控制器中的寄存器独立编址</li><li>优点：不占用内存地址空间</li><li>缺点：需要设置<strong>专门的指令</strong>来操作控制器</li></ul></li></ul></li></ul><hr><h4 id="i-o控制方式" tabindex="-1"><a class="header-anchor" href="#i-o控制方式" aria-hidden="true">#</a> <em>I/O控制方式：</em></h4><blockquote><p>总体来说，I/O控制方式的发展过程就是要尽量<strong>减少CPU对I/O过程的干预</strong>，将CPU从I/O中解脱出来，以便高效处理数据任务</p></blockquote><ul><li><p><u>程序直接控制方式</u></p><ul><li><p>读写流程：轮询</p><blockquote><p>以读操作为例具体讲解。其他方式的读写流程可以类比</p></blockquote><ol><li><p>CPU向控制器发出读指令，设备启动，<strong>状态寄存器</strong>设为1</p></li><li><p>CPU轮询检查控制器状态，直到状态寄存器变为0</p></li><li><p>输入设备准备数据后将数据传给控制器，并报告状态</p><blockquote><p>这里的状态可能是正常，也可能是<strong>错误条件</strong></p></blockquote></li><li><p>控制器接收数据存入<strong>数据寄存器</strong>中，修改状态寄存器为0</p></li><li><p>CPU发现设备就绪，从数据寄存器中读取数据至<strong>寄存器</strong>，再存入<strong>内存</strong></p></li><li><p>如果还需要读取数据，CPU可以继续发出读指令</p></li></ol></li><li><p>CPU干预频率：极高</p><ul><li>一次I/O开始前、完成后需要CPU介入</li><li>一次I/O过程中CPU需要轮询</li></ul></li><li><p>数据传输</p><ul><li>单位：每次读/写<strong>一个字</strong></li><li>流向： <ul><li>读：I/O设备<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rarr</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span>CPU寄存器<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rarr</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span>内存</li><li>写：内存<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rarr</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span>CPU寄存器<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rarr</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span>I/O设备</li></ul></li></ul></li><li><p>评价</p><ul><li><p>优点：<strong>实现简单</strong>，在读/写指令后，加上实现轮询逻辑的一系列指令即可</p><blockquote><p>因此得名“程序直接控制方式”</p></blockquote></li><li><p>缺点：CPU和I/O设备<strong>串行</strong>工作，CPU需要轮询“忙等”，<strong>资源利用率低</strong></p></li></ul></li></ul></li><li><p><u>中断驱动方式</u></p><ul><li><p>读写流程：中断</p><ol><li><p>CPU发出I/O命令，<strong>阻塞</strong>等待I/O的进程，切换到其他进程执行其他命令</p></li><li><p>I/O完成后，<strong>控制器</strong>向CPU发出<strong>中断信号</strong></p></li><li><p>CPU检测到中断信号，保存进程现场，执行<strong>中断处理程序</strong></p><blockquote><p>CPU会在每条指令末尾检测中断信号；</p><p>中断处理过程需要保存、恢复进程运行环境，有一定开销，可能降低系统性能</p></blockquote></li><li><p>CPU、I/O控制器、主存交换数据</p></li><li><p>I/O结束后，CPU恢复等待I/O的进程</p></li></ol></li><li><p>CPU干预频率</p><ul><li>一次I/O开始前、完成后需要CPU介入</li><li>一次I/O过程中CPU可以切换到其他进程</li></ul></li><li><p>数据传输</p><ul><li>单位：每次读/写<strong>一个字</strong></li><li>流向： <ul><li>读：I/O设备<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rarr</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span>CPU寄存器<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rarr</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span>内存</li><li>写：内存<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rarr</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span>CPU寄存器<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rarr</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span>I/O设备</li></ul></li></ul></li><li><p>评价</p><ul><li>优点：I/O过程中CPU和I/O设备可<strong>并行工作</strong>，<strong>资源利用率提升</strong></li><li>缺点：频繁中断处理会消耗CPU较多时间</li></ul></li></ul></li><li><p><u>DMA方式</u></p><ul><li><p>DMA(Direct Memory Access)控制器：一种特殊的I/O控制器</p><ul><li>DR(Data Register)：暂存<strong>设备与内存</strong>之间传递的数据</li><li>MAR(Memory Address Register)：指明数据 <strong>在内存/存放到内存</strong> 中的位置</li><li>DC(Data Counter)：剩余要读/写的字节数</li><li>CR(Command Register)：存放CPU发来的<strong>I/O命令</strong>或<strong>设备状态</strong></li></ul></li><li><p>读写流程：</p><ol><li><p>CPU向DMA发出命令，阻塞I/O进程，切换到其他进程</p><ul><li>操作类型</li><li>数据量</li><li>内存地址</li><li>外部设备地址</li></ul></li><li><p>DMA准备好<strong>一块数据</strong>后，向CPU发出中断信号</p><blockquote><p>相比于单纯的中断，一定程度上可以与 CPU 并行</p></blockquote></li></ol></li><li><p>CPU干预频率</p><ul><li>一次I/O开始前、完成后需要CPU介入</li><li>一次I/O过程中CPU可以切换到其他进程</li></ul></li><li><p>数据传输</p><ul><li><p>单位：每次读/写<strong>一块或多块连续数据</strong>（一批数据）</p><blockquote><p>如果要操作多块数据，则必须是<strong>连续的多块数据</strong>，离散的多块依然需要<strong>中断</strong></p></blockquote></li><li><p>流向：</p><ul><li>读：I/O设备<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rarr</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span>内存</li><li>写：内存器<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rarr</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span>I/O设备</li></ul></li></ul></li><li><p>评价</p><ul><li>优点：数据传输<strong>以“块”为单位</strong>，CPU介入频率降低；内存与设备之间数据传输不需要经过CPU，提升数据传输率，提高CPU与I/O设备并行性。</li><li>缺点：CPU每发出一条I/O指令，只可以读写一个或多个连续块。如果要读写多个离散块，或要写入离散内存区域，CPU需要发出多条I/O指令，经历多次<strong>中断</strong>。</li></ul></li></ul></li><li><p><u>通道控制方式</u></p><ul><li><p>通道：也叫 I/O 处理机，一种硬件，可以识别CPU指令，并执行一系列<strong>通道指令</strong>，控制<strong>I/O控制器</strong>操作设备</p><blockquote><p>通道可以执行的指令很单一，且通道程序存放于内存中，与CPU共享内存，可以看成一个“简单版”CPU；</p><p>一个系统中可以有多个通道，一个通道可以控制多个I/O控制器，一个I/O控制器也可以控制多个I/O设备</p></blockquote></li><li><p>读写流程：</p><ol><li>CPU向通道发出I/O指令，指明<strong>通道程序</strong>在<strong>内存</strong>中的位置，指明<strong>要操作的设备</strong>，阻塞I/O进程，切换到其他进程</li><li>通道执行<strong>通道程序</strong><ul><li>操作类型</li><li>数据量</li><li>内存地址</li><li>外部设备地址</li></ul></li><li>通道执行完任务后，向CPU发出<strong>中断</strong>信号，CPU处理中断</li></ol></li><li><p>CPU干预频率：极低</p><ul><li>一次通道程序执行开始前、完成后需要CPU介入</li><li>一次通道程序执行过程中CPU可以切换到其他进程</li></ul></li><li><p>数据传输</p><ul><li>单位：每次读/写<strong>一组数据块</strong></li><li>流向： <ul><li>读：I/O设备器<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rarr</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span>内存</li><li>写：内存器<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rarr</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span>I/O设备</li></ul></li></ul></li><li><p>评价</p><ul><li><p>优点：CPU、通道、I/O设备可并行工作，资源利用率很高</p><blockquote><p>通道和中断技术结合能实现CPU与I/O的<strong>并行</strong>工作。通道可以独立于CPU运行，中断可以避免CPU轮询</p></blockquote></li><li><p>缺点：需要专门的通道硬件支持</p><blockquote><p>字节多路通道用作连接大量的低速或中速 I/O 设备</p></blockquote></li></ul></li></ul></li></ul><h3 id="_5-3-i-o系统" tabindex="-1"><a class="header-anchor" href="#_5-3-i-o系统" aria-hidden="true">#</a> 5.3 I/O系统</h3><h4 id="i-o软件层次结构" tabindex="-1"><a class="header-anchor" href="#i-o软件层次结构" aria-hidden="true">#</a> <em>I/O软件层次结构：</em></h4><ul><li><p><u>用户层软件</u></p><ul><li>对上层的服务：实现与用户交互的接口，提供方便的<strong>库函数</strong></li><li>对下层的调用：将用户请求翻译成格式化的I/O请求，通过<strong>系统调用</strong>请求操作系统内核服务</li></ul></li><li><p><u>设备独立性软件/系统调用处理层</u></p><ul><li><p>对上层的服务：提供统一的系统调用接口，将系统调用参数翻译成设备操作命令；进行<strong>I/O调度</strong></p></li><li><p>对下层的封装：</p><ul><li><p><strong>设备保护</strong>：将设备看作特殊的文件，类似<strong>文件保护</strong></p></li><li><p><strong>差错处理</strong>：对设备的错误进行处理</p></li><li><p><strong>数据缓冲区管理</strong>：通过缓冲技术屏蔽设备之间数据交换单位和传输速度的差异</p></li><li><p><strong>设备分配与回收</strong>：对设备这种<strong>临界资源</strong>进行分配回收</p></li><li><p><strong>设备映射</strong>：通过<strong>逻辑设备表（LUT）</strong>，建立<strong>逻辑设备名与物理设备名</strong>的映射关系；根据设备类型调用相应的驱动程序</p><blockquote><p>逻辑设备表（LUT），也可称为<strong>设备映射表（DMT）</strong></p><p>LUT的字段：</p><ul><li>逻辑设备名：以<strong>文件路径</strong>的形式体现</li><li>物理设备名</li><li><strong>驱动程序入口地址</strong>，每种类型 I/O 设备都需要一个驱动程序</li></ul><p>LUT管理方式：</p><ul><li>整个操作系统只有一张</li><li>每个用户均有一张，存放于用户管理进程的PCB中</li></ul></blockquote></li></ul></li></ul></li><li><p><u>设备驱动程序 / 命令解释程序</u></p><blockquote><p>直接与硬件交互，进行与中断无关的操作</p></blockquote><ul><li><p>对上层的服务：解释并执行上层 <strong>I/O 命令</strong>，转化为特定的<strong>设备操作</strong></p></li><li><p>对下层的调用：控制硬件，执行符合硬件特性的驱动；设置设备寄存器，检查设备状态等</p><blockquote><p>驱动程序一般会以一个<strong>独立进程</strong>的方式存在。<strong>每类</strong>设备只需要<strong>一个</strong>驱动程序</p></blockquote></li></ul></li><li><p><u>中断处理程序</u></p><blockquote><p>直接与硬件交互，进行与中断有关的操作</p></blockquote><ul><li>对上层的服务：提供<strong>对中断的处理</strong></li><li>对下层的调用：接收控制器的<strong>中断信号</strong>，处理I/O数据</li></ul></li><li><p><u>硬件层</u>：参考“<strong>I/O控制</strong>”小节</p></li></ul><hr><h4 id="i-o核心子系统功能" tabindex="-1"><a class="header-anchor" href="#i-o核心子系统功能" aria-hidden="true">#</a> <em>I/O核心子系统功能：</em></h4><blockquote><p>I/O核心子系统包括：</p><ul><li>设备独立性软件</li><li>设备驱动程序</li><li>中断处理程序</li></ul></blockquote><ul><li><p><u>I/O调度</u></p><ul><li><p>用某种<strong>算法</strong>确定一个<strong>处理I/O请求的顺序</strong></p><blockquote><p>例如：先来先服务、优先级算法、短作业优先算法等</p></blockquote></li></ul></li><li><p><u>设备保护</u></p><ul><li>操作系统提供<strong>文件保护</strong>功能，管理<strong>用户访问权限</strong></li><li>将<strong>设备</strong>看作特殊的<strong>文件</strong>，有对应的FCB</li></ul></li><li><p><u>假脱机技术 / SPOOLing 技术</u></p><ul><li><p><strong>脱机技术</strong></p><ul><li><p>工作方式：在<strong>外围控制机</strong>控制下，以<strong>磁带</strong>作为中介，<strong>设备</strong>与磁带数据交换，<strong>主机</strong>与磁带数据交换</p><blockquote><p>这个过程不需要主机/CPU的控制，所以叫“脱机”</p></blockquote></li><li><p>作用：缓解设备与CPU的速度矛盾，实现<strong>预输入、缓输出</strong></p></li></ul></li><li><p><strong>假脱机技术</strong>：用<strong>软件</strong>的方式模拟脱机技术</p><ul><li><p><strong>输入井与输出井</strong>：在<strong>磁盘</strong>中开辟出的两块存储区域，模拟<strong>脱机技术中的磁带</strong>，分别收容<strong>I/O设备输入与普通进程输出</strong>的数据</p><blockquote><p>有<strong>井管理程序</strong>的支持</p></blockquote></li><li><p><strong>输入进程与输出进程</strong>：模拟脱机输入输出时的<strong>外围控制机</strong>，协调“井”和<strong>设备</strong></p><blockquote><p>所以，要实现 SPOOLing 技术，必须要有<strong>多道程序技术</strong>的支持；</p><p>所以，提高单机资源利用率的关键技术依然是<strong>多道程序设计技术</strong>；</p><p>注意这里是用<strong>多进程模拟外围计算机</strong>，而不需要真的外围计算机</p></blockquote></li><li><p><strong>输入缓冲区与输出缓冲区</strong>：<strong>内存</strong>中的缓冲区，由输入进程与输出进程管理，在<strong>输入输出设备</strong>与<strong>输入输出井</strong>之间缓冲</p><blockquote><p>输入输出进程配合缓冲区实现<strong>预输入和缓输出程序</strong>；</p><p>普通进程的输出先到<strong>输出井</strong>，再经<strong>输出缓冲区</strong>到输出设备，而输入设备的输入先经<strong>输入缓冲区</strong>再到<strong>输入井</strong></p></blockquote></li></ul></li><li><p><strong>作用</strong>：用 SPOOLing 技术可以将<strong>独占式</strong>设备改造成<strong>共享</strong>设备</p><blockquote><p>举例：共享打印机</p><ul><li>相关数据结构 <ul><li><strong>输出井中的空闲缓冲区</strong>：存放用户要打印的数据</li><li><strong>假脱机文件队列</strong>：存放打印请求表（说明用户的打印数据<strong>存放位置</strong>等信息）</li></ul></li><li>工作流程 <ol><li>用户进程提出打印请求</li><li>系统应答用户请求，为该进程分配<strong>输出井</strong>中的<strong>空闲缓冲区</strong>，并建立<strong>打印请求表</strong>，挂到假脱机文件队列上</li><li>打印机空闲时，取出一张打印请求表，将数据从输出井送往<strong>输出缓冲区</strong>，再<strong>输出</strong>到打印机，处理打印任务</li></ol></li><li>共享性的实现 <ul><li>用输出井为每个打印进程分配<strong>存储区</strong>，相当于分配<strong>逻辑设备</strong>，实现共享性</li></ul></li></ul></blockquote></li></ul></li><li><p><u>设备的分配与回收</u></p><ul><li><p>设备<strong>固有属性</strong>/设备的独占式性与共享性</p><ul><li><p>独占式设备：只允许各个进程<strong>串行</strong>使用的设备</p><blockquote><p>例如：打印机、磁带机、扫描仪</p><p>分配独占设备可能引发死锁</p></blockquote></li><li><p>共享设备：一段时间内允许多个进程<strong>并发</strong>使用的设备</p><blockquote><p>例如：磁盘</p><p>往往是宏观上并行，微观上交替，注意是一段时间而不是同一时间。</p><p>分配共享设备不会引发死锁</p></blockquote></li><li><p>虚拟设备：采用 <strong>SPOOLing技术</strong> 将独占设备改造成虚拟的共享设备，允许<strong>多进程共享</strong></p><blockquote><p>把一个物理设备变成<strong>多个</strong>对应的<strong>逻辑</strong>设备</p></blockquote></li></ul></li><li><p>设备<strong>分配算法</strong>：与I/O调度算法类似，有先来先服务、优先级、短作业优先等等</p></li><li><p>设备<strong>安全性</strong>：</p><ul><li><p><strong>安全分配</strong>方式：为进程分配一个设备后就将其阻塞，直到I/O完成再唤醒</p><blockquote><p>一段时间内每个进程只能使用一个设备，破坏了“请求和保持”条件，但对一个进程来说，CPU和I/O设备只能串行工作</p></blockquote></li><li><p><strong>不安全分配</strong>方式：为进程分配一个设备后，进程可继续执行并发出新的I/O请求，只有某个I/O请求得不到满足时才将进程阻塞</p><blockquote><p>一个进程可同时使用多个设备，可以并发处理计算任务和I/O任务，但有可能发生死锁，需要死锁避免、死锁的检测和解除</p></blockquote></li></ul></li><li><p>设备独立性：</p><ul><li>概念：用户在<strong>编程</strong>时使用的设备与实际设备无关</li><li>优点： <ul><li>方便用户编程，便于程序移植，使程序运行不受具体机器环境的限制</li><li>可以提高分配的灵活性和设备的利用率</li></ul></li></ul></li><li><p>设备<strong>静态分配与动态分配</strong></p><ul><li><p>静态分配：进程运行前为其分配全部所需资源，运行结束后归还资源</p><blockquote><p>破坏“请求和保持”条件；<strong>独占设备</strong>常采用</p></blockquote></li><li><p>动态分配：进程运行过程中动态申请设备资源</p><blockquote><p><strong>共享设备</strong>常采用</p></blockquote></li></ul></li><li><p>设备分配管理中的<strong>数据结构</strong></p><ul><li><p>通道控制表（CHCT）：每个通道均有一张，记录其信息</p><ul><li><p>通道<strong>标识符</strong>：各通道的唯一ID</p></li><li><p>通道<strong>状态</strong>：忙碌、空闲、故障等</p></li><li><p>与通道连接的控制器表首址：通过该指针可以找到所有COCT</p><blockquote><p>系统中可以有多个通道，一个通道可控制多个I/O控制器，一个I/O控制器又可控制多个设备</p></blockquote></li><li><p>通道队列的指针：指向正在等待该通道的<strong>进程队列</strong>（由进程PCB组成）</p><blockquote><p>回顾：系统会根据阻塞原因不同，将进程PCB挂到不同的阻塞队列中。接下来的控制器队列和通道队列也同理</p></blockquote></li></ul></li><li><p><strong>控制器控制表</strong>（COCT）：每个I/O控制器均有一张，记录其信息</p><ul><li>控制器<strong>标识符</strong>：各I/O控制器的唯一ID</li><li>控制器<strong>状态</strong>：忙碌、空闲、故障等</li><li>指向<strong>通道控制表</strong>的指针</li><li><strong>控制器队列</strong>的指针：指向正在等待该I/O控制器的<strong>进程队列</strong>（由进程PCB组成）</li></ul></li><li><p><strong>设备控制表</strong>（DCT）：每个设备均有一张，记录设备情况</p><ul><li><p>设备<strong>类型</strong>：打印机、扫描仪、键盘等</p></li><li><p>设备<strong>标识符</strong>：即<strong>物理设备名</strong>，系统中每个设备的物理设备名唯一</p><blockquote><p>计算机系统为每台设备确定一个编号以便<strong>区分和识别</strong>设备，这个确定的编号称为设备的<strong>绝对号</strong></p></blockquote></li><li><p>设备<strong>状态</strong>：忙碌、空闲、故障等</p></li><li><p>指向<strong>控制器控制表</strong>的指针</p></li><li><p>重复执行次数或时间：重复多次I/O操作或一段时间或I/O仍然不成功，则认为I/O失败</p></li><li><p><strong>设备队列</strong>的指针：指向正在等待该设备的<strong>进程队列</strong>（由进程PCB组成）</p></li></ul></li><li><p>系统设备表（SDT）：记录系统中全部设备的情况，每个设备对应一个条目</p><ul><li><p>设备<strong>类型</strong></p></li><li><p>设备<strong>标识符</strong></p></li><li><p><strong>DCT</strong></p></li><li><p><strong>驱动程序入口</strong></p></li></ul></li></ul></li><li><p>设备<strong>分配流程</strong>及其改进</p><ol><li><p>根据进程请求的<strong>物理设备名</strong>查找<strong>SDT</strong></p><blockquote><p>使用<strong>物理设备名</strong>的缺点：</p><ul><li><strong>底层细节</strong>对用户不透明，编程不方便</li><li>若<strong>更换</strong>物理设备，则进程无法运行（因为把名写死了）</li><li>若设备正在忙碌，进程必须<strong>阻塞</strong>，无法使用<strong>同类型设备</strong>（因为把名写死了）</li></ul><p>改进：</p><ul><li>用户只需提供逻辑设备名或<strong>设备类型</strong></li><li>建立逻辑设备表（LUT），若在表中找到符合要求的设备可直接尝试分配</li></ul></blockquote></li><li><p>根据<strong>SDT</strong>找到<strong>DCT</strong>，若设备<strong>忙碌</strong>则将进程PCB挂到<strong>设备队列</strong>，不忙碌则分配设备</p><blockquote><p>改进：</p><ul><li>查找SDT中<strong>指定类型且空闲</strong>的设备，找到则分配，都忙碌则阻塞</li><li>分配成功后在逻辑设备表中<strong>新增表项</strong></li></ul></blockquote></li><li><p>根据DCT找到COCT，若I/O控制器<strong>忙碌</strong>则将进程PCB挂到<strong>控制器队列</strong>，不忙碌则分配设备</p></li><li><p>根据COCT找到CHCT，若通道<strong>忙碌</strong>则将进程PCB挂到<strong>通道队列</strong>，不忙碌则分配设备</p></li><li><p>只有设备、控制器、通道均分配成功，这次设备分配才算成功，然后可以启动I/O设备进行数据传输</p></li></ol></li></ul></li><li><p><u>缓冲区管理</u></p><ul><li><p>缓冲区概述</p><ul><li><p>概念：本节课中指的是<strong>内存缓冲区</strong>，是<strong>设备独立性软件</strong>负责管理好的缓冲区</p><blockquote><p>磁盘必须使用缓冲技术，鼠标、图形卡等也有必要使用缓冲技术</p></blockquote></li><li><p>特性：向缓冲区<strong>充入数据</strong>与从缓冲区<strong>取出数据</strong>的操作必须串行，禁止边充边取</p></li><li><p>作用：</p><ul><li>缓和CPU与I/O设备<strong>速度不匹配</strong>的矛盾</li><li>提高CPU与I/O设备之间并行性</li><li>减少CPU<strong>中断频率</strong></li><li>解决<strong>数据粒度不匹配</strong>问题</li></ul></li><li><p>工作框架：设备--(T)--缓冲区--(M)--工作区--(C)--处理</p><ul><li><strong>块设备</strong>：即慢速I/O设备</li><li><strong>缓冲区</strong>：位于<strong>内存</strong>中，与块设备进行<strong>数据输入/输出（T）</strong></li><li><strong>进程工作区</strong>：位于<strong>内存</strong>中，与缓冲区进行<strong>数据传送（M）</strong></li><li><strong>CPU</strong>：对进程工作区的数据进行<strong>处理（C）</strong></li></ul><blockquote><p>只有 C 和 T 是可以并行的</p></blockquote></li></ul></li><li><p><strong>单缓冲</strong></p><ul><li><p>策略：操作系统为本次请求读写的块设备在<strong>主存</strong>中分配<strong>一个缓冲区</strong></p><blockquote><p>若无特殊说明，一个缓冲区大小就是<strong>一块</strong></p></blockquote></li><li><p>处理<strong>一块数据</strong>的平均耗时：Max(C, T) + M</p><blockquote><p>分析问题的初始状态：工作区满、缓冲区空。从一个初始状态到达另一个初始状态即为无限多次处理数据的平均耗时</p><p>一开始 C 和 T 就可以并行，但 M 要等 C 和 T 都结束才能进行，因为缓冲区不能边充边取，CPU 也不能边工作边取缓冲区中的数据，且缓冲区满后必须先等 CPU 取出再充入</p></blockquote><blockquote><p>如果不是无限多次处理数据，而是特定几块数据，则先计算<strong>从全空到达初始状态</strong>的时间，然后用<strong>平均</strong>时间计算除了最后一块外的所有块，最后一块从初始状态开始，<strong>不考虑下一块的读入</strong>，单独计算</p></blockquote></li><li><p>主机间通信时的应用：若两机配置单缓冲区，则同一时刻只能一方发送、一方接收</p></li></ul></li><li><p><strong>双缓冲</strong></p><ul><li><p>策略：操作系统为本次请求读写的块设备在<strong>主存</strong>中分配<strong>两个缓冲区</strong></p></li><li><p>处理<strong>一块数据</strong>的平均耗时：Max(T, C+M)</p><blockquote><p>分析问题的初始状态：工作区空，一个缓冲区满、另一个缓冲区空</p><p>一开始 M 和 T 可以并行，C 必须在 M 后，由于缓冲区不能边充边取，要回到初始状态，必须等 T 和 C+M 都结束</p></blockquote></li><li><p>主机间通信时的应用：若两机配置双缓冲区，则可以同时发送与接收</p></li></ul></li><li><p><strong>循环缓冲</strong>：多个缓冲区链接成<strong>循环队列</strong>，in 指针指向第一个空缓冲区，out 指针指向第一个满缓冲区</p></li><li><p><strong>缓冲池</strong></p><ul><li>三个队列： <ul><li>空缓冲队列：存储<strong>空缓冲区</strong></li><li>输入队列：存储存放了<strong>输入数据</strong>的缓冲区</li><li>输出队列：存储存放了<strong>输出数据</strong>的缓冲区</li></ul></li><li>四种工作缓冲区 <ul><li>收容输入（hin）：<strong>输入进程输入</strong>时会从<strong>空缓冲队列</strong>中摘下缓冲区置于此，接收完输入后再挂到<strong>输入队列</strong>中</li><li>提取输入（sin）：<strong>计算进程取得输入</strong>时会从<strong>输入队列</strong>中摘下缓冲区置于此，提取输入后再挂回<strong>空缓冲队列</strong></li><li>收容输出（hout）：<strong>计算进程产生输出</strong>时会从<strong>空缓冲队列</strong>中摘下缓冲区置于此，接收完输出后再挂到<strong>输出队列</strong>中</li><li>提取输出（sout）：<strong>输出进程输出</strong>时会从<strong>输出队列</strong>中摘下缓冲区置于此，提取输出后再挂回<strong>空缓冲队列</strong></li></ul></li></ul></li></ul></li></ul></div><!----><footer class="page-meta"><div class="meta-item edit-link"><a href="https://github.com/SunDocker/SunDocker.github.io/edit/main/docs/notes/Theory/OperationSystem.md" rel="noopener noreferrer" target="_blank" aria-label="Edit this page on GitHub" class="nav-link label"><!--[--><svg xmlns="http://www.w3.org/2000/svg" class="icon edit-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="edit icon"><path d="M430.818 653.65a60.46 60.46 0 0 1-50.96-93.281l71.69-114.012 7.773-10.365L816.038 80.138A60.46 60.46 0 0 1 859.225 62a60.46 60.46 0 0 1 43.186 18.138l43.186 43.186a60.46 60.46 0 0 1 0 86.373L588.879 565.55l-8.637 8.637-117.466 68.234a60.46 60.46 0 0 1-31.958 11.229z"></path><path d="M728.802 962H252.891A190.883 190.883 0 0 1 62.008 771.98V296.934a190.883 190.883 0 0 1 190.883-192.61h267.754a60.46 60.46 0 0 1 0 120.92H252.891a69.962 69.962 0 0 0-69.098 69.099V771.98a69.962 69.962 0 0 0 69.098 69.098h475.911A69.962 69.962 0 0 0 797.9 771.98V503.363a60.46 60.46 0 1 1 120.922 0V771.98A190.883 190.883 0 0 1 728.802 962z"></path></svg><!--]-->Edit this page on GitHub<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!----></a></div><div class="meta-item git-info"><div class="update-time"><span class="label">Last update: </span><!----></div><div class="contributors"><span class="label">Contributors: </span><!--[--><!--[--><span class="contributor" title="email: sundocker@qq.com">SunDocker</span><!--]--><!--]--></div></div></footer><nav class="page-nav"><a href="/notes/Theory/DistributedSystem.html" class="nav-link prev" aria-label="Distributed System"><div class="hint"><span class="arrow start"></span>Prev</div><div class="link"><span class="font-icon icon iconfont icon-OS" style=""></span>Distributed System</div></a><a href="/notes/Theory/XV6LabSummary.html" class="nav-link next" aria-label="XV6 Lab Summary"><div class="hint">Next<span class="arrow end"></span></div><div class="link">XV6 Lab Summary<span class="font-icon icon iconfont icon-OS" style=""></span></div></a></nav><!----><!----><!--]--></main><!--]--><footer class="footer-wrapper"><div class="footer">Default footer</div><div class="copyright">Copyright © 2023 Dominic Sun</div></footer></div><!--]--><!----><!----><!--]--></div>
    <script type="module" src="/assets/app-aa324d52.js" defer></script>
  </body>
</html>
